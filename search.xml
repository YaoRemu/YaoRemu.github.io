<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Bootstrap CSS栅格、代码和表格]]></title>
    <url>%2F2019%2F04%2F23%2FBootstrap-CSS%E6%A0%85%E6%A0%BC%E3%80%81%E4%BB%A3%E7%A0%81%E5%92%8C%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[CSS栅格概述设置全局的CSS样式，基本的HTML元素均可以通过 class 设置，并且得到增强的效果，而且 Bootstrap着重介绍了 栅格系统（grid system）,也就意味着 栅格系统 非常重要，使用起来非常方便 Containers 容器栅格系统是 依赖容器 而存在的，Bootstrap 需要为页面内容和 栅格系统 包裹一个 容器Containers 好处给我们提供了一些 padding 属性，也就是像 margin 属性都有去设置一下，所以我们在使用的时候一定要包裹一个容器 123 ... 或者是使用下面这种方式，表示 百分百最宽 ，也就是能达到最大的使用范围，占据全部视口的整个容器，一般使用 container 即可 123 ... Grid systemBootstrap 给我们提供了一套响应式、移动式设备优先的流式栅格系统，它会随着屏幕的视口尺寸进行增加，系统也会自动最多分配，这里我们要记得是 12列 ，不管是在什么设备上，它最多只能承载 12列 介绍它必须通过 container 进行承载，栅格系统通用于一些系列的行与列的组合来创建一些页面布局，它有点类似于表格，但是使用起来确比表格方便得多 栅格的参数 Gird behavior 栅格系统行为表示以怎样的方式来布局 针对于不同屏幕 手机 平板 偏小桌面显示器 偏大桌面显示器 < 768px >= 768px >= 992px >= 1200px 布局方式针对于栅格系统的行为，其实就是它以怎样的方式来布局； 手机上的肯定是水平排列，在后面会有一些堆叠，然后根据屏幕的大小来自动释放 Container width 最大宽度 手机 平板 偏小桌面显示器 偏大桌面显示器 自适应 最大750px(它受最外层屏幕的限制) 790px 1170px Class preflx 前缀它给我们提供了所有的样式的使用我们必须遵循它所提供的 class 方式来进行书写，这一行是它针对不同屏幕的书写格式 手机 平板 偏小桌面显示器 偏大桌面显示器 .col-xs- .col-sm- .col-md- .col-lg- of columns 列数默认为 12列 最大的列宽 手机 平板 偏小桌面显示器 偏大桌面显示器 自适应 ~62px ~81px ~97px Gutter width 槽宽默认为 30px 其他另外它是 可嵌套的、 可偏移的 与 可以使用 列的排序 例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 .row{ margin-bottom: 20px; } .row .row{ margin-top: 10px; margin-bottom: 0px; } //通配方式： [class*="col-"] 选择所有类名中含有"col-"的元素 [class*="col-"]{ padding-top: 15px; padding-bottom: 15px; background-color: #eee; background-color: rgba(88,61,124,.15); border: 1p solid #ddd; border: 1px solid rgba(86,61,124,.2); } //注意：最大只能承载12个 //class名字 后面的数字表示当前所占的比例，1 代表 1/12 col-md-1 col-md-1 col-md-1 col-md-1 col-md-1 col-md-1 col-md-1 col-md-1 col-md-1 col-md-1 col-md-1 col-md-1 //一行承载4个 col-md-3 col-md-3 col-md-3 col-md-3 //如果内容过多，它采取自适应，自动调整高度或宽度 col-md-3col-md-3col-md-3col-md-3col-md-3col-md-3col-md-3col-md-3col-md-3col-md-3 col-md-3 col-md-3 col-md-3 //偏移 col-md-offset-偏移的个数 col-md-3 //嵌套 one first two //列的排序 col-md-9 col-md-3 CSS代码它的作用就是当我们想在网页中展示一些代码的时候，我们肯定要用到 code，比如我们会写个人博客，个人博客当中我们会 拷贝 一些代码放在上面供别人进行参考，这个时候我们就应该有一些关于代码的输入，那么它包含内联代码、用户输入、代码块、变量和程序输出 内联代码12345//这里我们不必要一定要使用容器，我们只是习惯性把容器放最外层 //我们通过 code标识 来包裹要作为代码片段的内容 For example & lt;section& gt; as inline eg: 我们可以看到代码的样式，它包含了一个尖括号以及背景和颜色突出的一个效果 用户输入单个字符用户输入在 Bootstrap 当中它模仿的是有命令行的输入方式的一个样式 123 我希望现在能键入 cmd 命令 eg: 这里我们可以看到，这个 cmd 明显是一个黑色包裹起来的代表它是一个用户输入 代码块12345 Sample text here...; eg: 可以看到它会有一个外边框，可以在里面加一些实体，比如说尖括号或者其他的一些实体效果。这里面的内容是可以直接复制的 变量123 x = y + z eg: 可以看到他是有一个 斜体的效果 程序输出123 hello world eg: 它没有什么特殊我们可以在页面上看到的一个效果，但是一般程序输出用这种方式来进行表示，既然它给我们了，我们就可以进行使用]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全局CSS样式-排版]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%85%A8%E5%B1%80CSS%E6%A0%B7%E5%BC%8F-%E6%8E%92%E7%89%88%2F</url>
    <content type="text"><![CDATA[由于我们暂时只是测试，所以我们不用去添加刚才我们所添加的那个响应式布局的标题 排版排版包含：标题、页面主体、内联文本元素、对齐、改变大小写、缩略语、地址、引用 和 列表 标题HTML5 中，所有标题标签从 H1 ~ H6 均是可以使用的，另外还提供了了 【 .h1 】 ~ 【 .h6 】 类，为的是给内联属性的文本赋值一些标题的样式 在标题后面通常会有一个相对于标题小一点甚至颜色淡一点的副标题，它也提供了一个 small 标签来进行赋值操作， 也提供了 【 .small 】 类的元素来作为副标题 注意： 它与最基本的 H1 ~ H6 （不使用 Bootstrap） 还是有区别的 12345678 姚大帅哥 姚大帅哥 姚大帅哥 //副标题 姚大帅哥欢迎你的到来 页面主体Bootstrap 将全局的 fontSize（字体大小） 设置为14px，行高设置为1.428，这些属性直接赋值 body，所有的段落元素都可以生效。 另外 p标签还被设置了等高为二分之一行高，也就是 10px的底部外边距 1234hellhellohellohellohellohellohello//突出显示操作hellhellohellohellohellohellohello 文本内联元素1Hello World: 姚钊超级大帅哥 提供了类似于被删除文本的标签: del 无用文本标签： s 插入文本： ins 带下划线的文本: u 还有很多类似于小号文本，着重斜体等等…. ，它都提供了相应的使用，这些都可以参考它所给出的 API 来进行写，因为只是非常简单的通过它所给定的的标签来使用即可 文本的对齐123456//居左你好吗？//居右你好吗？//居中你好吗？ 改变字母的大小写123456//全部小写ABC//全部大写DEF//首字母大写hij 缩略语1hellohellohellohellohello eg: 地址123456 姚大帅哥 广东省汕头市潮阳区 上地三街，超级大厦，1008 P:8888 8888 列表没有样式的列表12345]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[入门例子创建]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%85%A5%E9%97%A8%E4%BE%8B%E5%AD%90%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[在 Bootstrap官网 我们在它展示的例子中我们可以看到一个简单的例子，只有导航和文字的页面 接下来我们完成这样一面的搭建，我们来看一下，Bootstrap 来完成这样一个页面到底有多简单，以及他给我们封装的样式到底如何使用 现在暂时先不考虑这个页面中我们为什么要使用它所给定的一些固定的格式 12345678910111213141516171819202122232425262728293031323334353637383940414243//添加一个 meta标签 因为它是一个响应式布局，我们通过一个 meta标签来设置//主要是提供自适应功能，表示宽度等于当前设备的宽度，缩放比例是当前不缩放//首先导入 Bootstrap 的Css文件: bootstrap.min.css body{ padding-top: 50px; } .starter{ padding: 40px 15px; text-align: center; } Project Name Home About Contact //自定义类 Bootstrap starter template 钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸 eg:]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素描]]></title>
    <url>%2F2019%2F04%2F22%2F%E7%B4%A0%E6%8F%8F%2F</url>
    <content type="text"><![CDATA[如何排线握笔姿势将铅笔放在四根手指的上面，大拇指盖住它，食指和拇指用力，剩余的三根手指收起，握住笔 eg: 注意： 握笔千万不要太用力，要保持一个放松的状态，让自己的手腕保持放松（软下来） 排线手法运腕法最基本的排线手法； 排线过程中是手腕在运动，整个手凌空于整个画面之上，并没有压在画面上去画 要点 靠手腕的力量去运动，快速的铺出均匀而密集的线条 运腕法多用于 大面积 的绘画 eg: 注意： 线条不是来回的画，每一根线条都是独立的 小拇指支撑运腕法使用上面讲述的握笔姿势，将小拇指提出来，顶在画面上 特点 边缘整齐 画出线条的力道比运腕法更大 线条更加的密集 小拇指支撑运腕法多用于 小面积 的绘画 eg: 运臂法运笔法所画出的线条比较大,比较直，所以运臂法是用来画直线的； 素描中的长直线是用来 起型 ： 在画面的一开始用来定型，比如说要花一个玻璃瓶，就先得知道玻璃瓶有多高，有多低，具体有多宽，之后再这个范围里面去再去找它的具体形状eg: 绘画步骤 长直线是运用在起型的阶段 之后再用运腕法画出样式 最后用小拇指运腕法去塑造细节（局部） eg: 写字方式应用在塑造更加精确的形体，运用写字的方式来对画面进行绘画时，可以使画面更加精准，可以很清楚的确定自己要画的范围 eg: 练习方式千万不要一直保持一个方向去排，因为练习久了，你的手可能就只熟悉这种方向排线的手感；所以，练习运腕法的时候，第一遍排过来之后，第二遍就稍微倾斜一个角度（倾斜 15度 最适合） 注意： 运臂法 练习时千万不要犹豫， 一定要快、 准、 狠 练习大概一星期，培养出一种基本的手感 手感： 手感来自我们长期的练习，手对铅笔的记忆，只有不断地练习，手感会越来越顺手，越来越强， 画什么的都会得心应手 可能在一开始的时候，总是想着线条有没有画好，可是画到后面手感越来越好之后，你所在乎的就不是线条了，它已经变成了你的一个本能 线条的讲究均匀和稳定需要排的足够密集，长短差不多就够了 轻 — 重 — 轻（不强制要求）线条的两边的感觉是轻的，中间会比较踏实一点 轻–重–轻 的优点： 当使用 轻重轻 的线条进行一个衔接； 当两头轻的线相交，它就变成了一个稍微重一点的颜色； 这样的线条排出来的画面很均匀，具有美感 eg:]]></content>
      <categories>
        <category>素描</category>
      </categories>
      <tags>
        <tag>画画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5增强的页面元素]]></title>
    <url>%2F2019%2F04%2F22%2FHTML5%E5%A2%9E%E5%BC%BA%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[课程概要 新增的 figure元素、 figcaption元素 新增的 details元素与 summary元素 新增的 mark元素 新增的 progress元素 新增的 meter元素 改良的 ol列表 改良的 dl列表 加以严格限制的 cite元素 和重新定义的 small元素 figure元素 以及 figcaption元素figure元素figure元素是一种组合元素，带有可选标题，figure元素用来表示网页上的一块独立的内容，将其从网页上移除之后，不会对网页的其他内容产生影响，figure元素 所表示的内容可以是图片、统计图或者是代码示例等 figcaption元素表示 figure元素 的标题，它从属于 figure元素 必须书写在 figure元素 的内部，可以书写在 figure 元素内部以及其他元素的前面或者后面，一个 figure元素 最多只允许放置一个 figcaption元素 ，但是允许放置多个其他元素 123456 美女 details元素 和 summary元素details元素details元素 是一种用于标识该元素内部的子元素可以被展开、收缩、显示的元素。 该元素具有一个 布尔类型 的 open属性，该属性值为 true 时，该元素内部的子元素应该被展开显示，当该属性为 false 的时候，其内部的子元素应该被收缩起来，不显示的。 该属性默认值是 false，页面打开时，其内部属于收缩状态。另外，details元素 内部不仅限于放置文字，还可以放置表单、插件或者是一个统计图的详细数据 summary元素summary元素 从属于 details元素，用鼠标单击 summary元素 中的文字内容时，details元素中的所有从属元素应该会被展开或者收缩，如果 details元素 没有 summary元素 ，浏览器会提供默认文字以供单击 123456789101112131415 function detail_onclick(detail){ var p = document.getElementById("p"); if(detail.open){ p.style.visibility = "hidden"; }else{ p.stule.visibility = "visible"; } } 速度与激情7 你好么，这是为保罗特意打造的电影，看起来激情四射 eg: mark元素mark元素 表示页面中需要突出显示或高亮显示的对于当前用户具有参考作用的一段文字 1这是一段文字，用来测试mark元素 eg: ol HTML5 中,将 ol 进行了改良，为它添加了 start属性 与 reversed属性 start属性如果我们希望它不是在 1 开始， 而是在 5 开始，就可以使用 start属性 1234567 列表1 列表2 列表3 列表4 列表5 reversed属性使用 reversed 倒叙列表 1234567 列表1 列表2 列表3 列表4 列表5 dl在 HTML5 中，将该元素进行重新定义，重新定义后的 dl列表 表示 多个名字的列表项，每一项都包含一条或多条带有名字的 dt元素，用来表示术语， dt 元素仅跟着一个或多个 dd 元素，在一个元素内不允许有相同名字的 dt 元素，不允许有重复的术语 123456 Hello 你好就是Hello 博客 你喜欢看博客吗]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap简介]]></title>
    <url>%2F2019%2F04%2F21%2FBootstrap%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Bootstrap介绍 Bootstrap 是最受欢迎的 HTML 、CSS 、JS 的框架，用于开发响应式布局，移动设备优先的Web项目 Bootstrap 是为所有开发者，所有应用场景而设计的， Bootstrap 的前端是让开发更加快速，简单。所有的开发者都能快速上手、所有的功能都能适配、所有的项目都适用 三个优点 预处理脚本： 虽然我们可以直接使用 Bootstrap 提供的 CSS 样式表，但是 Bootstrap 的源码是基于最流行的 CSS 预处理脚本 Less 和Sass，你可以采用预编译的 CSS 文件快速开发，也可以从源码中定制自己需要的样式 响应式布局： 一个框架，多种设备；那么这对于我们现在来说无疑是最需要的点，我们希望我们的网页可以在电脑上展示，在平板上展示，在手机端展示，那么希望他们展示的内容都是相通的内容，那么这个时候，响应式布局给我们提供了很多的方便 特性齐全： Bootstrap提供了全面，美观的文档，你能在这里找到相应的 HTML 元素，HTLM 和 CSS 组件，以及 jQuery 插件方面的所有详细文档 注意： Bootstrap 是完全开源的，它的代码托管、开发、维护都依赖于Github 想要快速开发，使用Bootstrap是一个非常好的开源项目 Bootstrap的学习步骤 起步 全局的CSS样式 组件 JavaScript插件 定制 起步官网提供的几种下载方法生产环境的Bootstrap 使用这种方式下载的只是我们要使用的Bootstrap的几个文件，包含它的 CSS、 JS 以及字体文件（不包含文档和源码） eg: Bootstrap的源码 它包含 less 、 JavaScript 和 字体文件的源码，而且还带有文档 eg: SassBootstrap 从 less 到 Sass 的一个代码迁移移植项目，用于快速的来进行开发或者正对于 Sass 项目的引入等 下载选择 一般来说我们希望看到源码，所以下载第二个（Bootstrap源码）即可 如果我们只是单纯的使用，而且我们使用步骤也比较明确，那我们可以直接下载第一种 如果我们不想去下载，也可以直接使用 Bootstrap 给我们提供的一些 CDN 的加速服务 在下载完成后的 js 文件夹中发现，存在有两个文件 Bootstrap.js （未压缩）与 Bootstrap.min.js（压缩版本） 文件 注意： Bootstrap 是依赖于 jQuery 的，我们需要先引入一个 jQuery包 ，再来引入 Bootstrap包 基本的模板和案例eg： 如果我们觉得当前网站全是英文不是特别好理解，我们可以 Bootstrap 对应的中文网站： Bootstrap的中文网站]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js第二课]]></title>
    <url>%2F2019%2F04%2F21%2FVue-js%E7%AC%AC%E4%BA%8C%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[知识点梳理 过滤器 键盘修饰符以及自定义键盘修饰符 自定义指令 vue实例的生命周期 vue-resource 实现 get、 post、 jsonp 请求 Vue中的动画 数组的新方法forEach、 somw 、 filter 、 findIndex、 这些都是数组的新方法，都会对数组中的每一项进行遍历，执行相关操作 不同之处 forEach： 无法被中止 some： 可以通过 return true 中止 filter： 进行过滤，把符合条件的，返回得到一个新数组 findIndex： 找到对应对象的索引 过滤器概念 Vue.js 允许你自定义过滤器，可以用作一些常见的文本格式化 。 过滤器可以用在两个地方： mustache插值 v-bind表达式 过滤器应该被添加在JavaScript表达式的尾部， 由“管道”符指示; 定义一个过滤器概念过滤器 调用 时候的格式1{{ name | 过滤器的名称 }} 代表我们在输出 name 的值之前，先 调用函数 进行一下处理，并把处理的结果当作 内容 渲染到 插值表达式 中 12//过滤器的定义语法Vue.filter('过滤器的名称',function(){}) 过滤器中的 function： 第一个参数已经被规定死了，永远都是过滤器管道符前面传递过来的数据 eg: 当输出 name，调用过滤器，就自动加入了 123 的后缀 123Vue.filter('name',function(data){return data + '123'}) 过滤器的基本使用过滤器本身就是用来做 输出前 最后一层的处理，没有修改 原数据 123456789101112131415161718192021222324252627282930313233 {{ msg | msgFormat('疯狂','123') | test }} //定义一个 Vue 全局的过滤器，名字叫 msgFormat //第一个参数可以拿到管道值， 第二个位置可以进行传参 //也可以传递多个参数 Vue.filter('msgFormat',function(msg,arg,arg2){ //字符串的replace 方法，第一个参数，除了可写一个字符串之外， 还可以定义一个正则 //【 /单纯/g 】 表示全局匹配 return msg.replace(/单纯/g,arg + arg2) }) //可以多次调用过滤器，先将 原始的值 交个第一个过滤器处 //理，再调用 第二个过滤器 对第一个过滤器处理的值进行处 //理，最后把结果放回 插值表达式 Vue.filter('test',function(msg)){ return msg + '========' } //Vue实例 var vm=new Vue({ el: '#app', data: { msg: '曾经，我也是一个单纯的少年，单纯的我，傻傻地问，谁是世界上最单纯的男人' }, methods: { } }); 处理过程： 对象先交个过滤器处理，过滤器调用函数，最后返回给 插值表达式 案例：品牌管理案例 Vue不提倡操作 DOM jQuery帮我们封装了一些 DOM操作，它是用来操作 DOM 的； 而Vue是帮我们免除操作 DOM 的这个过程，所以 Vue 中一般不使用 jQuery 在 Vue 中，使用事件绑定机制，为元素指定处理函数的时候，如果加了小括号，就可以给函数传参了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182//此案例需要引入 bootstrap 框架 添加品牌 Id: Name: 搜索名称关键字： Id Name Ctime Operation //之前， v-for 中的数据都是直接从 data 上的list中直接渲染过来的 //现在，我们自定义了一个 search方法，同时，把所有的关键字，通过 //传参的形式，传递给了 search 方法 //在 search 方法内部，通过执行 for循环，把所有符合关键字的数据，保存 //到一个新数组中，返回 {{ item.id }} {{ item.ctime | dataFormat('')}} //要阻止 a标签 的默认行为并且定义一个方法 删除 //定义全局过滤器，进行时间的格式化 Vue.filter('dataFormat',function(dataStr,pattern=''){ //这是根据给定的时间字符串，得到特定的时间 var dt = new Date(dataStr) // yyyy-mm-dd var y = dt.getFullYear() var m = dt.getMonth() + 1 var d = dt.getDate() //retrun y + '-' + m + '-' + d //模板字符串 //return `${y} - ${m} - ${d}` //如果你传过来的 pattern 经过转换 第一个 判断条件 则返回年月日 //如果不成立，就认为要得到一个最全的日期 if(pattern.toLowerCase() === ’yyyy-mm-dd‘){ return `${y} - ${m} - ${d}` }else{ var hh = dt.getHours() var mm = dt.getMinutes() var ss = dt.getSeconds() return `${y} - ${m} - ${hh} ${hh}:${mm}:${ss}` } }) //Vue实例 var vm=new Vue({ el: '#app', data: { id: '', name: '', keywords: '',//搜索的关键字 list: [ {id: 1,name: '奔驰',ctime: new Date()}, {id: 2,name: '宝马',ctime: new Date()} ] }, methods: { add(){//添加的方法 //console.log('ok'); //分析步骤： //1.要获取 id 和 name ，直接从 data 上面获取 //2.组织出一个对象 //3.把这个对象，调用 数组的相关方法，添加到当前 data 上的 list中 //4.注意：在Vue中，已经实现了数据的双向数据绑定，每当我们修改了data中的数据，Vue会默认监听到数据的改动，自动把最新的数据应用到页面上； //5.当我们意识到上面的第四步的时候，就证明大家已经入门Vue了，我们更多的是在进行 VM 中 Model 数据的操作， 同时，在操作 Model 数据的时候，指定的业务逻辑操作； var car = { id: this.id, name: this.name, ctime: new Date()} this.list.push(car) //等号从右到左进行计算，依次赋值 this.id = this.name = '' }, del(id){ //根据id删除数据 //分析 //1.如何根据 Id, 找到要删除这一项的索引 //2.如果找到索引了，直接调用 数组的 splice方法 /* this.list.some((itme, i)=>{ if(item.id == id){ this.list.splice(i,1) //在数组的 some 方法中，如果 return true，就会立即终止这个数组的循环 return trun; } }) */ //另一种方法 var index = this.list.findIndex(item => { if(item.id == id){ return true; } }) this.list.splice(index, 1) }, search(keywords){//根据关键字，进行数据的搜索 /* var newList=[] this.list.forEach(item => { //判断是否包含关键字 if(item.name.indexOf(keywords) !=-1){ newList.push(item) } }) return newlist */ //注意： forEach、 somw 、 filter 、 findIndex、 这些都是 //数组的新方法，都会对数组中的每一项进行遍历，执行相关操作 return newList = this.list.filter(item => { //方法一：if(item.name.indexOf(keywords) != -1) //注意： SE6中，为字符串提供了一个新方法， //叫做 String.prototype.include('要包含的字符串') //如果包含，返回true，否则返回false if(item.name.includes(keywords)){ return item } }) //return newList } } }) some()： 根据指定的条件进行判断，如果返回true some() 就会被终止 findIndex()： 专门用来查找索引 Vue 调试工具 vue-devtools 的安装步骤和使用方法一：直接在谷歌浏览器添加插件Vue.js devtools - 翻墙安装方式 （本人测试无法使用） 方法二：本地手动安装 首先在github下载 devtools源码 ，地址：vue-devtools 再根据这篇博客进行添加，地址：手动添加 vue-devtools 方法 注意： 要想使用该插件，必须使用未被压缩过的文件 Vue.js，如果使用压缩过的 Vue.min.js ，则浏览器控制台不会出现 Vue 这一标签栏 如果还是无法使用，查看扩展工具中是否有 【 允许访问文件网址 】 安装成功就会出现如下效果]]></content>
      <categories>
        <category>Vue学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单新增的元素与属性（五）]]></title>
    <url>%2F2019%2F04%2F20%2F%E8%A1%A8%E5%8D%95%E6%96%B0%E5%A2%9E%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%8E%E5%B1%9E%E6%80%A7%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在HTML5中，大幅度的增加了与改良了input元素的种类，可以简单的使用元素来实现HTML5之前需要使用JavaScript脚本才能实现的许多功能 增加与改良的input元素 url类型、emali类型、date类型、time类型、datetime类型、datetime-local类型、month类型、week类型、number类型、range类型、search类型、Tel类型、color类型 url类型如果提交的不是一个网址，则会弹出提示请求输入网址,达到了一个检验的效果 1234 eg: email类型email的input元素是一种专门用来输入email地址的文本框，如果提交时该文本框的内容不是一个email地址的完整格式，则不允许进行提交，达到了一个检验的效果 1234 eg: date类型data类型的input元素是深受开发者喜爱的一种元素，在网页中经常需要输入各种各样的日期，例如生日，购买日期，订票等，那么data类型的input元素以日历的形式方便用户进行输入 1234 eg: time类型time类型的input元素，是一种专门用来输入时间的文本框，并且在提交时对输入时间有效性进行检查 1234 eg: datetime类型datetime类型是input元素一种专门用来输入UTC时间和日期的文本框，并且在提交时对输入的日期和时间进行有效性的检查； 它与time的区别就是，它是一个UTC的时间和日期 1234 datetime-local类型datetime-local它是input元素一种专门用来输入本地日期和时间的文本框，并且在提交时，对输入的日期和时间进行有效性的检查 1234 month元素month元素的input类型是一个专门用来输入月份的文本框，并且在提交时进行有效性的检查 1234 eg: week元素week类型的input元素是一种专门用来输入周号的一个文本框 1234 eg: number类型number类型的input元素是一种专门用来输入数字的文本框，并且在提交时进行检查，检查其中内容是否为数字，如果其中内容不为数字，则文本框内容作为空白来进行提交，也就意味着它也可以提交的，只不过提交的数据是空白，同时与输入日期时间的元素相通，number类型的input元素也具有一个最大值、最小值和一个step属性 1234 step属性意味着每次增加，是以指定的数字进行增加 eg: number类型的 valueAsNumbervalueAsNumber将文本框中的字符当做数字进行操作，而不是当成默认的字符串 制作简易计算器 1234567891011121314151617 function sum(){ var n1 = document.getElementById("num1").valueAsNumber; var n2 = document.getElementById("num2").valueAsNumber;; document.getElementById("result").valueAsNumber = n1 + n2 } + = range元素range类型的input元素是一种只允许输入一段范围的文本框，具有最大值和最小值属性，可以设置最大值、最小值， 默认值一般是0和100，也具有 step属性 step属性： 是一个每次增加的数值，可以指定每次拖动的步幅 12 eg: search类型它是一种专门用来输入搜索关键字文本框 12 tel类型tel类型的 input元素 被设计为用来输入电话号码的专用文本框，tel类型没有特殊的限制规则，不强制输入数字 12 color类型color类型的input元素被用来设计选取颜色，提供一个颜色选择器，现在它在黑莓浏览器、chrome20以上都是支持的 1234 eg: output元素的追加在HTML5中，追加了新的元素output元素，output元素定义不同类型的输出 12345678910 function value_change(){ var number= document.getElementById("range").value; document.getElementById("output").value= number; } 10 eg: 表单验证1234567891011121314151617 function check(){ var emial = document.getElementById("email"); if(email.value == ""){ alert("请输入email"); return false; }else if(!email.checkValidity()){ alert("请输入正确的Email地址"); return false; } } Email novalidates 表示不会对输入进行验证的表单 eg:]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js第一课]]></title>
    <url>%2F2019%2F04%2F19%2FVue-js%E7%AC%AC%E4%B8%80%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[什么是Vue.js Vue.js是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App；Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js是最前端主流框架之一，和Angular.js、React.js一起，并成为前端三大主流框架 Vue.js是一套构建用户界面的框架，值关注视图图层，它不仅易与上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层，主要的工作就是和界面打交道 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱 提高开发效率的发展历程：原生JS（原生代码纯在兼容性） -> Jquery（屏蔽各个浏览器的兼容性） -> 前端模板引擎（不需要频繁操作DOM） -> Angular.js / Vue.js（减少不必要的DOM操作，提高渲染效率；提供了双向数据绑定概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心概念，就是让用户不再操作DOM元素，解放了程序员的双手，让程序员可以更多的时间去关注业务逻辑 在MVC中，C层（业务逻辑层）开发起来最麻烦，通常占了整个程序的70~80%的代码量，消耗主要的精力 争强自己就业时候的竞争力，人无我有，人有我优！！！ 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大；项目如果需要更换框架，则需要重新架构整个项目 库（插件）：提供某一个小功能，对项目入侵较小，如果某个库无法完成某些需求，可以很容易切换到其他库实现需求。例如： 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的MVC与前端中的MVVM的区别 MVC 是后端的分层开发概念（M【model】：处理数据、V【view】视图层、c【Controller】业务逻辑层） 数据的CRUD：增加(Create)、读取查询(Read)、更新(Update)和删除(Delete)几个单词的首字母简写。 MVVM是前端视图图层概念，主要关注于视图层分离，也就是说：MVVM把前端的视图层，分为了三部分： Model View VM ViewModel （MVVM思想的核心，因为VM是M和V之间的调度者） 前端页面中使用MVVM的思，主要是为了让我们开发更加方便，因为MVVM提供了数据的双向绑定； 注意：数据的双向绑定是由VM提供的 Vue.js 基本代码和MVVM之间的对应关系 Vue和其他框架一样，需要下载一个 .js 文件（这里使用vue- 2.4.0.js版本） 通过Vue提供的指令，很方便的就能把数据渲染到页面上，程序员不再手动操作DOM元素了【前端的Vue之类的框架，不提倡我们去手动操作DOM元素了】 当我们导入包之后，在浏览器的内存中，就多了一个 Vue 的构造函数 123456789101112131415161718192021222324//将来new的Vue实例，会控制这个元素中的所有内容//导入vue的包//创建一个Vue的实例 //我们new出来的这个 vm 对象，就是我们 MVVM 中的 VM 调度者 var vm = new Vue({ el: '#app', //表示当前new的这个Vue实例，要控制页面上的哪个区域 //这里的data激素MVVM中的 M，专门用来保存每个页面的数据 data: { //data属性中，存放的是el中要用到的数据 msg: '欢迎学习Vue' } })// Vue元素所控制的这个区域，就是我们的 V {{ msg }} Vue值 - 【基本的代码结构】 和 【插值表达式】、【v-cloak】当网速较慢时，请求数据网页就会出现原本的代码块，此时可以用 v-clock属性 来解决该问题 v-cloak：能够解决插值表达式的闪烁问题 1234567891011121314151617181920 {{ msg }} [v-clock]{ //属性选择器 display: none; } var vm = new Vue({ el: '#app', data: { msg: '123' } }) 调整网速进行测试：浏览器的调试界面 -> Network -> Online -> Slow 3G，表示慢速的一个3G网络 Vue指令之 【V-text】 和 【V-html】v-textV-text的作用和插值表达式是没有太大的区别的,那为什么还要有插值表达式和 V-text 呢？ 区别： v-test v-html V-test默认没有闪烁问题 插值表达式默认会出现闪烁问题: V-test会覆盖html标签中原本的内容 插值表达式可以在前后放置任意内容（不会覆盖） 12345678910111213 var vm = new Vue({ el: '#app', data: { msg: '123' } }) v-html 插值表达式和V-test都会把内容当中普通字符串输出,当我们将数据作为HTML语句输出时，我们就需要使用v-html来进行输出 12345678910111213 var vm = new Vue({ el: '#app', data: { msg2: '哈哈，我是一个大大的H1，我大，我骄傲' } }) V-bind绑定属性v-bind是Vue中，提供的用于绑定属性的指令。声明这是一个data变量，从而对参数进行解析 12345678910111213 var vm = new Vue({ el: '#app', data: { mytitle:'这是一个自己定义的title' } }) 注意：v-bind会把属性引号内的东西当做js代码去解析执行，即可以写合法的表达式，eg：可以使用 “ mytitle + ‘123’ “ 【变量+表达式】来作为参数 v-bind的简写v-bind可以被简写为只用“ : ”来表示，eg： V-on绑定事件Vue中提供了 【 v-on： 】 事件绑定机制 123456789101112131415161718 var vm = new Vue({ el: '#app', data: { }, methods:{ //这个methods属性中定义了当前Vue实例所有可用额方法 show:function(){ alert('Hello') } } }) 一般在js中，带 s 的关键字通常是一个数组 知识总结 如何定义一个基本的Vue代码结构 插值表达式 和 v-text v-cloak 解决插值表达式闪烁问题 v-html v-bind vue提供的属性绑定机制；缩写是【 ： 】 v-on vue提供的事件绑定机制；缩写是【 @ 】 实例：Vue指令之 ‘v-on’ 和 ‘跑马灯效果’ 点击“浪起来”：每隔一段时间都会第一个字符并放到最后；点击“低调”：停止截取 分析： 给 【浪起来】 按钮，绑定一个点击时间 v-on 或缩写 【 @ 】 在按钮的事件处理函数中，要写相关的业务逻辑代码：拿到 msg 字符串，然后调用字符串的 substring 来进行字符串的截取操作，把第一个字符截取出来，放到最后一个位置即可 为了实现点击一下按钮，自动截取的功能需要把2步骤中的代码，放到一个定时器中 在VM实例中，如果想要获取 data 身上的属性，或者调用 methods 里面的方法，必须通过 this.数据属性名 或 this.方法名 来进行访问，这里的this，就表示我们 new 出来的 VM实例对象 1234567891011121314151617181920212223242526272829303132333435363738 {{ msg }} var vm = new Vue({ el: '#app', data: { msg: '猥琐发育，别浪~~!', intervalId:null //在data上定义 定时器id，类似于全局变量，方便调用 } methods: { lang(){ //console.log(this.msg) //刚一开始定时器的值等于null，每当调用null，都会返回一个值给IntervalId，所以每次点击按钮，都会重复的开启定时器，所以需要一个条件来判断是否等于null，即是否第一次开启定时器，防止重复开启 if(this.intervalId != null) return; // => 表示内部的this指向外部的this this.intervalId = setInterval( () => { //获取到头的第一个字符 var start = this.msg.substring(0,1) //获取到后面的所有字符 var end = this.msg.substring(1) //表示从1开始截取，如果不写第二个参数，则截取剩余所有部分 //重新拼接得到新的字符串，并赋值给this.msg this.msg=end + start },400) }, stop(){ clearInterval(this.intervalId) //每当清楚了定时器之后，需要重新把 intervalId 置为null this.intervalId = null; } } }) 箭头函数 【 => 】 的作用：解决了this指向的问题，箭头函数内部的this永远和箭头函数外部的this保持一致；我们外部的this当前的指向是我们的vm实例，所以内部的指向也是vm实例 Vue有一个特点，它能监听自己身上date的改变，只要date有改变，它会立即把改变应用到页面中去。【好处：程序员值需要关系数据，不需要考虑如何重新渲染到页面】 console.log()方法：表示用于在控制台输出信息 Vue指令之 v-on的缩写 和 时间修饰符v-on的缩写，即使用‘ @ ’符号v-on 提供的事件修饰符 .stop阻止冒泡 .prevent阻止默认事件 .capture添加事件监听器使用事件捕获模式 .self只当事件在元素本身（比如不是子元素）触发时触发回调 .once事件只触发一次 【 .stop 】 阻止冒泡机制冒泡机制：先调用当前元素事件，然后再调用外层被包裹的这些元素;使用了【 .stop 】 阻止冒泡机制，就不会自动调用外层事件，只会调用当前的事件 1234567891011121314151617181920212223242526272829303132 .inner{ height: 150px; background-color: darkcyan; } var vm=new Vue({ //指定了要控制的元素 el: "#app", //指定了要展示的数据 data: {}, //要触发的方法 methods:{ div1Handler(){ console.log('这是触发了 inner div 的点击事件') }, btnHandler(){ console.log('则是窜了 btn按钮 的点击事件') } } }); 【 .prevent 】 阻止默认行为eg：只要显示自己定义的事件，不实现默认事件(即阻止默认行为)。eg：超链接的默认跳转事件 123456789101112131415161718192021222324 有问题，先去百度 var vm=new Vue({ //指定了要控制的元素 el: "#app", //指定了要展示的数据 data: {}, //要触发的方法 methods:{ linkClick(){ concole.log('触发了链接的点击事件') } } }); 【 .capture 】 添加事件监听器时使用事件捕获机制使用 【 .capture 】 实现捕获触发事件的机制，即将捕获到的事件优先运行。eg：由于DOM是默认冒泡排序机制（从内到外），我们可以使用【 .capture 】捕获外层事件，实现从外到内进行程序的运行 123456789101112131415161718192021222324252627282930313233 .inner{ height: 150px; background-color: darkcyan; } //捕获 var vm=new Vue({ //指定了要控制的元素 el: "#app", //指定了要展示的数据 data: {}, //要触发的方法 methods:{ div1Handler(){ console.log('这是触发了 inner div 的点击事件') }, btnHandler(){ console.log('则是窜了 btn按钮 的点击事件') } } }); 【.self】事件，表示只有自身才能触发自身的事件使用【.self】实现只有点击当前元素的时候，才会触发事件处理函数 1234567891011121314151617181920212223242526272829303132 .inner{ height: 150px; background-color: darkcyan; } var vm=new Vue({ //指定了要控制的元素 el: "#app", //指定了要展示的数据 data: {}, //要触发的方法 methods:{ div1Handler(){ console.log('这是触发了 inner div 的点击事件') }, btnHandler(){ console.log('则是窜了 btn按钮 的点击事件') } } }); once事件只触发一次使用【.once】只触发一次事件处理函数，类似于使用了一次事件后就将事件舍弃 123456789101112131415161718192021222324 有问题，先去百度 var vm=new Vue({ //指定了要控制的元素 el: "#app", //指定了要展示的数据 data: {}, //要触发的方法 methods:{ linkClick(){ concole.log('触发了链接的点击事件') } } }); 注意： 【.stop】和【.self】的区别 【.stop】阻止了所有的 冒泡行为；【.self】只会阻止自身冒泡行为的触发，并不会真正阻止 冒泡的行为； Vue指令之 【v-model】 和 【双向数据绑定】使用v-model指令，可以实现 表单元素和Model中数据的双向绑定；注意：v-model只能运用在表单元素中 只有v-model才可以实现 【双向数据绑定】 v-bind只能实现数据的单向绑定，从 M 自动绑定到 V，无法实现数据的双向绑定 12345678910111213141516 {{ msg }} var vm=new Vue({ el: '#app', data: { msg: '大家都是好学生，爱敲代码，爱学习，爱思考，简直是完美，没瑕疵！' }, methods: {} }); 我们在date身上定义的属性或者字段，Vue会帮我们挂载到vm身上 实例：简易计算器案例 代码是从上带下去执行，先加载Vue.js包，再渲染HTML页面，然后立即执行Vue脚本语言，重新为HTML中的值赋值，最后赋值完成并且输出到HTML页面中 1234567891011121314151617181920212223242526272829303132333435363738394041424344 + - * / var vm = new Vue({ el: '#app', data: { n1: 0, n2: 0, result: 0, opt: '+' }; methods: { calc(){ switch(this.opt){ case '+': this.result = parseInt(this.n1) + parseInt(this.n2) break; case '-': this.result = parseInt(this.n1) - parseInt(this.n2) break; case '*': this.result = parseInt(this.n1) * parseInt(this.n2) break; case '/': this.result = parseInt(this.n1) / parseInt(this.n2) break; } } } }); 还可以使用如下代码代替 switch()函数： eval()函数：把字符串解析执行，然后获得执行的结果 123//投机取巧的方式，正式开发中尽量少用var codeStr = 'parseInt(this.n1)' + this.opt + 'parseInt(this.n2)'this.result=eval(codeStr) 在Vue中使用样式使用class样式 数组1这是一个邪恶的H1 注意：class使用 v-bind 做数据绑定时，类名必须用单引号包起来，vue的属性则不必加单引号 数组中使用三元样式1这是一个邪恶的H1 eg: 1234567891011121314 这是一个很大很大的H1，大到你无法想象！！！ var vm=new Vue({ el: '#app', data: { flag: false }, methods: {} }); 数组中嵌套对象 在数组中使用对象来代替三元表达式，提高代码的可读性 1这是一个邪恶的H1 eg: 1234567891011121314 这是一个很大很大的H1，大到你无法想象！！！ var vm=new Vue({ el: '#app', data: { flag: true }, methods: {} }); 直接使用对象 在为 class 使用 v-bind 绑定对象的时候，对象的属性是类名，由于对象的属性可带引号，也可不带引号，所以这里可写可不写； 属性的值是一个标识符 1这是一个邪恶的H1 eg: 1234567891011121314 var vm = new Vue({ el: "add", data: { flag: true, classObj: { red: true, thin: true, italic: false, active: false} }, methods: {} }) 使用内联样式 对象就是无序键值对的集合 直接在元素上通过 【:style】 的形式，书写样式对象1这是一个善良的H1 如果属性中有 ‘-‘ ，则必须添加一个单引号 将样式对象，定义到 【data】 中，并直接引用到 【:style】中在 data 上定义样式：123data: { h1StyleObj: {'color': 'red','font-size': '40px','font-weight': '200'}} 在元素中，通过属性绑定的形式，将样式的对象应用到元素中：1这是一个善良的H1 在 【:style】 中通过数组，引用多个 【data】 上的样式对象在data上定义样式：1234data: { h1StyleObj: {color: 'red','font-size': '40px','font-weight': '200'}, h1StyleObj2: {fontStyle: 'italic'}} 在元素中，通过属性绑定的样式，将样式对象应用到元素中：1这是一个善良的H1 Vue指令之 【v-for】 和 【key】 属性迭代数组v-for循环普通数组12345678910111213 索引值：{{i}} --- 每一项： {{item}} var vm= new Vue({ el: '#app', data: { list: {1,2,3,4,5,6} }, methods: {} }); v-for循环对象数组1234567891011121314151617 Id: {{ user.id }} === 名字： {{ user.name }} --- 索引：{{ i }} var vm= new Vue({ el: '#app', data: { list: { id:1, name: 'zs1'}, list: { id:2, name: 'zs2'}, list: { id:3, name: 'zs3'}, list: { id:4, name: 'zs4'} }, methods: {} }); 迭代对象中的属性在遍历对象身上的键值对的时候，除了有 val key之外 ，在第三个位置还有一个索引 1234567891011121314151617 值是： {{ val }} --- 键是： {{ key }} --- 索引： {{ i }} var vm = new Vue({ el: "#app", data: { uesr: { id: 1, name: '托尼·斯达克', gender: '男' } }, methods: {} }) 迭代数字in 后面我们放 普通数组， 对象数组， 对象， 还可以放数字 1234567891011121314 这是第 {{count}} 个p标签 var vm=new Vue({ el: "#app", data: { }, methods: {} }) 如果使用用 v-for 去迭代一个数字的话，则起始位置从1开始 2.2.0+ 的版本里，单在组件中使用 v-for 时，key现在是必须的当Vue.js用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略，如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的顺序，而是简单复用此处每个元素，而且确保它在特定索引下显示已被渲染过得每个元素。 为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有的元素，你需要为每项提供一个唯一key属性。 在组件中，使用 v-for 循环的时候，或者在一些特殊情况中，如果 v-for 有问题，必须在使用 v-for 的同时，指定唯一的字符串/数字类型： key值 注意：没有使用key时，表示没有指定选中为哪一项，会导致bug；每次for循环的时候，通过制定key来标识当前循环这一项的一个唯一身份 12345678910111213141516171819202122232425262728293031323334353637383940414243 Id: Name: //注意：v-for循环的时候，key 属性只能使用 number 或 string //注意： key 在使用时，必须使用v-bind属性绑定的形式，指定key的值 {{item.id}} --- {{item.name}} var vm = new Vue({ el: "#app", data: { id: '', name: '', list: { {id: 1, name: '李斯'}, {id: 2, name: '嬴政'}, {id: 3, name: '赵高'}, {id: 4, name: '韩非'}, {id: 5, name: '荀子'}, } }, methods: { add(){ this.list.unshift({id: this.id, name: this.name }) } } }) key属性 能够保证数据的唯一性，让我们data上的数据与页面上的数据强制关联起来 ； 如果不使用key，程序则会值使用 v-for 来循环渲染，渲染结束后就会忘记各个DOM元素的对应关系，从而导致BUG eg: push():在数组末尾添加元素， unshift():在数组开始添加元素 Vue指令之 v-if 和 v-show一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换使用 v-show 较好，如果在运行时条件不大可能改变使用 v-if 较好 如果元素涉及到频繁的切换，最好不要使用 v-if ，而是推荐使用 v-show； 如果元素可能永远也不会被显示出来被用户看到，则推荐使用v-if v-if的特点： 每次都会重新删除或创建元素； v-show的特点： 每次不会重新进行DOM的删除和操作，知识切换了元素的 display： none 样式 v-if 有较高的切换性能消耗； v-show 有较高的初始渲染消耗 1234567891011121314151617181920 这是用v-if控制的元素 这是用v-show控制的元素 var vm=Vue({ el: "#app", data: { flag: true }, methods: { toggle(){ this.flag= !this.flag } } }); 知识梳理：MVC 和 MVVM 的区别MVC 是后台开发的概念，MVVM 为前端的概念。MVC站在整个项目的角度来考虑，MVVM只考虑前端页面，把前端页面分离为 Model 、 View 、 VM，其中，VM为核心，它是一个调度者，如果离开了VM，则MVVM将失去所有的优势。其中，vm提供了一个很重要的功能，即双向数据绑定 Vue基本代码的结构 导入包 创建一个要控制的元素（一般在 div标签 中加一个 id 以便控制） 变向Vue代码 注意： 不要给 body标签 加一个 id，在 Vue的版本1 里面是可以这么干的，但是在 Vue2.0 以后都不能这么写了 基本指令 插值表达式 v-cloak、 v-text、 v-html、 v-bind、 v-on、 v-model 、v-for、 v-if 、v-show； 其中： v-bind 的缩写是：【 : 】 v-on 的缩写是：【 @ 】 事件修饰符 【 .stop 】： 阻止冒泡 【 .prevent 】： 阻止默认行为 【 .capture 】： 捕获机制 【 .self 】： 自身执行 【 .once 】： 只执行一次 vm实例的属性 【 el 】： 指定要控制的区域 【 data 】： 是个对象，指定了控制的区域内要用到的数据 【 methods 】：虽然带了个 s 后缀，但是是个对象，这里可以自定义方法 学习注意事项 在vm实例中，如果要访问data上的数据，或者要访问methods中的方法，必须带this 在 v-for 中，要会使用 key 属性（只接受 string / number） v-model 只能应用于表单元素 在vue中绑定样式的两种方式 v-bind: class 、 v-bind: style v-if 有更高的切换消耗、 v-show 有更高的初始渲染消耗]]></content>
      <categories>
        <category>Vue学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单新增的元素与属性（四）]]></title>
    <url>%2F2019%2F04%2F19%2F%E8%A1%A8%E5%8D%95%E6%96%B0%E5%A2%9E%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%8E%E5%B1%9E%E6%80%A7%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[文本框的list属性在HTML5中，为单行文本框增加了一个list属性，该属性的值为某个datalist元素的id。datalist元素也是HTML5中新增的元素，该元素类似于选择框，但是用户想要设定的值不在选项列表之内时，允许自行输入。datalist元素本身并不显示，而是当文本框获得焦点时以提示输入的方式显示。(类似于下拉菜单) 123456789 HTML5学习 Android学习 IOS学习 datalist属性默认是看不到的，但是为了在每个浏览器中兼容，所以还是自己设置style的display属性 eg: 文本框的autocomplete属性帮助输入所用的自动完成功能，是一个既节省输入时间有十分方便的功能，在HTML5之前，因为谁都可以看见输入的值，所以在安全方面存在缺陷，只要使用AutoComplete属性，安全性方面也可以得到很好地控制。 1234//方法同上，即使用datalist标签定义候补的值 autocomplete有两个值：on（不填写）、off 文本框的pattern属性在HTML5中，对input属性使用pattern属性，并且将属性值设为某个格式的正则表达式，在提交时会针对这些进行检查，检查其内容是否符合给定格式。当输入的内容不符合给定格式时，则不允许提交，同时在浏览器中显示提示文字，提示输入的内容必须符合给定格式。 123456 请输入内容 //该正则表达式表示随意输入3个大写字母 eg: 文本框的SelectionDirection属性这对input元素与textarea元素，在HTML5增加了SelectionDirection属性。当用户在这两个元素中用鼠标选取部分文字时，可以使用该属性来获取选取方向。当用户正向选取文字时，该属性值为“forward”，当用户反向选取文字时，该属性值为“backward”。当用户没有选取任何文字时，该属性值为“forward”。 12345678910111213 function AD(){ var control = document.forms[0]['text']; var Direction = control.selectionDirection; alert(Direction); } 一般我们会以SelectionDirection这种属性的方式来获取用户的操作然后从中获取需要的信息]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单新增的元素与属性（三）]]></title>
    <url>%2F2019%2F04%2F18%2F%E8%A1%A8%E5%8D%95%E6%96%B0%E5%A2%9E%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%8E%E5%B1%9E%E6%80%A7%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[标签的control属性在HTML5中，可以在标签内部放置一个表单元素，并且通过该标签的control属性来访问该表单元素 1234567891011121314151617 function setValue(){ var label = document.getElementById("label"); var textbox = label.control; textbox.value="010010"; } 邮箱： 请输入六为数字 文本框的placeholder属性placeholder是指当前文本框处于未输入状态时显示的输入提示。当文本框处于未输入状态且未获取光标焦点时，模糊显示输入提示文字 placeholder属性相当于文本框的提示，方便我们对当前的输入框当中的输入内容有更好的了解 12 eg: 复选框的indeterminate属性对于复选框checkbox元素来说，过去只是选取与非选取这两种状态。在HTML5中，可以在JavaScript脚本代码中对该元素使用indeterminate属性，以说明复选框处于“尚未明确是否选取状态”。 12345属性测试 var cb = document.getElementById("cb"); cb.indeterminate = true; eg : 注：该属性表明checkbox有三种状态。 注：这两个属性的配合使用，我们指的是interminate与checkbox属性两种不同的属性，如果只考虑interminate与checkbox结合使用，可能会被认为复选框具有两种false或者两种true、或者是一种true一种false、另外一个false另外一个true，即四种状态来组合。但事实上，他只有三种状态，即选取、非选择和不明状态，所以写的时候，需要在JavaScript脚本中进行简单的处理。 image提交按钮的height属性和width属性针对于类型为image的input属性，HTML5新增了两个属性，height、width分别用来指定图片按钮的高度和宽度。 12345 姓名 eg:]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP生成验证码]]></title>
    <url>%2F2019%2F04%2F18%2FPHP%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[代码部分form.php文件 12345678910111213if (isset($_REQUEST['authcode'])) { session_start(); if (strtolower($_REQUEST['authcode'])==$_SESSION['authcode']) { echo' 输出正确'; # code... }else{ echo $_REQUEST['authcode']; echo $_SESSION['authcode']; echo' 输出错误'; } exit();} 本段代码的解析：先接受session值，将提交的值与验证码比较，如果输入正确，则显示‘输入正确’，否则依次输出提交的值、验证码的值和‘输入错误’ captcha.php文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//必须至于顶部,多服务器端记录验证码信息，便于用户输入后做校验session_start();//默认返回的是黑色的照片$image = imagecreatetruecolor(100, 30);//将背景设置为白色的$bgcolor = imagecolorallocate($image, 255, 255, 255);//将白色铺满地图imagefill($image, 0, 0, $bgcolor);//空字符串，每循环一次，追加到字符串后面 $captch_code='';//验证码为随机四个数字母字for ($i=0; $i]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP相关知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单新增的元素与属性（二）]]></title>
    <url>%2F2019%2F04%2F17%2F%E8%A1%A8%E5%8D%95%E6%96%B0%E5%A2%9E%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%8E%E5%B1%9E%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[formtarget属性在HTML4中，表单元素具有一个target属性，该属性用于指定在何处打开表单提交后所需要加载的页面。 在HTML5中，可以对多个按钮分别使用formtarget属性来指定提交后在何处打开所需加载的页面。 123456789101112 提交到xx.jsp页面 提交到xx.jsp页面 提交到xx.jsp页面 提交到xx.jsp页面 提交到xx.jsp页面< /form>< /form> formtarget的五个属性 _blank：在新的浏览器页面或窗口进行打开 _self：target属性的默认值，在相同的框架frame中打开 _parent：在当前框架的父框架中进行打开 _top：在当前窗口中打开， _framename：在指定框架中打开 autofocus属性为文本框，选择框或按钮控件加上autofocus属性，当画面打开时，该控件自动获得光标焦点 12345 < /form> autofocus属性一般是用在当前页面，当前的输入框或者是按钮或者是其他的内容处于第一优先级时，才会使用该属性 required属性HTML5中新增的required属性可以应用在大多数输入元素上，在提交时，如果元素中内容为空白，则不允许提交，同时在浏览器中显示相应的提升文字 12345 提交< /button>< /form> eg: labels属性在HTML5中，为所有可使用标签的表单元素、button、select元素等，定义一个labels属性，属性值为一个NodeList对象，代表该元素所绑定的标签元素所构成的集合 12345678910111213141516171819202122 function Validate(){ var txtName=document.getElementById("txt_name"); var button=document.getElementById("btnValidate"); var form=document.getElementById("testform"); if(txtName.value.trim()=="" ){ var label=document.createElement("label"); label.setAttribute("for","txt_name"); form.insertBefore(label,button); txtName.labels[1].innerHTML="请输入姓名"; txtName.labels[1].setAttribute("style","font-size:9px;color:red"); } }< /script> 姓名：< /label> < /form> label的for属性：for属性规定label与那个表单元素绑定 trim()：去除字符串的头尾空格]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环回接口（Loopback）]]></title>
    <url>%2F2019%2F04%2F16%2F%E7%8E%AF%E5%9B%9E%E6%8E%A5%E5%8F%A3%EF%BC%88Loopback%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概述路由器上的一个逻辑、虚拟接口。路由器默认没有任何环回接口，但是它们很容易创建。可以根据需要创建任何数目的环回端口。这些接口在路由器上与物理接口一样对待；可以给他们分配寻址信息，包括他们在路由器选择更新中的网络号，甚至在它们上可以终止IP链接，如Telnet。环回接口由于独占一个IP地址，子网掩码一般建议设为255.255.255.255 loopbackloopback接口，在网络设备（一般是路由器）上是一种特殊的接口，它不是物理接口，而是一种看不见摸不着的逻辑接口（虚拟接口），但是对于网络设备来说是至关重要的。 在网络设备上可以通过配置命令来创建一个或多个环回接口，并且可以和配置物理接口一样，配置环回接口的IP地址和掩码，环回接口的掩码一般全为1，既255.255.255.0。环回接口有一个特性，除非设备瘫痪，否则其状态一直是up。这个特征对于路由协议来说非常重要。环回接口是使用广泛的一种逻辑接口。在一个网络中，不同设备的环回接口地址以及同一设备上的不同环回接口地址应该统一规划，避免重复。 创建环回接口的原因 用来建立路由邻居 我们知道路由协议想要正常运行，大多数需要先建立邻居关系，邻居关系的稳定是路由计算正确的基石。实际运用中，常常使用环回接口来建立两个路由器之间的邻居关系。比起使用物理接口建立连接，使用环回接口可以使邻居关系更加牢固，因为就算某刻物理链路和接口发生了故障，只要能从其他途径访问到该设备，那么邻居关系就不会中断。 用来作为Router-ID 在常用的OSPF，BGP登录有协议中，都有Router-ID的概念，这相当与一台路由器的身份证号，在一个指定的范围（如一个自治系统）内只能标识一台设备，不能有重复。因为环回接口的稳定性，我们常使用一个环回接口地址来作为Router-ID，使整个设备标识稳定可靠。 使用环回接口作为Router-ID还有一个好处就是可以节省地址，因为环回接口的地址一般和业务地址没有关系，是独立规划的。 用于虚拟隧道的链接 在建立IPSec或GRE之类的虚拟隧道时，使用loopback接口可以保证整个隧道的稳定性。 用于网络连通性测试 创建并配置好环回端口之后，它的地址是能被ping或telnet的，这就可以被用来测试网络的连通性。 如何创建loopback接口Router(config)# interface loopback[number] 注意：启动OSPF路由选择进程时会选择OSPF的路由器ID。这发生在手动执行了router ospf命令或者在启动过程中加载路由器配置时。因此，如果在启用了OSPF之后再创建环回接口，那么该环回接口将不会被用作路由器ID；然而，如果重新启动路由器，默认将使用环回接口。因此，建议优先创建环回接口并给它先分配IP地址，再启动OSPF,这样可以消除关于路由器ID的困惑]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>Cisco知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RIPv1基本配置]]></title>
    <url>%2F2019%2F04%2F16%2FRIPv1%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[RIPv1基本配置#拓扑图： Lo0：表示环回口0，可以把一个环回口想象成路由器上的一个接口接了一台主机，这个主机的地址是1.1.1.1 配置命令配置路由器R1router rip //启动RIP进程 version 1 //配置RIP版本1 network 1.0.0.0 //通告网络 network 192.168.12.0 配置路由器R2router rip version 1 network 192.168.12.0 network 192.168.23.0 配置路由器R3router rip version 1 network 192.168.23.0 network 192.168.34.0 配置路由器R4router rip version 1 network 192.168.34.0 network 4.0.0.0 实验调试查看路由表show ip route 以上输出表面路由器R1学到了三条RIP路由，其中条目“R 4.0.0.0/8[120/3] via 192.168.12.2,00:00:13,Serial0/0/0”的含义如下： R：路由条目是通过RIP路由协议学来的； 4.0.0.0/8：目的网络 120：RIP路由协议的默认管理距离； 3：度量值，从路由器R1到达网络4.0.0.0/8的度量值为3跳； 192.168.12.2：下一跳地址； 00:00:13：距离下一次更新还有17（30-13）秒； Serial0/0/0：接收该条路由条目的本路由器的接口 查看路由协议配置和统计信息show ip protocols Routing Protocols is “rip”:路由器上运行的路由协议是RIP Send updates every 30 seconds,next due in 23 seconds:更新周期是30秒，距离下次更新还有23秒 Outgoing update filter list for all interfaces is not set:在入方向上没有设置过滤列表 Incoming update filter list for all interfaces is not set:在出方向上没有设置过滤列表 Invalid after 180 seconds,hold down 180,flushed after 240:路由条目如果在180秒还没有收到更新，则被标记为无效 Redistributing:rip:只允许rip协议，没有其他的协议重分布进来 Default version control:send version 1, receive version 1:默认发送版本1的路由更新，结束版本1的路由更新]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>Cisco强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RIP概述]]></title>
    <url>%2F2019%2F04%2F16%2FRIP%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[动态路由协议包括距离向量路由协议和链路状态路由协议。RIP（Routing Information Protocols，路由信息协议）是使用最广泛的举例向量路由协议。RIP是为小型网络环境设计的，因为这类协议的路由学习及路由更新将产生较大的流量，占用过多的带宽。 概述RIP是由Xerox在70年代开发的，最初定义在RFC1058中，RIP用两种数据包传输更新：更新和请求，每个有RIP功能的路由器默认情况下每隔30秒利用UDP520端口向与它直连的网络邻居广播（RIP v1）或组播（RIP v2）路由更新。因此路由器不知道网络的全局情况，如果路由更新在网络上传播慢，将会导致网络收敛慢，造成路由环路。为了避免路由环路，RIP采用水平分割、毒性逆转、定义最大跳数、闪式更新、抑制计时五个机制来避免路由环路。 RIPv1、RIPv2相同点RIP协议分为版本1和版本2.不论是版本1或者版本2，都具备下面的特征： 都是距离向量路由协议； 使用跳数（Hop Count）作为度量值； 默认路由更新周期为30秒； 管理距离（AD）为120； 支持触发更新； 最大跳数为15跳； 支持等价路径，默认4条，最大6条； 使用UDP520端口进行路由更新； 不同点 RIPv1 RIPv2 在路由器更新的过程中不携带子网信息 在路由器更新的过程中携带子网信息 不提供认证 提供明文和MD5认证 不支持VLSM和CIDR 支持VLSM和CIDR 采用广播更新 采用组播（224.0.0.9）更新 有类别（Classful）路由协议 无类别（Classless）路由协议]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>Cisco强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单新增的元素与属性]]></title>
    <url>%2F2019%2F04%2F15%2F%E8%A1%A8%E5%8D%95%E6%96%B0%E5%A2%9E%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%8E%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[表单内元素的form属性在HTML4中，表单内的从属元素必须书写在表单内部，而在HTML5中，可以把他们书写在页面上任何地方，然后为该元素指定一个form属性，属性值为该表单的id，这样就可以声明该元素从属于指定表单了 123456 < /form>< /textarea> 这样做的好处是，如果你需要向页面添加一些样式，比较好添加，因为它们不会分散在表单之内了，所以添加相关的css效果，也会变得方便很多 表单内元素的formaction属性在HTML4中，一个表单之内的所有元素只能通过表单的action属性被统一提交到另一个页面，而在HTML5中可以为所有的提交按钮，增加不同的formaction属性，使单击不同的按钮时可以将表单提交到不同的页面 123456 提交到xx.jsp页面 提交到xx.jsp页面 提交到xx.jsp页面< /form> 表单内元素的formmethod属性在HTML4中，一个表单内只能有一个action属性用来对表单内所有元素统一指定提交页面，所以每个表单内页只有一个method属性来统一指定提交方法。在HTML5中，可以使用formmethod属性来对每一个表单元素指定不同的提交方法。 提交方法：提交时最常用的有像GET和POST两种方式 1234 提交 提交< /form> 表单内元素的formenctype属性在HTML4中，表单元素具有一个enctype属性，该属性用于指定在表单发送到服务器之前应该如何对表单内的数据进行编码； 在HTML5中，可以使用formenctype属性对表单元素分别指定不同的编码方式； 1234 < /form> formenctype的三种属性 text/plain属性：表单数据中的空格被转换为加号，但不对表单数据中的特殊字符进行编码 multipart/form-data属性：不对字符进行编码，在使用包含文件上传控件的表单时，必须使用改值 application/x-www-form-urlencoded属性：发送前编码所有字符，当表单元素的action属性为get时浏览器则用当前的编码方式把表单数据转换成一个字符]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Valine-访问被api域名白名单拒绝]]></title>
    <url>%2F2019%2F04%2F15%2FValine-%E8%AE%BF%E9%97%AE%E8%A2%ABapi%E5%9F%9F%E5%90%8D%E7%99%BD%E5%90%8D%E5%8D%95%E6%8B%92%E7%BB%9D%2F</url>
    <content type="text"><![CDATA[发现错误 打开LeanCloud控制台点击设置->安全中心 添加相关网站网址 回到网站刷新查看 成功解决！]]></content>
      <categories>
        <category>教学</category>
      </categories>
      <tags>
        <tag>github搭建个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为博客添加域名]]></title>
    <url>%2F2019%2F04%2F15%2F%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[阿里云上购买域名 购买后点击解析 修改IP以及主机记录获得博客IP的方法：在cmd页面ping博客”.github.io后缀”的域名 eg: 点击修改弹出如下窗口，填入相关信息 eg: 记录值中填入博客的IP以及修改主机记录（随意），其他选项默认 创建CNAME文件放入仓库在站点的source文件夹下创建CNAME文件 在CNAME中写入你购买的站点名 添加域名成功！]]></content>
      <categories>
        <category>教学</category>
      </categories>
      <tags>
        <tag>github搭建个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新增的非主体结构元素（一）]]></title>
    <url>%2F2019%2F04%2F14%2F%E6%96%B0%E5%A2%9E%E7%9A%84%E9%9D%9E%E4%B8%BB%E4%BD%93%E7%BB%93%E6%9E%84%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在HTML5中，还增加了一些用来表示逻辑结构或者是附加信息的非主体结构元素 header元素 footer元素 hgroup元素 address元素 header元素header元素是一种具有引导和导航作用的结构元素，通常用来放置整个页面或页面内的一个内容区块的标题，但是也可以包含其他内容，例如数据表格、搜索歌单或相关的logo图片 以前我们是通过一个div包裹然后给它设定一个class或者id指定是header用来包含整个页面或页面内的区域块的一个标题 注意：header的出现不一定只有一次，它可以出现多次，不论是在整个页面来表示他的标题，或者说区域块来表示标题都是可以的 旧版的写法1234< /div>< /div>< /div> ##现在的写法 1234567891011 页面标题< /h1>< /header> Hello< /h1> < /header>< /article> 通常一个header元素至少包含一个h元素 完整的例子123456789101112 IT最新技术< /h1> 姚的博客< /a> 学习< /a>< /li> 技术< /a>< /li> 运动< /a>< /li> < /ul> < /nav>< /header>]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新增的主题结构元素（七）]]></title>
    <url>%2F2019%2F04%2F14%2F%E6%96%B0%E5%A2%9E%E7%9A%84%E4%B8%BB%E9%A2%98%E7%BB%93%E6%9E%84%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[footer元素footer元素可以作为其上层父级内容区块或是一个根区块的脚注。footer通常包括其相关区块的脚注信息，如作者、相关阅读链接及版权信息等。 旧版本和新版本的书写区别旧版的书写方式12345678 版权信息< /a>< /li> 站点地图< /a>< /li> 联系方式< /a>< /li> < /ul>< /div> 新版的书写12345678 版权信息< /a>< /li> 站点地图< /a>< /li> 联系方式< /a>< /li> < /ul>< /footer> footer元素的使用与header元素的使用相似footer元素与header元素一样，一个页面也限制为必要使用一个数量，在当前的页面当中，未必只包含一个footer用来表示底部，它还可以在一个区域块当中进行表示（与header元素的使用比较相似）； eg: 123456789101112 这是一个文章的底部 < /footer>< /article> 这是一个文章的底部 < /footer>< /section> hgroup元素hgroup元素是将标题及其子标题进行分组的元素。hgroup元素通常会将h1~h6元素进行分组，譬如一个内容区块的标题及其子标题算一组 当我们需要为主标题加上一个子标题的时候，尤其是一些文章，或者是一些我们看到的广告，它会有子标题 当只有一个标题的时候，我们就没有必要去使用hgroup;当标题过多，第一个和第二个是同一级，而且他是属于第一个的子标题的时候，此时我们应该使用hgroup将其包裹起来，代表当前他是一个子标题 1234567891011121314151617181920212223 这是文章标题 < /h1> 这是一个子标题< /h2> < /hgroup> 2015-10-10< /time>< /p> < /header> 这是内容 < /div> 这是底部 < /footer>< /article> 内容区域块使用div重载，存在的样式都通过div来进行添加一些css样式]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新增的主题结构元素（六）]]></title>
    <url>%2F2019%2F04%2F14%2F%E6%96%B0%E5%A2%9E%E7%9A%84%E4%B8%BB%E9%A2%98%E7%BB%93%E6%9E%84%E5%85%83%E7%B4%A0%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[address元素address元素的简介address元素用来在文档中呈现联系信息，包括文档作者或者文档维护者的名字、他们的网络链接、电子邮箱、真实地址、电话号码等。address应该不只用来呈现电子邮箱或真实地址，还用来展示跟文档相关的联系人的所有联系地址。 123456789101112131415 < /a> < /a>< /address> < /a> 欢迎来到Yaoremu的博客 < /address> 2015-10-10< /time> < /div>< /footer> HTML5的结构大纲编排的规则显示编排内容区域块显示编排是指明确的使用section等元素创建文档结构，在每个区域块使用标题，类似与< h1 > ~ < h6 >或< hgroup >等…… 隐示编排内容区域块所谓隐示编排指不明确使用section等元素，而是根据网页需求，来写各级的< h1 > ~ < h6 >或者< hgroup >，把各级内容区域块自动创建出来 标题分级从< h1 > ~ < h6 >它的级别是不同的，更具标题不同，那么级别也不同。如果新的出现的标题比上一个标题级别低，将生成下级内容区域块；如果新出现的标题比上一标题级别要高，或者两者级别相等的情况下，将生成新的区域块 不同区域块使用相同级别标题eg: 123456789101112131415161718192021222324252627282930 网页标题< /h1> 首页< /a>< /li> 帮助< /a>< /li> < /ul> < /nav>< /header> 文章主标题< /h1> 文章子标题< /h2> < /hgroup> 文章正文< /p> 评论标题< /h1> 评论正文< /p> < /article> < /div> < /section>< /article> 版权所有...< /small>< /footer>]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新增的主题结构元素（五）]]></title>
    <url>%2F2019%2F04%2F13%2F%E6%96%B0%E5%A2%9E%E7%9A%84%E4%B8%BB%E9%A2%98%E7%BB%93%E6%9E%84%E5%85%83%E7%B4%A0%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[time元素与微格式微格式：它是一种利用HTML5的class属性来对网页添加的附属信息的方法，那么附加的信息有可能新闻发生的时间，日期，个人电话号码，企业邮箱等，微格式并不是在HTML5之后才有的，在HTML5之前它就和HTML结合使用了，但是在使用过程当中发现日期和时间的机器编码上出现了一些问题，编码过程中会产生一些歧义。HTML5增加了一个新的元素，来无歧义的，明确的对机器码时间、日期进行编码，并且让人一读，很容易认出它，这个元素就是TIME元素 Time元素： Time元素代表的是24小时中某一个时刻或者某一个日期，它是允许带时差的 12342015-10-10< /time>2015-10-10< /time>2015-10-10< /time>2015-10-10< /time> 编码时，机器读到的在datetime属性当中，而元素的开始标记和结束标记之间的部分是显示在网页上的 datetime属性 日期与时间之间用T来表示，它是一个间隔分隔符（T代表的是Time） Z表示的是机器编码使用的是UTC标准时间 +时间：表示另一地区的时差，如果是在本地编码，而且是在本地使用就不需要再加这个时差 pubdate属性pubdate是一个可选的，布尔类型的值得属性，它可以用在article元素中的time元素上，意思是time元素代表了文章或者整个网页的发布日期，pubdate属性的具体使用方法通过下面案例来演示。 提问：为什么使用pubdate属性，为什么不能直接使用time表示当前发布的一个日期 1234567891011 苹果< /h1> 发布日期 2015-10-10< /time> < /p> 舞会时间 2015-10-12< /time> < /p> < /header>< /article> 此时程序中有两个time，所以我们要有一个明确的time来指出他是一个发布时间，这个时候我们就在第一个time中加上一个pubdate，用它来表示当前具体的发布时间]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新增的主题结构元素（四）]]></title>
    <url>%2F2019%2F04%2F13%2F%E6%96%B0%E5%A2%9E%E7%9A%84%E4%B8%BB%E9%A2%98%E7%BB%93%E6%9E%84%E5%85%83%E7%B4%A0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[section元素section元素用于对网站或应用程序中页面上的内容进行分块。一个section元素通常由内容及其标题组成。但section元素并非一个普通的容器元素；当一个容器需要被直接定义样式或通过脚本定义行为时，推荐使用div而非section元素。 通常不推荐为那些没有标题内容使用section元素。 section元素的作用是对页面上的那些内容进行分块，或者说对文章进行分段，请不要与有了自己完整的独立的内容的aritcle元素进行混淆。 123456789101112131415161718 苹果< /h1> 这是一个苹果，可以吃。而且很好吃< /p>< /section> 苹果< /h1> 这是一个苹果，可以吃。而且很好吃 红富士< /h2> 这是一种外表很红的苹果，吃起来也不赖< /p> < /section> 国光< /h2> 这是一种外表很红的苹果，吃起来也不赖< /p> < /section>< /article> 第一行不适用section的原因：这里可以使用section元素，但是由于其结构非常清晰，分析器可以识别第一行内容在一个section元素当中，所以可以将第一个section进行省略 section与article的区别123456789 水果< /h1> pingguo< /h2> 内容< /p> < /article>< /section> 在HTML5中，article元素可以看成是一个特殊类的section元素，它比section元素更加强调独立性，既section元素强调分段或分块，而article元素强调的是独立性。具体来说，如果一块内容相对于比较独立、完整的时候，应该使用article元素；但如果想将一块内容分为几段，那这个时候可以使用section元素。 在HTML5中，div元素作为一个容器的存在，当使用css样式时，可以对这个容器进行总体的css样式的嵌套;即不要讲section元素作为设置样式页面的容器，这是div的工作 总结 不要讲section元素作为设置样式的页面容器； 如果article元素、aside元素、nav元素更符合使用条件，那不要使用section元素 没有标题内容，不要section元素；section元素是要存在一个标题的]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新增的主题结构元素（三）]]></title>
    <url>%2F2019%2F04%2F12%2F%E6%96%B0%E5%A2%9E%E7%9A%84%E4%B8%BB%E9%A2%98%E7%BB%93%E6%9E%84%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[nav元素是一个可以用在页面导航的连接组，其中的导航元素链接到其他的页面或当前页面的其他部分。并不是所有的连接组都要被放进nav元素，只需要将主要的、基本的链接组放进nav元素即可。 nav元素的应用场景： 传统导航条 侧边栏导航 页内导航 翻页操作 nav元素通常承载一个列表元素 nav元素是可以多处使用的 12345678910111213141516171819202122232425262728293031 主页< /a>< /li> 开发文档< /a>< /li>< /nav> HTML5与CSS3的历史< /h1> HTML5历史< /a>< /li> CSS3历史< /a>< /li> < /ul> < /nav> < /header> HTML5历史< /h1> ....< /p> < /section> CSS3的历史< /h1> ....< /p> < /section> 删除< /a> 修改< /a> < /footer>< /article> 版权声明：< /small>< /p>< /footer> 标签定义文档中的节（section、区段）。比如：章节、页眉、页脚或文档中的其他部分。 注意：HTML5中不能使用menu元素代替nav元素。manu元素是用在一系列发出命令的菜单上的，是一种交互性的元素，确切点说是使用在web应用程序中的。]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新增的主题结构元素（二）]]></title>
    <url>%2F2019%2F04%2F12%2F%E6%96%B0%E5%A2%9E%E7%9A%84%E4%B8%BB%E9%A2%98%E7%BB%93%E6%9E%84%E5%85%83%E7%B4%A0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[aside元素aside元素用来表示当前页面或文章的附属信息部分，它可以包含与当前页面或主要内容相关的引用，侧边栏、广告、导航条以及其他类似有区别于主要内容的部分。 article元素内使用aside元素是针对于article元素的名词解释；eg：在< p>下面存放了一个aside元素，用来存放名词解释的部分； 12345678 语法< /h1> 文章的正文......< /p> 名词解释< /h1> 语法：这是一个对语言来说很重要的内容体< /p> < /aside>< /article> article元素之外使用作为页面或站点全局的附属信息部分，最典型的形式是侧边栏，其中的内容是可以有一些链接，博客中的或者是文章列表、广告单元等等； （我们也可以在aside元素中添加一个弹出窗，然后把它当成一个广告单元，在很多论坛上经常会看到在右下角会弹出一个框，可以给它加一下样式，然后让他弹出来就会是一个广告单元；既可以通过aside来进行承载） 1234567891011121314151617181920 语法< /h1> 文章的正文......< /p> 名词解释< /h1> 语法：这是一个对语言来说很重要的内容体< /p> < /aside>< /article> 评论 2018-3-10< /a>< /li> 大牛：真希望能好好学习一下 < /a>< /li> < /nav>< /aside> nav元素：表示导航 通过使用article元素我们可以发现当前页面的语义化是非常明确的，让人读起来是一下就可以了然，我就知道你当前是在哪、或者做什么的、它的具体作用是什么；]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新增的主题结构元素（一）]]></title>
    <url>%2F2019%2F04%2F11%2F%E6%96%B0%E5%A2%9E%E7%9A%84%E4%B8%BB%E9%A2%98%E7%BB%93%E6%9E%84%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[article元素article元素 代表文档、页面或应用程序中独立的、完整的、可以独自被外部引用的内容。它可以是一篇博客或者报刊中的文章，一篇论坛帖子、一段用户评论或独立的插件，或其他任何独立的内容。 eg: 12345678910 YaoRemu< /h1> Hello，欢迎来到YaoRemu的博客< /p> Hello< /p> 这是底部< /p> < /footer>< /article> article元素是可以嵌套使用的 内层的内容在原则上需要与外层的元素相关联（eg：一篇博客文章中，针对于该文章的评论，就可以使用嵌套article元素的方式，因它们有一个所属关系，用来呈现当前的评论，可以使用article元素来进行包裹一下） eg: 123456789101112131415161718192021 YaoRemu< /h1> Hello，欢迎来到YaoRemu的博客< /p> < /header> 作者 < /header> 评论 < /p> time < /footer> < /aritcle> 这是底部< /p> < /footer>< /article> 为了更加的语义化，更加的方便我们去阅读源码，可以使用article元素，使用article元素代替div后，从语义化来说，它是非常方便的，但是从内容的呈现角度来说，他们是没有区别的。 article元素可以用来表示插件eg: 12345678910111213141516171819202122232425262728 YaoRemu< /h1> Hello，欢迎来到YaoRemu的博客< /p> < /header> 作者 < /header> 评论 < /p> time < /footer> < /aritcle> 这是底部< /p> < /footer>< /article> 这是一个内嵌页面< /h1> < /embed> < /object>< /article> eg: < embed>标签定义嵌入的内容，比如插件（演示中表示引入当前页面）]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新增的元素和废除的元素]]></title>
    <url>%2F2019%2F04%2F11%2F%E6%96%B0%E5%A2%9E%E7%9A%84%E5%85%83%E7%B4%A0%E5%92%8C%E5%BA%9F%E9%99%A4%E7%9A%84%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[新增的元素新增的结构元素section、article、aside、header、hgroup、footer、nav、figure section：页面中的内容块（eg：章节、页眉、页脚……），可以与< h1>~< h6>等元素结合使用，表示文档的结构 article：页面中的一块与上下文不相干的独立内容（eg：博客中的一篇文章、报纸中的一篇文章） aside：表示article元素内容之外的，与article元素内容相关的补助信息 header：表示页面中的一个内容区域块，通常用它来表示标题 hgroup：用于对整个页面或者页面中的一个内容块的标题进行结合 footer：表示页面中的一个部分、一个区域块，通常表示这个区域块的脚部（底部），通常我们会用它来承载作者的姓名，日期等一下与作者相关的元素 nav：表示页面中的导航链接部分 figure：表示一段独立的流的内容，一般表示文档中主体流内容中的一个独立的单元 新增的其他元素video、audio、embed、mark、progress、meter、time、ruby、rt、rp、wbr、canvas、command、details、datalist、datagrid、keygen、output、source、menu video：video元素来定义视频（eg：电影片段、视频流） audio：定义音频、音乐或者音频流 canvas：画布，对于画布我们比较注重，因为无论是在应用当中还是在游戏当中，我们对canvas的应用都比较多；canvas表示图形（eg：图表或者其他图形），这个元素本身没有行为，仅仅提供一块画布，但它的一个绘图API展示给客户端JavaScript以及脚本，能够把想绘制的东西绘制在这块画布上 新增的input元素的类型email、url、number、range、Date Pickers email：email表示必须输入的email地址 url：表示文本框输入的一个地址 number：表示数字 range：表示输入框内的一个数字的范围值 Date Pickers：关于日历的日期，时间， 废除的元素能使用CSS替代的元素：basefont、big、center、font、s、tt、u等不再使用frame框架对于< frameset>元素，< frame>元素以及< noframes>元素，由于frame框架对网页可用性存在负面的影响，在HTML5当中以及不支持frame框架，只支持iframe，或者用服务器创建的由多个页面组成的复合页面的形式，同时，以上三个元素被废除 只能部分浏览器支持的元素其他被废除的元素新增的属性和废除的属性新增的属性 表单相关的属性 链接相关的属性 其他属性 废除的属性在后面的文章进行详解]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5与HTML4区别]]></title>
    <url>%2F2019%2F04%2F10%2FHTML5%E4%B8%8EHTML4%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[推出理由及目标HTML5的储蓄，对于Web来说的意义是非常重大的，因为他的意图是想把目前Web上纯在的各种问题一并解决掉了。 Web浏览器之间的兼容性很低 （规范不统一，没有标准化） 文档结构不够明确 （之前表示文档的标题、正文都是使用< div>来排版，结构比较混乱） Web应用程序的功能收到了限制 世界知名浏览器厂商对HTML5的支持：微软（IE9以下不支持）、Google、苹果、opera、Mozilla 语法的改变内容类型文件扩展符（.html、.htm）与内容类型（text.html）保持不变； DOCTYPE声明在HTML4中，我们要明确的指出是哪一个版本；而在HTML5中可以省略部分内容； eg: < !DOCTYPE html> 指定字符编码在HTML4中需要很多声明；eg: < meta http-equiv="content-type" content="text/html;charset=UTF-8"> 在HTML5中则非常简单；eg: < meta charset="UTF-8"> 可以省略标记的元素在HTML5中，元素的标记可以进行省略（详细内容之后再提）； 具有boolean值的属性当这些属性值不指定属性值时，默认表现为true；如果想将属性设为固定的true，可将属性值设为属性名，或者字符串设置为空，不写（默认为true）； 如果想将属性值设为false，可不写该属性； eg: 前三true，最后一个false 省略引号指定属性值时，必须指定引号；但是在HTML5中，可以省略引号;]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新增的属性和废除的属性]]></title>
    <url>%2F2019%2F04%2F10%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0-%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[contentEditable属性允许用户编辑元素中的内容，取值为true【可编辑】、false【不可编辑】eg: designMode属性指定整个页面是否可以编辑（只能在JavaScript中修改编辑），取值：on【可编辑】、off【不可编辑】 hidden属性通知浏览器不渲染该元素，使该元素为不可见状态，取值：true【可见状态】、false【不可见状态】eg:不可见状态 spellcheck属性针对input元素与textarea文本输入框提供的新属性，对用户输入的文本内容进行拼写和文本检查eg: tabindex属性不断敲击tab键，让窗口或页面中的控件获得焦点，对窗口中的所有控件进行遍历，每一个tableindex属性表示该接口是第几个访问到的eg:]]></content>
      <categories>
        <category>【极客】前端学习</category>
      </categories>
      <tags>
        <tag>前端知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown进阶操作]]></title>
    <url>%2F2019%2F04%2F10%2FMarkDown%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[图片处理有时候希望图片变得小一点，或者让他靠左边，使得排版更加美观，但是默认没有提供这类操作，可以直接引入HTML来设置； 基本形式 ！[图片描述]（图片链接） 例子： ！[头像]（ http://ww1.sinaimg.cn/large/8c0b2220gy1g1ae3jfoogj20du0duwf0.jpg ） 自定义尺寸 < img width=’150’ height=’150’ src=” http://ww1.sinaimg.cn/large/8c0b2220gy1g1ae3jfoogj20du0duwf0.jpg “> 插入音乐在网易云音乐生成外连接，直接复制黏贴即可；（如果不想自动播放，可以把auto改成0） < iframe frameborder=”no” border=”0” marginwidth=”0” marginheight=”0” width=330 height=86 src=”//music.163.com/outchain/player?type=2&id=29979976&auto=1&height=66”> 插入视频 视频与图片和音乐同理，不在赘述； 设置不同的字体颜色 < font color=red>我是红色 eg: 我是红色 设置不同类型的字体 < font face=”黑体”>我是黑体 eg: 我是黑体 添加背景色 < table>< tr>< td bgcolor=”red”> 背景色是:red < / td>< / tr>< / table> eg: 背景色是:red]]></content>
      <categories>
        <category>教学</category>
      </categories>
      <tags>
        <tag>MarkDown基本语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络端口地址转换NAPT配置]]></title>
    <url>%2F2019%2F03%2F31%2F%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAPT%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[拓扑图 相关知识①：NAT将网络划分为内部网络和外部网络两部分，局域网主机利用NAT访问网络时，是将局域网内部的本地地址转换为全局地址（互联网合法的IP地址）后转发数据包； 相关知识②：NAT分为两种类型：NAT（网络地址转换）和NAPT（网络端口地址转换IP地址对应一个全局地址）； 相关知识③：NAPT：使用不同的端口来映射多个内网IP地址到一个指定的外网IP地址，多对一。NAPT采用端口多路复用方式。内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可以隐瞒内部的所有主机，有效的避免来自Internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式 配置命令配置Router0enable configure terminal hostname R0 配置端口interface fa0/0 ip address 192.168.1.1 255.255.255.0 no shutdown exit interface s0/0/0 ip address 200.1.1.1 255.255.255.0 no shutdown clock rate 64000 exit 配置Router1enable configure terminal hostname R1 配置端口interface s0/0/0 ip address 200.1.1.2 255.255.255.0 no shutdown exit interface fa0/0 ip address 200.1.2.1 255.255.255.0 no shutdown exit 配置Router0静态路由ip route 200.1.2.0 255.255.255.0 200.1.1.2 配置Router1静态路由ip route 192.168.1.0 255.255.255.0 200.1.1.1 查看路由表end show ip route 使用PC1测试能否与服务器通信CMD Web浏览器 Router0上进行网络端口地址转换NAPT配置interface fa0/0 ip nat inside //设定私有地址连接口 exit interface fa2/0 ip nat outside //设定公有地址连接口 exit access-list 1 permit 192.168.1.0 0.0.0.255 //建立一个控制列表，列表名为1，用来定义内部使用的私有IP地址段，为地址段转换为公网IP做准备 ip nat pool 5ijsj 200.1.1.3 200.1.1.3 netmask 255.255.255.0 //定义一个IP地址池 ip nat inside source list 1 pool 5ijsj overload //启用内部源地址转换为动态NAT //无overload表示多对多，有overload表示多对一 end show ip nat translations //查看NAT转发表 实验结果PC1使用Web浏览器范文服务器 查看NAT转发表show ip nat translations(有1个结果) PC2使用web浏览器访问服务器 eg: 再次查看NAT转发表show ip nat translations(有2个结果) eg:]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>Cisco基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络地址转换NAT配置]]></title>
    <url>%2F2019%2F03%2F30%2F%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[拓扑图 相关知识①：网络地址转换NAT（Network Address Translation）,被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了IP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。 相关知识②：默认情况下，内部IP地址是无法被路由到外网的，内部主机10.1.1.1要与外部Internet通信，IP包到达NAT路由器时，IP包头的源地址10.1.1.1被替换成一个合法的外网IP，并在NAT转发表中保存这条记录。 当外部主机发送一个应答到内网时，NAT路由器收到后，查看当前NAT转换表，用10.1.1.1替换掉这个外网地址。 相关知识③：NAT将网络划分为内部网络和外部网络两部分，局域网主机利用NAT访问网络时，将局域网内部的本地地址转换为全局地址（互联网合法的IP地址）后转发数据包； 相关知识④：NAT分为两种类型：NAT（网络地址转换）和NAPT（网络端口地址转换IP地址对应一个全局地址）；①、 静态NAT：实现内部地址与外部地址一对一映射。现实中，一般都用于服务器；②、 动态NAT：定义一个地址池，自动映射，也是一对一的。现实中，用的比较少；③、 NAPT：使用不同的端口来映射多个内网IP地址到一个指定的外网IP地址，多对一； 配置命令配置Router0enable configure terminal hostname R0 配置路由器端口interface fa0/0 ip address 192.168.1.1 255.255.255.0 no shutdown exit interface s0/0/0 ip address 222.0.1.1 255.255.255.0 no shutdown clock rate 64000 exit 配置Router1enable configure terminal hostname R1 配置路由器端口interface s0/0/0 ip address 222.0.1.2 255.255.255.0 no shutdown exit interface fa0/0 ip address 222.0.2.1 255.255.255.0 no shutdown exit Router0静态路由配置ip route 222.0.2.0 255.255.255.0 222.0.1.2 Router1静态路由配置ip route 192.168.1.0 255.255.255.0 222.0.1.1 使用PC0尝试与服务器通信ping 192.168.1.2 （成功通信） Web浏览器 （成功通信） Router0进行NAT配置interface fa0/0 ip nat inside //设定私有地址连接口(局域网) exit interface fa s0/0/0 ip nat outside //设定公有地址连接口(广域网) exit ip nat inside source static 192.168.1.2 222.0.1.3 //设置NAT地址，将内网地址映射为外网地址 end show ip nat translations //查看NAT转发表 知识点①：对于路由器来说：①inside对应的是access-list（访问控制列表）、②outside对应的是转换地址池； 实验结果ping被转换后的地址： 222.0.1.3 （成功通信） Web浏览器中尝试访问转换后的地址：222.0.1.3 （成功通信）]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>Cisco基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展IP访问控制列表配置]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%89%A9%E5%B1%95IP%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[拓扑图 知识点①：访问控制列表定义的典型规则主要有以下：源地址，目标地址，上层协议，时间区域；扩展IP访问列表（编号100-199、2000、2699）使用以上四种组合来进行转发或阻断分组；可以根据数据包的源IP、目的IP、源接口、目的接口、协议来定义规则，进行数据包的过滤。 知识点②：扩展IP访问列表的配置包括以下两部分：①定义扩展IP访问列表；②将扩展IP访问列表应用于特定接口上； 配置命令配置Router0端口enable configure terminal hostname R0 interface fa0/0 ip address 172.16.1.1 255.255.255.0 no shutdown exit interface fa0/1 ip address 172.16.2.1 255.255.255.0 no shutdown exit 配置Router1端口enable configure terminal hostname R1 interface fa0/1 ip address 172.16.2.2 255.255.255.0 no shutdown exit interface s0/0/0 ip address 172.16.3.1 255.255.255.0 no shutdown clock rate 64000 配置Router2端口enable configure terminal hostname R2 interface s0/0/0 ip address 172.16.3.2 255.255.255.0 no shutdown exit interface fa0/0 ip address 172.16.4.1 255.255.255.0 no shutdown exit 配置Router0静态路由ip route 0.0.0.0 0.0.0.0 172.16.2.2 配置Router2静态路由ip route 0.0.0.0 0.0.0.0 172.16.3.1 配置Router1静态路由ip router 172.16.1.0 255.255.255.0 172.16.2.1 ip router 172.16.4.0 255.255.255.0 172.16.3.2 end show ip route //查看路由表 实验PC0尝试与服务器通信ping 172.16.4.2（此时成功通信） 使用网页尝试通信 Router1上配置扩展IP访问控制列表configure terminal 允许源主机地址使用TCP协议通过出站端口访问目标地址WEB服务器access-list 100 permit tcp host 172.16.1.2 host 172.16.4.2 eq www 禁止源主机地址使用icmp协议通过出站端口到达目标主机地址WEB服务器access-list 100 deny icmp host 172.16.1.2 host 172.16.4.2 echo 知识点①：echo表示：传递echo报文 知识点②：ICMP协议（Internet Control Message Protocol Internet控制报文协议）：TCP/IP协议簇的一个子协议，用在IP主机，路由器之间传递控制消息；控制消息：指网络通不通，主机是否可达、路由是否可用等网络本身的消息； 将ACL应用到端口interface s0/0/0 ip access-group 100 out end 实验结果ping 172.16.4.2（此时无法通信） 使用网页尝试通信（此时成功通信）]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>Cisco基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标准 IP 访问控制列表配置]]></title>
    <url>%2F2019%2F03%2F28%2F%E6%A0%87%E5%87%86-IP-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[拓扑图 相关知识①：ACLs 的全称为 接入控制列表(Access Control Lists),也称访问控制列表(Access Lists),俗称防火墙，在有的文档中还称包过滤。 相关知识②：ACLs 通过定义一些规则对网络设备接口上的数据报文进行控制；运行通过或者丢失，从而提高网络可管理型和安全性； 相关知识③：IP ACL分为两种：标准IP访问列表和扩展IP访问列表，编号范围为 1~99、1300~1999、100~199、2000~2699;标准IP访问控制列表：根据数据包的源地址定义规则，进行数据包的过滤；扩展IP访问控制列表：根据数据包的源IP、目的IP、源接口、目的端口、协议来定义规则，进行数据包的过滤； 相关知识④：IP ACL 基于接口进行规则的应用，分为：入栈应用和出栈应用； 配置命令配置路由器0enable configure terminal hostname R0 配置端口interface fa 0/0 ip address 172.16.1.1 255.255.255.0 no shutdown exit interface fa0/1 ip address 172.16.2.1 255.255.255.0 no shutdown exit interface s0/0/0 ip address 172.16.3.1 255.255.255.0 no shutdown clock rate 64000 exit 配置路由器1enable configure terminal hostname R1 配置端口interface s0/0/0 ip address 172.16.3.2 255.255.255.0 no shutdown exit interface f0/0 ip address 172.16.4.1 255.255.255.0 no shutdown exit 配置路由器0的静态路由配置静态路由ip route 172.16.4.0 255.255.255.0 172.16.3.2 配置路由器1的静态路由配置静态路由ip route 0.0.0.0 0.0.0.0 172.16.3.1 查看路由表end show ip route PC0、PC1尝试能否与PC2通信PC0: （此时成功通信） PC1: （此时成功通信） 在路由器0中配置访问控制列表建立ACL命名为 5ijsjip access-list standard 5ijsj permit 172.16.1.0 0.0.0.255 //允许网段通过 deny 172.16.2.0 0.0.0.255 //禁止网段通过 interface s0/0/0 ip access-group 5ijsj out //将ACL应用到相关端口 end 知识点：in表示过滤入口的包；out表示过滤出口的包； 实验结果再次PC0、PC1尝试能否与PC2通信PC0: （由于ACL允许 172.16.1.0 网段通过，所以PC0成功通信） PC1: （由于ACL禁止 172.16.1.0 网段通过，所以PC1通信失败）]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>Cisco基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSPF、RIP小记]]></title>
    <url>%2F2019%2F03%2F28%2FOSPF%E3%80%81RIP%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[OSPF可将OSPF比喻成导航，可以实时更新； RIP将RIP比喻成路标，是固定不变的，除非人为修改；]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>Cisco笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由器综合路由配置]]></title>
    <url>%2F2019%2F03%2F27%2F%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%BC%E5%90%88%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[拓扑图 相关知识①：运行多个路由协议进程，系统软件提供了路由信息从一个路由进程重新分布到另一个路由进程的功能；路由的相互重分布可以再所有的IP路由协议之间进行。相关命令：redistribute protocol … 相关知识②：路由重分发，可在同一网内使用多种路由协议，为了实现多种路由协议的协同工作，路由器可以使用路由重分发(route redistribution) 将学习到的一种路由协议的路由通过另一种路由协议广播出去，这样网络的所有部分就可以互通了。为了实现重分发，路由器必须同时运行多种路由协议，这样每种路由协议才可以取路由表中的所有或部分其他协议的路由来进行广播； 配置命令配置三层路由器Switch0enable configure terminal 开启Vlanvlan 2 exit 划分Vlan给端口fa0/10interface fa0/10 switchport access vlan 2 exit 注意：由于vlan1默认是划分给所有端口的，所以可以省略划分vlan1 配置Vlaninterface vlan 1 ip address 192.168.1.1 255.255.255.0 no shutdown exit interface vlan 2 ip address 192.168.2.1 255.255.255.0 no shutdown exit 查看Vlan信息end show interface vlan 1 在路由器上启动rip协议configure terminal ip routing //开启三层交换机路由功能 router rip //配置RIP协议 network 192.168.1.0 //宣告本地路由和相连路由之间的网段 network 192.168.2.0 version 2 //设置RIP版本 配置路由器Router0enable configure terminal hostname R1 配置端口interface fa0/0 ip address 192.168.2.2 255.255.255.0 no shutdown exit interface fa0/1 ip address 192.168.3.1 255.255.255.0 no shutdown exit 在路由器启动rip协议router rip network 192.168.2.0 version 2 在路由器启动ospf协议router ospf 1 //配置OSPF协议 network 192.168.3.0 0.0.0.255 area 0 //宣告直连网络 配置路由器Router1enable configure terminal hostname R2 配置端口interface fa0/1 ip address 192.168.3.2 255.255.255.0 no shutdown exit interface fa0/0 ip address 192.168.4.1 255.255.255.0 no shutdown exit 在路由器启动ospf协议router ospf 1 network 192.168.3.0 0.0.0.255 area 0 network 192.168.4.0 0.0.0.255 area 0 查看路由表end show ip route 实验结果使用Router0（中间的路由器）测试与两台PC是否能够通信ping 192.168.1.2 (success) ping 192.168.4.2 (success) 尝试PC0与PC1通信 （此时无法通信） 配置Router0（中间的路由器）configure terminal 路由重分布router rip redistribute ospf 1 //ospf路由重发布 exit router ospf 1 redistribute rip subnets //rip路由重发布 end 注意： 本例在Packet Tracer 5.2上能够正常运行，但是在Packet Tracer 5.3 上的Switch0不能学习到192.168.3.0/192.168.4.0的路由信息，所以需要给Switch0指定静态路由: ip route 0.0.0.0 0.0.0.0 192.168.2.2 再次Router1查看路由表 （查看路由重发布后该路由器学习到的路由） show ip route 再次尝试PC0与PC1通信 （成功通信）]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>Cisco基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由器OSPF动态路由配置]]></title>
    <url>%2F2019%2F03%2F26%2F%E8%B7%AF%E7%94%B1%E5%99%A8OSPF%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[拓扑图 相关知识①：OSPF(Open Shortest Path First 开放式最短路径优先)是一个内部网关协议(Interior Gateway Protocol，检测IGP)，用在单一自治系统(autonomous system,AS)内决策路由。与RIP相比，OSPF是链路状态协议，而RIP是距离矢量协议。 相关知识②：OSPF开放式最短路径优先协议，是目前网络中应用最广泛的路由协议之一；OSPF路由协议通过向全网扩散本设备的链路状态信息，使网络中每台设备最终同步一个具有全网链路状态的数据库，然后路由器采用SPF算法，以自己为根，计算到达其他网络的最短路径，最终形成全网路由信息； 配置命令配置三层交换机S3569enable configure terminal hostname S3569 划分Vlan给端口vlan 10 exit valn 20 exit interface fa 0/10 switchport access vlan 10 exit interface fa 0/20 switchport access vlan 20 exit 配置Vlaninterface vlan 10 ip address 192.168.1.1 255.255.255.0 no shutdown exit interface vlan 20 ip address 192.168.3.1 255.255.255.0 no shutdown exit end show ip route //查看路由表 配置OSPF动态路由协议configure terminal ip routing //开启三层交换机路由功能 router ospf 1 //启动OSPF进程 network 192.168.1.0 0.0.0.255 area 0 //通告直连网络 network 192.168.3.0 0.0.0.255 area 0 end show ip route 知识点①：OSPF宣告是要加反掩码的； 知识点②：area是自治系统区域的标识，eg：如果全局在一个area中，那么它们属于一个自治系统，也成单区域自治系统； 配置路由器R1enable configure terminal hostname R1 配置端口interface fa0/0 no shutdown ip address 192.168.3.2 255.255.255.0 exit interface serial 0/0/0 no shutdown clock rate 64000 ip address 1952.168.4.1 255.255.255.0 end show ip route 配置OSPF动态路由协议configure terminal router ospf 1 network 192.168.3.0 0.0.0.255 area 0 network 192.168.4.0 0.0.0.255 area 0 end show ip route 配置路由器R2enable configure terminal hostname R2 配置端口interface fa 0/0 no shutdown ip address 192.168.2.1 255.255.255.0 exit interface serial 0/0/0 no shutdown ip address 192.168.4.2 255.255.255.0 end show ip route 配置OSPF动态路由协议configure terminal router ospf 1 network 192.168.2.0 0.0.0.255 area 0 network 192.168.4.0 0.0.0.255 area 0 end show ip route 实验结果验证 PC1、PC2 主机之间可以互相通信；eg:]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>Cisco基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由器RIP动态路由配置]]></title>
    <url>%2F2019%2F03%2F25%2F%E8%B7%AF%E7%94%B1%E5%99%A8RIP%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[拓扑图 相关知识①：动态路由是指路由器能够自动的建立自己的路由表，并且根据实际情况适时的进行调整； 相关知识②：RIP(routing infromation protocol)路由信息协议：一种内部网关协议（IGP），是一种动态路由选择协议；RIP协议基于距离矢量算法，使用“跳数(metric)”来衡量到达目标地址的路由协议。（该协议的路由器只关心自己周围的世界，只与自己相连的路由器交换信息，范围在15跳之内）； 相关知识③：RIPv1与RIPv2的区别： 配置命令配置三层交换机enable configure terminal hostname S3560 划分vlan给端口vlan 10 exit vlan 20 exit interface fa0/10 switchport access vlan 10 exit interface fa0/20 switchport access vlan20 exit end show vlan 配置vlanconfigure terminal interface vlan 10 ip address 192.168.1.1 255.255.255.0 no shutdown exit interface vlan 20 ip address 192.168.3.1 255.255.255.0 no shutdown end show ip router //查看路由表 show running //查看当前配置 在三层交换机上启动rip协议configure terminal router rip //启动rip协议 network 192.168.1.0 //宣告本地路由和相连路由之间的网段 network 192.168.3.0 version 2 //设置RIP版本为2 end show ip route 配置Router2enable configure terminal hostname R2 配置端口interface fa0/0 no shutdown ip address 192.168.3.2 255.255.255.0 interface serial0/0/0 //配置路由器的串行接口 no shutdown ip address 192.168.4.1 255.255.255.0 clock rate 64000 //配置时钟频率 end show ip route 知识点①：在Packet Tracert模拟器中，必须设置时钟速率，否则路由器之间无法ping通； 知识点②：serial口：路由器连接路由器就要用路由器上的Serial端口连接 在路由器上启动rip协议conf t router rip network 192.168.3.0 network 192.168.4.0 version 2 exit 配置Router1enable configure terminal hostname R1 配置端口interface fa0/0 no shutdown ip address 192.168.2.1 255.255.255.0 interface serial0/0/0 no shutdown ip address 192.168.4.2 255.255.255.0 end show ip route 在路由器上启动rip协议configure terminal router rip network 192.168.2.0 network 192.168.4.0 version 2 end 实验结果查看拓扑图中的的两台PC是否正常通信；eg:]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>Cisco基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由器静态路由配置]]></title>
    <url>%2F2019%2F03%2F24%2F%E8%B7%AF%E7%94%B1%E5%99%A8%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[拓扑图 注：由于路由器[2811]初始时没有Serial接口，所以需要在图形化界面安装上[WIC-2T]组件； 配置命令配置Router1各个端口enable configure terminal hostname R1 interface fa0/1 no shutdown //开启端口 ip address 192.168.1.1 255.255.255.0 //配置端口IP以及子网掩码 exit interface serial 0/0/0 //配置串行接口 no shutdown ip address 192.168.3.1 255.255.255.0 clock rate 64000 //设置时钟评率，起同步作用 end 知识点①：Serial是用V35线来传输数据是同步的，连接时需要DCE同步时钟速率； 知识点②： 路由器连接路由器要用路由器上的Serial端口连接； 配置Router2各个端口enable configure terminal hostname R2 interface fa0/1 no shutdown ip address 192.168.2.1 255.255.255.0 exit interface serial 0/0/0 ip address 192.168.3.2 255.255.255 no shutdown end 配置R1静态路由enable configure terminal ip route 192.168.2.0 255.255.255.0 192.168.3.2 //配置静态路由 end show ip route //查看路由表 知识点①：ip route 静态路由格式： ip route 目标网段 目标的子网掩码 目标网段的接口 配置R2静态路由enable configure terminal ip route 192.168.1.0 255.255.255.0 192.168.3.1 //配置静态路由 end show ip route 实验结果测试PC1是否ping通PC2;eg:]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>Cisco基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由器单臂路由配置]]></title>
    <url>%2F2019%2F03%2F23%2F%E8%B7%AF%E7%94%B1%E5%99%A8%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[拓扑图 配置命令配置Switchenable configure terminal vlan 2 exit vlan 3 exit interface fastEthernet 0/2 switchport access vlan 2 //将端口划分给Vlan2 exit interface fastEthernet 0/3 switchport access vlan 3 //将端口划分给Vlan3 exit interface fastEthernet 0/1 switchport mode trunk //设置端口为trunk模式 知识点：数据包经过trukn会封装新的包头，添加对应的Vlan信息；当目标接受到该数据包，即可解包查看对应的Vlan，然后发送个对应的Vlan； 配置Routerenable configure terminal interface fastEthernet 0/0 no shutdown //开启路由器端口 exit interface fastEthernet 0/0.1 //配置虚拟子接口 encapsulation dot1q 2 //配置以太网子接口Vlan号，封装格式为802.1q ip address 192.168.1.1 255.255.255.0 //设置端口ip及其子网掩码 exit interface fastEthernet 0/0.2 encapsulation dot1q 3 ip address 192.168.2.1 255.255.255.0 end show ip route //查看路由表信息 知识点①：dot1q(802.1q): 虚拟局域网标准，在路由器中dot1q为虚拟局域网的封装模式； 知识点②：为什么要划分子接口？ 多vlan通信，各vlan间的网段不同，网关不同，但是交换机只连接路由器上的一个物理端口，所以划分多个虚拟子接口，以便于配置多个地址作为vlan的网关地址 实验结果PC1与PC2实现多Vlan通信； eg:]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>Cisco基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速生成树配置]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E6%A0%91%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[拓扑图 配置命令Switch1配置命令enable //进入特权模式 show spanning-tree //查看生成树配置 configure terminal //全局配置模式 hostname S1 //交换机更名 int fa 0/10 switchport access vlan 10 //把端口划分给Vlan 10 exit int rang fa 0/1-2 switchport mode trunk //配置端口为trunk模式 exit spanning-tree mode rapid-pvst //把交换机的生成树模式由默认的STP改成RSTP(快速生成树) end 知识点：trunk端口可封装Vlan标签，用于多Vlan交换机 Switch2配置命令enable configure terminal hostname S2 interface fa0/10 switchport access vlan 10 exit interface range fa0/1-2 switchport mode trunk exit spanning-tree mode rapid-pvst //把交换机的生成树模式由默认的STP改成RSTP(快速生成树) end show spanning-tree 知识点：PVST(per Vlan Spanning Tree)：生成树协议； RSTP(Rapid Spanning Tree Protocol):快速生成树协议;在STP的基础上实现了快速收敛，并增加了边缘端口的概念及保护； 实验结果 当主链路处于down状态的时候，交换机能够自动切换到备份链路，保证数据的正常转发； eg: 使用PC1 ping PC2ipconfig ping -t 192.168.1.3 //-t表示在手动停止前，一直发送数据包 关闭S2正常运行端口，测试快速生成树协议en conf t interface fa 0/1 shutdown //关闭正常运行的端口测试是否自动切换到备份链路 使用ping -t ip 不断的请求PC2，然后关闭正在通信的Fa0/1接口，最后查看PC1中通信情况是否正常（即交换机是否自动切换到备份链路）；]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>Cisco基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用三层交换机实现Vlan间路由]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%88%A9%E7%94%A8%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%AE%9E%E7%8E%B0Vlan%E9%97%B4%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[拓扑图 配置命令配置二层交换机enable //特权模式 configure terminal //全局配置模式 vlan 2 //开启vlan exit vlan 3 exit interface fa0/2 switchport access vlan 2 //配置端口在access模式，允许vlan2通过 exit interface fa0/3 switchport access vlan 3 exit interface fa0/1 switchport mode trunk //配置该端口为trunk模式 exit show vlan //查看vlan配置 配置三层交换机enable configure terminal vlan 2 exit vlan 3 exit interface fa0/1 switchport trunk encapsulation dot1q //给端口封装802.1q协议(dot1q),既trunk链路的中继协议 switchport mode trunk //配置该端口为trunk模式 exit interface fa0/2 switchport access vlan 2 exit interface vlan 2 //配置vlan 2 ip address 192.168.1.1 255.255.255.0 //配置IP及其子网掩码 no shutdown //开启vlan 2 exit interface vlan 3 ip address 192.168.2.1 255.255.255.0 no shutdown exit exit ip routing //启用三层交换机IP路由功能 show ip route //查看路由表 实验结果PC3分别ping测试PC1、PC2，实验结果为： PC3ping通PC1；PC3ping通PC2,实现了路由功能； eg:]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>Cisco基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cisco多交换机之间的端口聚合链路]]></title>
    <url>%2F2019%2F03%2F20%2Fcisco%E5%A4%9A%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%81%9A%E5%90%88%E9%93%BE%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[拓扑图： 相关知识：port-channel具备了逻辑端口的属性，真正成为一个独立的逻辑端口；端口汇聚是一种逻辑上的抽象过程，将一组具备相同属性的端口，抽象成一个逻辑端口；其不仅能增加网络的带宽，还能提供链路的备份功能，以及负载均衡； 配置命令Switch0的配置命令hostname SwitchA //更名 int port-channel 1 //端口聚合模式 exit int fa0/1 channel-group 1 mode on //将物理端口加入channel-group exit int fa0/2 channel-group 1 mode on exit int fa0/3 channel-group 1 mode on exit int port-channel 1 switchport mode trunk //将端口聚合配置为trunk模式 switchport trunk allowed vlan all Switch1的配置命令hostname SwitchA int port-channel 1 exit interface fa0/1 channel-group 1 mode on exit interface fa0/2 channel-group 1 mode on exit interface fa0/3 channel-group 1 mode on exit int port-channel 1 switchport mode trunk switchport trunk allowed vlan all 结果使用show run查看结果： 知识点 链路聚合的配置，实现交换机间的端口聚合，扩展网络宽带，实现链路冗余备份；]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>Cisco基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cisco多交换机上配置基于端口的Vlan隔离办公网络]]></title>
    <url>%2F2019%2F03%2F19%2Fcisco%E5%A4%9A%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B8%8A%E9%85%8D%E7%BD%AE%E5%9F%BA%E4%BA%8E%E7%AB%AF%E5%8F%A3%E7%9A%84Vlan%E9%9A%94%E7%A6%BB%E5%8A%9E%E5%85%AC%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[拓扑图 配置命令配置左边的交换机enable //特权模式 configure terminal //全局模式 interface fa 0/1 switchport mode trunk //配置Trunk switchport trunk allowed vlan all //trunk允许所有Vlan流量通行（默认trunk就是允许所有） vlan 10 //开启vlan name RD1 //命名 vlan 20 name RD2 interface range fa0/9-fa0/16 //配置一组接口 switchport access vlan 10 //把该端口划分给Vlan exit interface range f0/17-fa0/24 switchport access vlan 20 exit 配置右边的交换机enable configure terminal interface fa0/1 switchport mode trunk switchport trunk allowed vlan all vlan 10 name RD1 vlan 20 name RD2 interface range fa0/9-fa0/16 switchport access vlan 10 exit interface range fa0/17-fa0/24 switchport access vlan 20 exit 注意： access为链接电脑的端口或者傻瓜交换机（也就是同一Vlan的交换机）；trunk则肯定是连接交换机的（属于多vlan的交换机）; 测试结果结果：PC1与PC3、PC2与PC4之间能相互ping通，除此以外的任意两台电脑上ping不通的；]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>Cisco基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown基础教学]]></title>
    <url>%2F2019%2F03%2F18%2FMarkDown%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[基础语法标题# h1 ## h2 ### h3 #### h4 ##### h5 ###### h6 段落及区块引用> 这段文字被高亮显示... eg: 这段文字被高亮显示… 插入链接或图片[点击跳转百度](http://www.baidu.com) eg:点击跳转百度 ![图片](https://i.loli.net/2019/03/19/5c903bc01be37.gif) eg: 列表Markdown支持有序列表和无序列表两种形式： 无序列表使用 * 或 + 或 - 标识 * 黄瓜 * 玉米 * 茄子 + 黄瓜 + 玉米 + 茄子 - 黄瓜 - 玉米 - 茄子 有序列表使用数字加.标识，eg: 1. 1. 玉米 2. 黄瓜 3. 茄子 注意：如果在单一列表项中包含了多个段落，为了保证渲染正常，*与段落首字母之间必须保留四个空格。（如果在列表中加入了区块引用，也要缩进4个空格） 分割线*** --- eg: 强调使用 * 或 _ 包裹字符即可。使用单一符号时效果是斜体，使用两个符号标记的效果是加粗； *这里是斜体* _这里是斜体_ eg: 这里是斜体 **这里是加粗** __这里是加粗__ eg: 这里是加粗 高级应用插入代码块使用反引号进行包裹即可； 如果插入一整段代买，需要至少两个以上反引号进行包裹； ` ` `JavaScript //此处声明语言，以便生成高亮效果 function YaoRemu(){ document.write("Hello MarkDown!"); } ` ` ` eg: 123function YaoRemu(){ document.write("Hello MarkDown!");} 插入表格表头|条目一|条目二 :---:|:---:|:---: 项目|项目一|项目二 eg: 表头 条目一 条目二 项目 项目一 项目二 注意：三个杆左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字具有，两边都放置表示文字居中。 其他特殊符号处理：在使用特殊符号时，需要插入反斜杠； eg: \\ 输出: \ 给文字上色手动添加标签’’’’保存即可； eg: 我是蓝色]]></content>
      <categories>
        <category>教学</category>
      </categories>
      <tags>
        <tag>MarkDown基本语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[No3. Telnet]]></title>
    <url>%2F2019%2F03%2F18%2FciscoTelnet%2F</url>
    <content type="text"><![CDATA[拓扑图: 配置命令: 首先开启Vlan: enable configure terminal interface vlan 1 no shutdown eg: 配置交换机：设置Vlan1 IP及其子网掩码: interface vlan 1 ip address 10.1.1.154 255.255.255.0 exit 设置进入系统视图的密码：enable password **** 设置五条虚拟链接：line vty 0 4 设置特权等级[级别越高权限越大]：privilege level 1 0 设置远程链接(Telnet)的密码：password cisco 设置login验证[如果只设置login,直接输入密码即可；如果设置了login local，则需要输入用户名以及密码]:login 退出VTY[VTY(Virtual typle terminal)虚拟类型终端]的配置：exit 使用PC与交换机进行Telnet测试:Telnet 10.1.1.154 (输入前面密码即可) eg: 结果:]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>Cisco基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql服务安装]]></title>
    <url>%2F2019%2F03%2F17%2FMySql%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装过程 先添加安装文件中bin文件夹到用户环境变量(这样才可以使用命令) mysqld –initialize（执行初始化【不添加用户名】/此处注意，如果安装提示出错，可以删除 [data] 文件夹后重试 ） mysqld install (安装MySql) （由于之前已经安装过，所以这里提示 已存在） net start mysql(启动MySql服务) 完成！ 注意：要正确配置[my.ini]中的文件！！！]]></content>
      <categories>
        <category>教学</category>
      </categories>
      <tags>
        <tag>安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我的博客]]></title>
    <url>%2F2019%2F03%2F16%2F%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[~~ 欢迎各位道友!~~]]></content>
  </entry>
</search>
