{"meta":{"title":"YaoZhao'Blog","subtitle":null,"description":"欢迎来到YaoRemu的博客","author":"YaoRemu","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-03-18T08:18:02.000Z","updated":"2019-03-18T08:20:43.324Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-03-18T08:11:11.000Z","updated":"2019-03-18T08:17:01.558Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"JavaScript/Web API","date":"2019-05-14T10:33:34.707Z","updated":"2019-05-13T12:52:42.321Z","comments":true,"path":"2019/05/14/JavaScript/Web API/","link":"","permalink":"http://yoursite.com/2019/05/14/JavaScript/Web API/","excerpt":"","text":"学习目标： 掌握API和Web API的概念 掌握常见浏览器提供的API的调用方式 能通过Web API开发常见的页面交互功能 能够利用搜索引擎解决问题 Web APIWeb API 介绍API（Application Programming Interface,应用程序编程接口）是一些预选定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。 任何开发语言都有自己的API API的特征输入和输出（I/O） var max = Math.max(1,2,3); API的使用方法 ( console.log(“adf”) ) Web API的概念浏览器提供的一套操作浏览器功能和页面元素的API（BOM 和 DOM） 此处的 Web API 特指浏览器提供的API（一组方法），Web API 在后面的课程中又其他的含义 掌握常见浏览器提供的API的调用方式在使用 JavaScript 编写 Web 代码时，有许多 API 可供调用。以下是所有接口（即对象类型）的列表，你可以在开发网站或 Web 应用程序时使用它们。 MDN-Web API JavaScript的组成 ECMAScript - JavaScript 的核心定义了 JavaScript 的语法规范 JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关 BOM - 浏览器对象模型一套 操作浏览器功能 的API 通过BOM可以操作浏览器窗口，不如：弹出框、控制浏览器跳转、获取分辨率 DOM - 文档对象模型一套 操作页面元素 的API DOM可以把HTML看做是 文档树，通过DOM提供的API可以对 树上的节点 进行操作 DOMDOM的概念文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。它是一种与平台和语言无关的应用程序接口（API）它可以动态地访问程序和脚本，更新其内容、结构和www文档的风格（目前，HTML和XML文档是通过说明部分定义的）。文档可以进一步被处理，处理的结果可以加入到当前的页面。DOM是一种基于 树 的API文档，它要求在处理过程中整个文档都表示在存储器中。 DOM又称为文档树模型 文档：一个网页可以称为文档 节点：网页中所有的内容都是节点（标签、属性、文本、注释等） 元素：网页中的标签 属性：标签的属性 DOM经常进行的操作 获取元素 对元素进行操作（设置其属性或调用方法） 动态创建元素 事件（什么时机做和相应的操作） 常用的审查方法（掌握）console.dir()：显示一个对象所有的属性和方法 console.log() ：用于在控制台输出信息。该方法对于开发过程进行测试很有帮助。 获取页面元素为什么要获取页面元素例如：我们向要操作页面上的某部分（显示/隐藏，动画），需要先获取到该部分对应的元素，才进行后续操作 根据id获取元素注意：由于id名具有唯一性，部分浏览器支持直接使用id名访问元素，但并不是标准方式，不推荐使用。 1234567891011121314151617181920212223242526272829303132helloworld黑马pppp var box = document.getElementById('box'); // 输出的是元素对应的标签的内容 // console.log(box); // 打印对象 console.dir(box); var arr = []; console.log(arr); // 如何获取对象的类型 --- 对象是有类型的 // typeof 不能获取对象的具体类型，它获取对象类型始终返回object // console.log(typeof arr); // console.log(typeof box); // 认为构造函数就是对象的类型 console.log(arr.constructor); // HTMLDivElement console.log(box.constructor); // 获取p标签 对应的元素 // HTMLParagraphElement var p = document.getElementById('p'); console.dir(p); 根据标签名获取元素1234111122223333pppp 1234567891011121314 // HTMLCollection 元素的集合 // 伪数组 var divs = document.getElementsByTagName('div'); console.log(divs); for(var i = 0 ; i < divs.length ; i++){ var div = divs[i]; console.dir(div); } var arr=[]; console.log(arr); 运行效果 根据 name 获取元素123456789 1234567891011var frm = document.getElementById(\"frm\");// 获取到的是 form 中的所有的input 标签// var radios = frm.getElementsByTagName('input');// NodeList 类型// 节点的集合var radios = document.getElementsByName('sex');console.log(radios);// IE9 以后才支持的 兼容性问题document.getElementsByClassName(); 根据 选择器 获取元素123456789101112131415161718192021222324 1111 2222 6666 3333 pppp span // 它返回的是集合 // var div = document.getElementsByClassName(); // HTML5 中新增元素的方法 // query 查询 Selector 选择器 // 查找一个元素，如果页面上有多个符合条件的元素，只返回第一个 // var div = document.querySelector('.a'); // console.log(div); // 返回的是 NodeList 的集合，（当前的情况依旧是元素的集合） // var divs = document.querySelectorAll('a'); // console.log(divs); 1234// IE8 以后来支持的var frm = document.querySelector('#frm');var text = frm.querySelectorAll('input[type = text]');console.log(text); 运行效果： 添加事件按钮添加事件： 123456789101112131415161718192021222324252627282930313233 // var obj = { // name: 'zs', // say: function(){ // } // }; // // javascript 的动态特性 可以随时给对象增加成员 // obj.test = function(){ // } // 可以给网页上所有可见的元素注册事件 // 根据 id 获取按钮 元素 var btn = document.getElementById('btn'); // 给按钮注册事件 // on 当什么时候 click 点击 btn.onclick = function () { // 匿名函数 alert('别点我，疼'); }; // 事件的三要素： // 事件源： 触发事件的元素 btn // 事件名称： click // 事件处理函数： 触发事件之后做的事情 取消 a 标签的默认行为 12345678910111213baidu // 获取超链接 var link = document.getElementById('link'); // 注册事件 link.onclick = function () { alert('hello'); // 取消后续内容 （默认行为） 的执行 return false; } 实例 —— 切换图片12345678910111213141516171819202122232425262728293031323334353637切换图片 // 元素的属性 -- 包含了标签对应的属性 // 元素（对象） 封装了标签对应的属性 // 1. 获取超链接 var link = document.getElementById('link'); var flag = 1; // flag = 1 此时显示 a.jpg flag = 2 此时显示 b.jpg // 2. 给超链接注册点击事件 link.onclick = function () { // 3. 切换图片 var img = document.getElementById('img'); console.log(img.id); console.log(img.alt); console.log(img.width); console.log(img.height); if (flag === 1) { flag = 2; img.src = './images/b.jpg'; } else { flag = 1; img.src = './images/a.jpg'; } // console.dir(img); // img.src = './images/b.jpg'; // 4. 取消a的默认行为 return false; } 运行效果","categories":[],"tags":[]},{"title":"","slug":"Bootstrap/实例/页面第五屏","date":"2019-05-14T10:33:34.509Z","updated":"2019-05-10T12:24:28.763Z","comments":true,"path":"2019/05/14/Bootstrap/实例/页面第五屏/","link":"","permalink":"http://yoursite.com/2019/05/14/Bootstrap/实例/页面第五屏/","excerpt":"","text":"第五屏包含的内容有：标题、图片、按钮 以及 下方的文字 123456789101112131415161718192021222324252627282930313233343536373839404142.fivepage-bg{ height: 800px; width: 100%; position: absolute; background-position: center center; background-size: cover;}#fivepage{ background-image:url(\"http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/b21c8701a18b87d608167af6050828381e30fd87.jpg\");}.footertext{ margin-top: 55px; width: 100%; color: #ffffff; font-size: 20px; text-align: center;}.footerbtncenter{ margin-top: 100px; text-align: center;}.queyeicon{ width: 200px;}.queyeicon:hover{ border: 2px solid #d9edf7;}.footertextbtn{ margin-top: 150px; width: 100%; text-align: center;}.footertextbtn-text{ margin-top: 20px; color: #000000;} 123456789101112131415161718192021222324252627282930313233343536 你为什么还在等待，快动手把 你还在在看？再看？再看我就吃了你 只要你有耐心！？！只要你有耐心！？！只要你有耐心！？！只要你有耐心！？！只要你有耐心！？！只要你有耐心！？！只要你有耐心！？！只要你有耐心！？！","categories":[],"tags":[]},{"title":"","slug":"Ajax/PHP基础/04_处理数据","date":"2019-05-14T10:33:34.042Z","updated":"2019-05-13T08:12:43.778Z","comments":true,"path":"2019/05/14/Ajax/PHP基础/04_处理数据/","link":"","permalink":"http://yoursite.com/2019/05/14/Ajax/PHP基础/04_处理数据/","excerpt":"","text":"发送数据 注意： PHP中 method 属性的 get 要用 小写，否则无效 12345678910111213141516 getData.php文件： 123456789101112/* echo '123';*/// 设置中文编码header('content-type:text/html;charset=utf-8');// 接收提交过来的数据// get// php 中为我们提供了一些 超全局变量// 跟 JS 中的 window对象类型 不需要定义直接就可以使用// 是有值的echo $_GET;echo '';print_r($_GET);// post 运行效果 分析信息传递方式 浏览器 用户输入数据 提交数据 渲染图形界面 服务器 接收提交的名字 使用名字去数据库中查询 详细的信息 返回给浏览器 直接返回数据本身 把数据封装一下 流程图 查询功能客户端程序 123456789101112 英雄查询页面 服务器端程序 123456789101112131415161718192021 模拟的假数据中查询 include './data_lol_detail.php'; $hero = $heroArr[$heroName]; // 3. 生成页面返 解析数据 创建好看的 HTML结构 并返回 echo ''.$hero['champion_title'].'-- '.$hero['champion_name'].''; // 图片 echo ''; // 个性签名 echo ''.$hero['champion_info'].''; // 位置 echo ''.$hero['champion_tags'].'';?> 运行效果 综合案例 —— LOL客户端页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 img { width: 242px; /* important 不要滥用 */ height: 200px !important; } .panel-body { background-color: skyblue; } LOL - 能够查看详情页 假数据 include './data_lol_list.php'; for($i=0;$i 服务器端 —— 处理页面 1234567891011121314151617181920212223 模拟的假数据中查询 include './data_lol_detail.php'; $hero = $heroArr[$heroName]; // 3. 生成页面返 解析数据 创建好看的 HTML结构 并返回 echo ''.$hero['champion_title'].'-- '.$hero['champion_name'].''; // 图片 echo ''; // 个性签名 echo ''.$hero['champion_info'].''; // 位置 echo ''.$hero['champion_tags'].'';?>我再考虑一下 运行效果 注意事项 代码放在服务器中 不要使用中文名 变量的定义 $name 使用的时候也要用 前后端分工 前端 写页面 精美的页面布局 后端 把前端写好的页面作为模板 读取数据 生成页面","categories":[],"tags":[]},{"title":"","slug":"Ajax/PHP基础/03_PHP与HTML应用","date":"2019-05-14T10:33:34.035Z","updated":"2019-05-12T08:17:45.884Z","comments":true,"path":"2019/05/14/Ajax/PHP基础/03_PHP与HTML应用/","link":"","permalink":"http://yoursite.com/2019/05/14/Ajax/PHP基础/03_PHP与HTML应用/","excerpt":"","text":"根据数据生成页面生成页面的步骤 生成页面的步骤 商业网站的数据 是保存在 => 服务器的数据库中 这里使用了一个数组作为 => 假数据 用户访问页面时 读取数据 生成对应的html代码 => 让页面好看一些 案例一：水果（简单）12345678910111213141516171819202122232425262728293031 body{ background-color:hotpink; } 'detail/detail1.php?flag=banana','path' => 'img/banana1.jpg','name' => '香蕉'); */// 2.读取数据echo '';for($i=0;$i 运行效果： 案例二：LOL（简单）12345678910111213141516171819202122232425262728293031323334353637 img{ width: 240px; height: 240px; } \"images/1498811286269.jpg\", \"champion_name\"=>\"凯隐\", ), */// 2.解析echo '';for($i=0;$i 运行效果： 案例三：水果（修改）1234567891011121314151617181920212223242526272829303132333435363738蔬菜水果网上超市 水果 蔬菜 干果 版权所有 运行效果： 案例四：LOL（修改） 本实例引入了 Bootstrap 对页面进行了美化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 img{ width: 242px; /* important 不要滥用 */ height: 200px !important; } .panel-body{ background-color:skyblue; } LOL - hero 运行效果：","categories":[],"tags":[]},{"title":"","slug":"Ajax/PHP基础/02_PHP基本语法","date":"2019-05-14T10:33:34.028Z","updated":"2019-05-11T08:01:25.238Z","comments":true,"path":"2019/05/14/Ajax/PHP基础/02_PHP基本语法/","link":"","permalink":"http://yoursite.com/2019/05/14/Ajax/PHP基础/02_PHP基本语法/","excerpt":"","text":"服务器渲染php代码 找到php页面 执行php页面中标签包裹的代码 执行 返回执行完的结果 基本语法12345678910111213 基本数据类型123456789101112131415161718192021222324252627 逻辑语句if 语句1234567// 逻辑语句$male = false;if($male == false){ echo '萌妹子';}else{ echo '糙汉子';} switch 语句12345678910111213141516171819202122232425 循环语句for 循环123456// forfor($i=0;$i'吴京','film'=>'战狼','wife'=>'谢楠');// 获取 内容echo $person['wife'];// 完整输出素组print_r($person);echo '';// 遍历// $key 循环的键// $value 循环的值foreach ($person as $key => $value){ echo $key.'------'.$value.'';} 二维数组12345678910111213141516171819202122232425 span{ color:hotpink; font-size:100px; }'刘德华','film'=>'无间道','friend'=>'曾志伟'), array('name'=>'吴京','film'=>'战狼2','friend'=>'张翰'), array('name'=>'黄渤','film'=>'疯狂的石头','friend'=>'林志玲'), array('name'=>'汪峰','film'=>'春天里','friend'=>'那英') ); //echo $starArr[2]['film']; for($i=0;$i出现在php标签之外的代码 不会执行 原封不动的返回给浏览器戳我有惊喜哦","categories":[],"tags":[]},{"title":"","slug":"Ajax/PHP基础/01_基本概念","date":"2019-05-14T10:33:34.021Z","updated":"2019-05-11T06:34:51.380Z","comments":true,"path":"2019/05/14/Ajax/PHP基础/01_基本概念/","link":"","permalink":"http://yoursite.com/2019/05/14/Ajax/PHP基础/01_基本概念/","excerpt":"","text":"服务器 提供了某种服务的电脑 一般没有显示器 没有输入设备 服务器主要提供的服务 文件服务器 提供文件下载服务 邮件服务器 提供邮件服务 游戏服务器 Web服务器 Web服务器 如何成为web服务器 安装软件即可 apache - 阿帕奇 – 开源、免费的web服务器软件 目前使用人数 最多的 web服务器软件 IIS – 微软的web服务器软件 不开源 —> 开源 tomcat – web服务器软件 Nginx – Web服务器软件 …… 计算机 普通的计算机没有什么功能 聊天 听歌 视频 端口 电脑需要为软件分配资源 不同的端口 默认服务器软件的端口 是80 如果被使用了 可以更换到别的端口，或者把占用的软件关闭即可 本地回环地址 为了测试方便，可以直接使用 http://127.0.0.1 服务器配置 cpu 至强 内存十分强大 硬盘为了读取速率，可能会使用固态 软件架构 B&S架构 浏览器 / 服务器 常规的商业网站都是这种架构 特点：只要有浏览器即可访问 便捷 特殊的 C&S C&S架构 客户端/服务器 特点： 必须安装对应的客户端 能够感受非常酷炫性能的 界面 数据库软件 常见的数据库 MySQL 开源免费 MSSQL 微软、收费 oracle 。。。 数据库管理员（DBA） 数据库提供了很多保护数据安全的功能： 可以备份 删除之后可以恢复 可以分配用户 不是所有用户可以删除数据 后台开发语言 php ”PHP是最好的语言“ 为什么学？ 语法与 JS 相似 亚洲比较多 java 全世界很多 python c++ c# go erlang","categories":[],"tags":[]},{"title":"","slug":"Ajax/04_Ajax","date":"2019-05-14T10:33:33.654Z","updated":"2019-05-14T10:19:32.351Z","comments":true,"path":"2019/05/14/Ajax/04_Ajax/","link":"","permalink":"http://yoursite.com/2019/05/14/Ajax/04_Ajax/","excerpt":"","text":"get 发送异步请求客户端请求页面 12345678910111213141516171819202122232425262728 点击的时候发送请求报文 --不刷新页面 //点击事件 document.querySelector(\"input\").onclick = function(){ // 1.创建对象 var xhr = new XMLHttpRequest(); // 2.设置请求行（get请求数据可写在url后面） xhr.open('get','getData.php?name=rose&skill=swim') // 3.设置请求头（get请求可以省略，post不发送数据也可以省略） // 3.5注册回调函数 xhr.onload = function(){ //获取数据 console.log(xhr.responseText); // 修改页面的 DOM 元素 document.querySelector('h3').innerHTML = xhr.responseText; } // 4.请求主体发送（get请求为空，或者写null post请求数据 // 写在这里，如果没有数据，直接为空或者写null） xhr.send(null); } 服务器响应页面 1234567 运行效果 总结 浏览器 ajax请求 异步对象 —— XMLHTTPRequest 请求行 —— .open 请求头 —— .setRequestHeader 回调函数（onload） —— 异步对象.responseText 请求主体 发送 —— .send 发送请求报文 服务器 执行 – 逻辑代码 返回响应报文 – 到浏览器 的回调函数 异步对象.responseText","categories":[],"tags":[]},{"title":"","slug":"Ajax/03_请求响应报文_基本概念","date":"2019-05-14T10:33:33.630Z","updated":"2019-05-14T05:10:39.321Z","comments":true,"path":"2019/05/14/Ajax/03_请求响应报文_基本概念/","link":"","permalink":"http://yoursite.com/2019/05/14/Ajax/03_请求响应报文_基本概念/","excerpt":"","text":"请求/响应报文_基本概念HTTP协议使用 请求报文 和 响应报文 种方式 进行数据的交互 称之为 http协议 请求报文 浏览器中获取 html页面、css、js、请求后台页面，发送的都是请求报文 响应报文 服务器返回的是响应报文 使用 抓包工具（fiddler） 浏览器 请求报文 请求行 请求方式 请求地址 请求头 浏览器信息 接收的语言格式 等一些 浏览器的信息 以及想 发送给服务器的信息 请求主题 发送给服务器的数据 内容 服务器 响应报文 状态行 请求是否成功 请求的状态 200 成功 404 页面不存在 304 被缓存了 响应头 服务器的一些信息 服务器想要告诉浏览器的一些信息 响应主体 正常用户看到的内容 请求报文是什么？ 包括请求行、请求头、请求主体 主要有 发送的方法、浏览器信息、发送的数据 响应报文是什么？ 包括状态行、响应头、响应主体 主要是 请求是否成功、服务器的 信息、浏览器中直接可以看到的内容 实例客户端请求页面 1234567891011121314151617181920 // 绑定点击事件 document.querySelector('input').onclick = function(){ // 创建 对象 异步对象 var xhr = new XMLHttpRequest(); // 请求行 xhr.open('get','xxx.php'); // 请求头 setRequestHeader // 参数1 键名 // 参数2 值 xhr.setRequestHeader('heima','goodgoodstudy day day up'); // 请求主体 发送 xhr.send(null); } 服务器响应页面 123 运行结果 回调函数 & 获取返回的数据客户端请求页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445 Document // 绑定点击事件 document.querySelector('input').onclick = function(){ // 创建 对象 异步对象 var xhr = new XMLHttpRequest(); // 请求行 // get 请求是拼接在 url 中 // xxx.php?key=value&key2=value2 xhr.open('get','xxx.php?name=jack&skill=painting'); // 注册回调函数 // 请求响应回来之后触发 xhr.onload = function(){ console.log('请求响应回来啦'); console.log(xhr.responseText); alert(xhr.responseText); } // 请求头 setRequestHeader // 参数1 键名 // 参数2 值 // 目前这个好像没有任何作用 是否可以省略呢 // get请求 可以省略设置请求头的操作 // xhr.setRequestHeader('heima','goodgoodstudy day day up'); // 请求主体 发送 xhr.send(null); } 服务器响应页面 12345678 运行效果","categories":[],"tags":[]},{"title":"","slug":"Ajax/02_PHP上传文件","date":"2019-05-14T10:33:33.614Z","updated":"2019-05-13T11:31:09.881Z","comments":true,"path":"2019/05/14/Ajax/02_PHP上传文件/","link":"","permalink":"http://yoursite.com/2019/05/14/Ajax/02_PHP上传文件/","excerpt":"","text":"上传文件客户端页面： 1234567891011121314151617上传文件 服务器页面： 1234567891011121314151617181920212223242526272829303132 Array ( [name] => 59783bb197ad5.jpg // 上传的文件名 [type] => image/jpeg // 类型 [tmp_name] => C:\\Users\\YaoZhao\\AppData\\Local\\Temp\\php425E.tmp // 路径 tmp 路径： 临时 [error] => 0 //错误编码 [size] => 639030 // 大小 ) ) */ // php 代码执行完毕之后 临时文件就被销毁了 // 如果想看到临时文件 可以 让 php代码 执行的的稍微 慢一些 。。。 休息一会 // 目的只是为了 看到临时文件 // sleep(5); // move_uploaded_file(file,newloc) // 参数1 移动的文件 // 参数2 移动到那里去 move_uploaded_file($_FILES['icon']['tmp_name'] , './files/'.$_FILES['icon']['name']);?> 运行效果： 注意： 如果要 严谨 一点 还需要 添加一些判断 判断文件类型 判断文件是否存在 判断文件的大小 。。。","categories":[],"tags":[]},{"title":"","slug":"Ajax/01_PHP进阶","date":"2019-05-14T10:33:33.610Z","updated":"2019-05-13T11:12:54.667Z","comments":true,"path":"2019/05/14/Ajax/01_PHP进阶/","link":"","permalink":"http://yoursite.com/2019/05/14/Ajax/01_PHP进阶/","excerpt":"","text":"PHP 拆分123456789101112131415161718192021222324252627282930313233 \"images/1498811286269.jpg\", \"champion_name\"=>\"凯隐\", ), array( \"champion_icon\"=> \"images/1493291013439.jpg\", \"champion_name\"=>\"洛\", ), array( \"champion_icon\"=> \"images/1447226977586.png\", \"champion_name\"=>\"俄洛伊\", )); // // 循环生成 HTML // for($i = 0; $i < count($heroArr); $i++){ // echo ''; // echo ''; // echo '' // }?> ---- 感觉自己萌萌哒O ∩_∩ O 萌你奶奶个腿 get 提交数据（扩展）客户端页面 12345678910111213141516171819202122232425262728293031323334 Document 提交数据 服务器处理页面 123456789101112131415161718192021222324 Document 没想到呀，你竟然喜欢吃 --- 而且用 - 种方法来吃 post提交数据客户端页面 1234567891011121314151617181920212223post提交数据 服务器处理页面 1234567891011 post 提交 练习 需求 用户默认访问的是 登陆页面 登陆改为 index 首页换个名字 登陆页面 输入完毕数据之后 点击提交 跳转到了 首页 修改登陆页面的一些设置 action method name submit 跳转到了首页之后 在首页的右上角没有注册跟登陆 取而代之的是 ​ xxx 怎么才来 ​ 删除默认的 注册 跟登陆 ​ 获取通过 post提交的数据 输出在 对应的位置即可 运行效果 总结 需求 用户默认访问的是 登陆页面 登陆改为 index 首页换个名字 登陆页面 输入完毕数据之后 点击提交 跳转到了 首页 修改登陆页面的一些设置 action method name submit 跳转到了首页之后 在首页的右上角没有注册跟登陆 取而代之的是 xxx 怎么才来 删除默认的 注册 跟登陆 获取通过 post提交的数据 输出在 对应的位置即可 前后台合作 前端程序员 写好网站的 静态页面 –> 搞定 用户限制对于界面的要求越来越高 主要写页面的各自各样的交互效果 后端程序员 根据网站的业务逻辑 业务逻辑 -> 去登录页 没有注册 去注册页 密码输入三次失败 冻结账号 登陆成功之后去首页 获取最新的 信息展示给用户 get还是post 如果是 像爱旅行 这种 跳转的方式 提交数据 一般是后端程序员来实现 后端程序员 根据 需求 选择用哪种方式提交 页面不跳转 提交数据 ajax 发送请求给服务器 也分 get 跟post 工作时 因为后端代码 是后台程序员来编写","categories":[],"tags":[]},{"title":"","slug":"英语/英语语法/02_名词语法","date":"2019-05-14T10:33:33.573Z","updated":"2019-05-13T13:44:29.974Z","comments":true,"path":"2019/05/14/英语/英语语法/02_名词语法/","link":"","permalink":"http://yoursite.com/2019/05/14/英语/英语语法/02_名词语法/","excerpt":"","text":"名词语法1.名词语法架构 名词的分类 专有名词 & 普通名词 可数名词 & 不可数名词 单数 - 复数 规则 +s 、+es 、 o 结尾 、y 结尾 、 f / fe 结尾 不规则 名词所有格 主谓一致 单复数意义不同的名词 名词分类专有名词 专有名词是个别的人、地、物、团体、机构等的 专用名称 专有名词中 实词 的 第一个字母要大写 Beijing，Tom，the People’s Republic of China 专有名词如 含有普通名词 的短句，必须用定冠词 the。 the Great Wall 长城 姓氏名采用复数形式，表 姓氏一家人 the Greens 格林一家人 实词：具有 实际意义 的单词 普通名词 普通名词：是许多人或事物的共有名称 pupil、family、man、foot 可数名词和不可数名词 可数名词是可以用 数词 进行 计数 的名词 box、child、orange 不可数名词是 不可以数词 进行 计数 的名词 water、news、oil、pupulation、information","categories":[],"tags":[]},{"title":"","slug":"英语/英语语法/01_语法基础概念","date":"2019-05-14T10:33:33.560Z","updated":"2019-05-12T13:29:35.827Z","comments":true,"path":"2019/05/14/英语/英语语法/01_语法基础概念/","link":"","permalink":"http://yoursite.com/2019/05/14/英语/英语语法/01_语法基础概念/","excerpt":"","text":"课程介绍 第一部分： 基础概念 词类、句子成分、构词法 第二部分：名词、代词、数词、冠词 名词、代词、数词、冠词 第三部分：升级篇 形容词、副词 第四部分：终极篇 动词、连词、其他 词类 —— 10种词性句子成分 —— 9种句子成分构词法 —— 3个原则 词名词（重要）表示 人、 事物、地点或抽象概念 的名称 boy，morning，bag，ball，class，orange 代词（重要）用来 代替 名词 who，she，you，it 形容词（重要）表 人或事物 的 性质或特征 good，right，white，orange 数词（重要）表 数目或顺序 one，two，three，first，second，third，fourth 动词（重要）表 动作 或 状态 am，is，are，have，see 丰富文章的 谓语动词，将会提高文章语言的质量 动词体现的 语法 是最多，并且是最难的 动词将会改变整个句子的句意 副词（重要） 修饰动词、形容词或副词 说明时间、地点、程度等 now、very、here、often、quietly、slowly 冠词（重要）用在名词前，帮助说明名词 a、an、the 介词表示它后面的名词或代词 与其他句子成分的关系 in、on、from、above、behind 连词（重要）用来 连接 词、短语或句子 and、but、before 感叹词表示喜、怒、哀、乐等表情 oh、well、hi、hello 小结 梳理 语法体系 的依据 正确 造句 的依据 句子成分1.主语 是句子所要说的人或物，回答是 “谁” 或者 “什么” 通常用 名词 或 代词 担任 eg： I’m Miss Green. 我是格林小姐 2.谓语 说明 主语 的 动作或状态，回答 “做（什么）” 由 动词 & 动词短语 担任 eg：Jack cleans the room every day. 杰克每天打扫房间 3.表语 在系动词后，说明主语的身份或特征，回答是 “什么” 或者 “怎么样” 由 名词、代词或形容词 担任 系动词： be 动词 eg: am、is、are 感官动词 与五官相关，eg： 听起来、闻起来。。。 My name is PingPing 我的名字叫萍萍 4.宾语 表 及物动词 的对象或结果 及物动词：后面+宾语 不及物动词：后面没有宾语 ；即没有宾语 就是 没有被动 的 由 名词或代词 担任 He can spell the word. 他能拼这个词 5.双宾 有些及物动词带有两个宾语，一个指物，一个指人 指物的叫直接宾语，指人的叫间接宾语 间接宾语一般放在直接宾语的前面 He wrote me a letter. 他给我写了一封信。 主谓 + 间接宾语 + 直接宾语 注意：可把介词 to 或 for 加在 间接宾语 前 构成 短语 放在 直接宾语 后面，来 强调 间接宾语 He wrote a letter to me. 他给我写了一封信。 6.定语 修饰 名词或代词 Shanghai is a big city. 上海是个大城市。 7.状语 修饰 动词、形容词、副词 He works hard. 他工作努力。 补充：正确区分定语 & 状语1.定语 形容词 帅气的 姚钊 介词短语 in the … 非谓语动词 动词 ing 动词 ed 动词 to do 从句 2.状语 副词 介词短语 非谓语动词 动词 ing 动词 ed 动词 to do 从句 区别：有没有修饰名词 定语 有 状语 无 8.宾语补足语 用来说明宾语怎么样或干什么 用 形容词 或 动词 充当 They usually keep their classroom clean. he often helps me do my lessons. The teacher wanted me to learn French all by myself. 双宾 与 宾补 都是在一个动词后有两个东西 双宾：如果这两个东西能改成被动语态的主语 宾补：动词之后的两个东西，只有一个能改成被动语态的主语 9.同位语跟在名词、代词后面，进一步说明他的情况 where is your class mate Tom? 你的同学汤姆在哪里？ 小结 区分 标语 、宾语 当动词不再是普通的动词，是一个 be动词 或者 感观动词 ，它的名字就叫表 宾补 、双宾 双宾和宾补的区别就是看动词之后的两个成分是否可以做被动语态的主语； 如果都行，就是双宾； 否至就是 宾补 定语 、 状语 看有没有被修饰的名词，如果有就是 定，否至就是 状 构词法合成法spaceship、headache、basketball、playground 等 派生法派生名词 动词 + er / or 动词 + ing 动词 +(t)ion 形容词 + ness 其他 inventor、learner、swiming、congratulation、kindness 派生形容词 名词+ y 名词 + ful 动词 + ing/ed friendly dangerous 国名、snowy、sunny、hopeful、beautiful、interesting、daily、nervous、delicious 派生副词 形容词 + ly 其他 slowly、angrily、 full –> fully 、good –> well、possible –> possibly 转换法 形容词 –> 动词 dry 干燥的 –> dry 弄干、 clean 干净的 –> clean 打扫，弄干净等 动词 –> 名词 look、walk、rest、work、study、swim、go、talk 等 名词 –> 动词 hand 手 –> 传递， face 脸 –> 面对 形容词 –> 副词 early –> early、 fast –> fast 副词 –> 连词 when 什么时候 –> 当……时候 介词 –> 副词 in 到……里 –> 在里面；在家； on 在……上 –> 进行，，继续 小结 合成法 派生法 派生形容词 派生副词 派生名词 转换法 adj. -v. v. -n. n. -v. adj. - adv. adj. - conj. prep. - adv. 注意： 后缀改变 词性 前缀改变 词义","categories":[],"tags":[]},{"title":"","slug":"Python/相关/运算符","date":"2019-05-14T10:33:33.353Z","updated":"2019-05-12T05:13:33.197Z","comments":true,"path":"2019/05/14/Python/相关/运算符/","link":"","permalink":"http://yoursite.com/2019/05/14/Python/相关/运算符/","excerpt":"","text":"运算符目标 比较（关系）运算符 逻辑运算符 运算符的优先级 数学符号表链接：数学符号表 比较（关系）运算符 运算符 描述 == 检查两个操作数的值是否 相等，如果是，则条件成立，返回 True != 检查两个操作符的值是否 不相等，如果是，则条件成立，返回 True > 检查左操作数的值是否 大于 右操作符的值，如果是，则条件成立，返回 True = 检查左操作数的值是否 大于或等于 右操作数的值，如果是，则条件成立，返回 True","categories":[],"tags":[]},{"title":"","slug":"Python/10_函数","date":"2019-05-14T10:33:32.702Z","updated":"2019-05-14T03:00:11.439Z","comments":true,"path":"2019/05/14/Python/10_函数/","link":"","permalink":"http://yoursite.com/2019/05/14/Python/10_函数/","excerpt":"","text":"函数基础目标 函数的快速体验 函数的基本使用 函数的参数 函数的返回值 函数的嵌套使用 在模块中定义函数 函数的快速体验快速体验 所谓函数，就是把 具有独立功能的代码块 组织为一个小模块，在需要的时候 调用 函数的使用包含两个步骤： 定义函数 —— 封装 独立的功能 调用函数 —— 享受 封装 的成功 函数的作用，在开发程序时，使用函数可以提高编写的效率以及代码的重用 演练步骤 新建 04_函数 项目 复制之前完成的 乘法表 文件 修改文件，增加函数定义 multiple_table(): 1234567891011121314151617181920def multiple_table(): # 1. 打印 9 行小星星 row = 1 while row","categories":[],"tags":[]},{"title":"","slug":"Python/09_循环","date":"2019-05-14T10:33:32.694Z","updated":"2019-05-14T02:21:03.376Z","comments":true,"path":"2019/05/14/Python/09_循环/","link":"","permalink":"http://yoursite.com/2019/05/14/Python/09_循环/","excerpt":"","text":"循环目标 程序的三大流程 while 循环基本使用 break 和 continue while 循环嵌套 程序的三大流程 在程序开发中，一共有三种流程方式： 顺序 —— 从上向下、顺序执行代码 分支 —— 根据条件判断，决定执行代码的 分支 循环 —— 让 特定代码 重复 执行 while 循环的基本使用 循环的作用就是让 指定的代码 重复的执行 while 循环最常用的应用场景就是 让执行的代码 按照 指定的次数 重复 执行 需求 —— 打印 5 遍 Hello Python 思考 —— 如果要求打印 100 遍怎么办 while 语句基本语法123456789初始条件设置 —— 通常是重复执行的 计数器while 条件(判断 计数器 是否达到 目标次数): 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...( 省略 )... 处理条件(\"计数器 + 1\") 注意： while 语句及缩进部分是一个 完整的代码块 第一个 while 循环需求 打印 5 遍 Hello Python 123456789101112131415# 打印 5 遍 Hello Python# 1. 定义一个整数变量，记录循环次数i = 1# 2. 开始循环while i 希望在循环内执行的代码 print(\"Hello Python\") # 2> 处理计数器 i = i + 1# 3. 冠词一下，循环结束后，计数器 i 的数值是多少print(\"循环结束后，i = %d\" % i) 注意：循环结束后，之前定义的计数器条件的数值是依旧存在的 死循环 由于程序员的原因，忘记 在循环内部 修改循环的判断条件，导致循环持续执行，程序无法终止！ 123456789101112131415# 打印 5 遍 Hello Python# 1. 定义一个整数变量，记录循环次数i = 1# 2. 开始循环while i 希望在循环内执行的代码 print(\"Hello Python\") # 2> 处理计数器 # i = i + 1# 3. 冠词一下，循环结束后，计数器 i 的数值是多少print(\"循环结束后，i = %d\" % i) 赋值运算符 在 Python 中，使用 = 可以给变量赋值 在算术运算时，为了简化代码的编写，Python 还提供了一系列的 与 算术运算符 对应的 赋值运算符 注意：赋值运算符中间不能使用空格 | 运算符 | 描述 | 实例 || —— | ————————— | ———————————— || = | 简单的赋值运算符 | c= a + b 将 a + b 的运算结果赋值为 c || += | 加法赋值运算符 | c += a 等效于 c = c + a || -= | 减法赋值运算符 | c -= a 等效于 c = c - a || = | 乘法赋值运算符 | c = a 等效于 c = c * a || /= | 除法赋值运算符 | c /= a 等效于 c = c / a || //= | 取整除赋值运算符 | c //= a 等效于 c = c // a || %= | 取 模（余数）赋值运算符 | c %= a 等效于 c = c % a || = | 幂赋值运算符 | `c = a 等效于 c = c ** a` | Python 中的计数方法常见的计数方法有两种，可以分别称为： 自然计数法（从 1 开始）—— 更符合人类的习惯 程序计数法（从 0 开始）—— 几乎所有的程序语言都选择从0开始计数 因此，大家在编写程序时，应该尽量养成习惯：除非需求的特殊要求，否则 循环 的计数都从 0 开始 12345678910111213141516# 打印 5 遍 Hello Python# 1. 定义一个整数变量，记录循环次数i = 0# 2. 开始循环while i < 3: # 1> 希望在循环内执行的代码 print(\"Hello Python\") # 2> 处理计数器 # i = i + 1 i += 1# 3. 冠词一下，循环结束后，计数器 i 的数值是多少print(\"循环结束后，i = %d\" % i) 循环计算 在程序开发中，通常会遇到 利用循环 重复计算 的需求 遇到这种需求，可以： 在 while 上方定义一个变量，用于 存放最终计算结果 在循环体内部，每次循环都用 最新的计算结果，更新 之前定义的变量 需求 计算 0 ~ 100 之间所有数字的累计求和结果 123456789101112131415161718# 计算 0 ~ 100 之间所有数字的累计求和结果# 0. 定义最终结果的变量result = 0# 1. 定义一个整数的变量记录循环的次数i = 0# 2. 开始循环while i 定义一个记录最终结果的变量result = 0i = 0while i 当 i 这个变量是偶数时，才进行累加操作 result += i # result += i i += 1print(\"0 ~ 100 之间的偶数累加结果 = %d \" % result) break 和 continue break 和 continue 是专门在循环中使用的关键字 break 某一条件满足时，退出循环，不再执行后续重复的代码 continue 某一条件满足时，不执行后续重复的代码 break 和 continue 只针对 当前所在循环 有效 break1234567891011121314i = 0while i < 10: # break 某一条件满足时，退出循环，不再执行后续重复的代码 # i == 3 if i == 3: break print(i) i += 1print(\"over\") continue1234567891011121314151617i = 0while i < 10: # continue 某一条件满足时，不执行后续重复的代码 # i == 3 if i == 3: # 注意在循环中，如果使用 continue 这个关键字 # 在使用关键字之前，需要确认循环的计数是否修改 # 否则可能会导致死循环 i += 1 continue print(i) i += 1 while 循环嵌套循环嵌套 while 嵌套就是：while 里面还有 while 123456789101112131415while 条件 1: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...（省略）... while 条件2: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...（省略）... 处理条件 2 处理条件 1 演练 —— 九九乘法表第一步：循环打印小星星需求 在控制台连续输出五行 * ，每一行星号的数量依次递增 12345*************** 12345678910111213141516# 在控制台连续输出五行 * ，每一行星号的数量依次递增# *# **# ***# ****# *****# 1. 定义一个计数器变量，从数字 1 开始，循环会比较方便row = 1# 2. 开始循环while row 完成 5 行内容的简单输出 2> 分析每行内部的 * 应该如何处理 12345678910111213141516171819202122232425262728293031323334353637383940414243# **需求**## - 在控制台连续输出五行 `*` ，每一行星号的数量依次递增# *# **# ***# ****# *****# **开发步骤**## - 1> 完成 5 行内容的简单输出# - 2> 分析每行内部的 `*` 应该如何处理row = 1while row","categories":[],"tags":[]},{"title":"","slug":"Python/08_判断","date":"2019-05-14T10:33:32.681Z","updated":"2019-05-13T06:02:39.692Z","comments":true,"path":"2019/05/14/Python/08_判断/","link":"","permalink":"http://yoursite.com/2019/05/14/Python/08_判断/","excerpt":"","text":"判断（if）语句目标 开发中的应用场景 if 语句体验 if 语句进阶 综合应用 开发中的应用场景生活中的判断几乎是无所不在的，我们每天都在做各种各样的选择，如果这样？如果那样？…… 程序中的判断 123456789101112131415if 今天发工资: 先还信用卡的钱 if 有剩余: 又可以happy了，😄哈哈~ else: 噢，no。。。还得等30天 else: 盼着工资 判断的定义 如果 条件满足，才能做某件事情 如果 条件不满足，就做另外一件事情，或者什么也不做 正是因为有了判断，才使得程序世界丰富多彩，充满变化！ 判断语句 又被称为 ”分支语句“，正式因为有了判断，才让程序有了很多的分支 if语句体验if 判断语句基本用法在 Python 中，if 语句 就是用来进行判断的，格式如下： 123if 要判断的条件: 条件成立时，要做的事情 ...... 注意：代码的缩进为一个 tab 键，或者 4 个空格 —— 建议使用空格 在 Python 开发中，Tab 和 空格 不要混用 我们可以把整个 if 语句看成一个完整的代码块 判断语句演练 —— 判断年龄需求 定义一个整数变量记录年龄 判断是否满18岁数（>=） 如果满 18 岁，允许进网吧嗨皮 123456789# 1. 定义一个整数变量记录年龄age = 23# 2. 判断是否满了18岁if age >= 18: # 3. 如果满了18岁，可以进网吧嗨皮 print(\"你已经成年，欢迎进网吧嗨皮\")print(\"看看什么时候会执行\") 注意： if 语句以及缩进部分是一个 完整的代码块 else 处理条件不满足的情况思考 在使用 if 判断时，只能做到满足条件时要做的事情。那如果需要在 不满足条件的时候，做某些事情，该如何做呢？ 答案 else，格式如下： 123456if 要判断的条件: 条件成立时，要做的事情 ......else: 条件不成立时，要做的事情 ...... 注意： if 和 else 语句以及各自的缩进部分共同是一个 完整的代码块 判断语句演练 —— 判断年龄改进需求 输入用户年龄 批判的是否满 18 岁 （>=） 如果满 18 岁，允许进网吧嗨皮 如果未满 18 岁，提示回家写作业 12345678910# 1. 输入用户年龄age = int(input(\"请输入年龄：\"))# 2. 批判的是否满 18 岁 （>=）if age >= 18: # 3. 如果满 18 岁，允许进网吧嗨皮 print(\"你已经成年，欢迎来网吧嗨皮\")else: # 4. 如果未满 18 岁，提示回家写作业 print(\"你还没有成年，请回家写作业吧\") 逻辑运算 在程序开发中，通常 在判断条件时，会需要同时判断多个条件 只有多个条件都满足，才能执行后续代码，这个时候需要使用到 逻辑运算符 逻辑运算符 可以把 多个条件 按照 逻辑 进行 连接，变成 更复杂的条件 Python 中的 逻辑运算符 包括：与 and / 或 or / 非 not 三种 and1条件1 and 条件2 与 / 并且 两个条件同时满足，返回 True 只有一个不满足，就返回 False | 条件1 | 条件2 | 结果 || —— | —— | —— || 成立 | 成立 | 成立 || 成立 | 不成立 | 不成立 || 不成立 | 成立 | 不成立 || 不成立 | 不成立 | 不成立 | or1条件1 or 条件2 或 /或者 两个条件只有一个满足，返回 True 两个条件都不满足，返回 False | 条件1 | 条件2 | 结果 || —— | —— | —— || 成立 | 成立 | 成立 || 成立 | 不成立 | 成立 || 不成立 | 成立 | 成立 || 不成立 | 不成立 | 不成立 | not1not 条件 非 / 不是 条件 结果 成立 不成立 不成立 成立 逻辑运算演练 练习1：定义一个整数变量 age，编写代码判断年龄是否正确 要求人的年龄在 0 - 120 之间 12345678910111213# 练习1：定义一个整数变量 `age`，编写代码判断年龄是否正确age = 120# - 要求人的年龄在 0 - 120 之间\"\"\"10000age >= 0 or age = 0 and age","categories":[],"tags":[]},{"title":"","slug":"Python/07_变量","date":"2019-05-14T10:33:32.663Z","updated":"2019-05-12T05:11:33.272Z","comments":true,"path":"2019/05/14/Python/07_变量/","link":"","permalink":"http://yoursite.com/2019/05/14/Python/07_变量/","excerpt":"","text":"程序就是用来处理数据的，而变量就是用来存储数据的 目标 变量的定义 变量的类型 变量的命名 变量定义 在 Python 中，每个变量 在使用前都必须赋值，变量 赋值以后 该变量 才会被创建 等号 （=）用来给变量赋值 = 左边是一个变量名 = 右边是存储在变量中的值 1变量名 = 值 变量定义之后，后续就可以直接使用了 变量演练1 – iPython123456789101112131415# 定义 qq_number 的变量用来保存 qq 号码qq_number = \"1234567\"# 输出 qq_number 中保存的内容qq_number# 定义 qq_password 的变量用来保存 qq 密码qq_password = \"123\"# 输出 qq_password 中保存的内容qq_password 使用交互式方式，如果要查看变量被人，直接输入变量名即可，不需要使用 print 函数 变量演练2 – PyCharm12345678910111213141516# 1. 定义一个变量记录 QQ 号码qq_number = \"1234567\"# 2. 定义一个变量记录 QQ 密码qq_password = \"123\"# 注意：在使用解释器执行 python 程序的时候，不能直接使用变量名# 在控制台输出变量的信息qq_number# 如果希望通过解释器的方式，输出变量的内容，需要使用 print 函数print(qq_number)print(qq_password) 使用解释器执行，如果要输出变量的内容，必须要使用 print 函数 变量演练3 – 超市买苹果 可以用 其他变量的计算结果 来定义变量 变量定义之后，后续就可以直接使用了 需求 苹果的价格是 8.5元/斤 买了 7.5斤 苹果 计算付款金额 12345678910# 1.定义苹果的单价price = 8.5# 2.挑选苹果weight = 7.5# 3.计算付款金额money = price * weightprint(money) 思考题 如果 只要买苹果，就返 5块钱 请重新计算购买金额 123456789101112# 1.定义苹果的单价price = 8.5# 2.挑选苹果weight = 7.5# 3.计算付款金额money = price * weight# 只要买苹果，就返回 5 块钱money = money - 5print(money) 提问 上述代码中，一共定义有几个变量？ 三个：price / weight / money money = money - 5 是在定义新的变量还是在使用变量？ 直接使用之前已经定义的变量 变量名 只有在 第一次出现 才是 定义变量 变量名 再次出现，不是定义变量，而是直接使用之前定义过的变量 在程序开发中，可以修改之前定义变量中保存的值吗？ 可以 变量中存储的值，就是可以 变 的 变量类型 在内存中创建一个变量，会包括： 变量的名称 变量保存的数据 变量存储数据的类型 变量的地址（标示） 变量类型的演练 – 个人信息需求 定义变量保存小明的个人信息 姓名：小明 年龄：18岁 性别：是男生 身高：1.75米 体重：75.0公斤 利用 单步调试 确定变量中保存数据的类型 1234567891011121314151617181920212223\"\"\"- 姓名：小明- 年龄：18岁- 性别：是男生- 身高：1.75米- 体重：75.0公斤\"\"\"# 在 Python 中，定义变量时是不需要指定变量的类型的# 在运行的时候，Python 解释器，会根据赋值语句（等号右侧的数据）# 自动推断出变量中保存数据的准确类型# str 表示是一个字符串类型name = \"小明\"# int 表示是一个整数类型age = 18# bool 表示是一个布尔类型，真 True 或者假 Falsegender = False # 不是# float 表示是一个小数类型，浮点数height = 1.75weight = 75print(name) 提问 在演练中，一共有几种数据类型？ 4种 str – 字符串 bool – 布尔（真假） int – 整数 float – 浮点数（小数） 在 Python 中定义变量时需要制定类型吗？ 不需要 Python 可以根据 = 等号右侧的值，自动 推导 出变量中存储数据的类型 变量的类型 在 Python 中定义变量是 不需要指定类型 （在其他很多高级语言中都需要） 数据类型可以分为 数字型 和 非数字型 数字型 整形（int） 浮点型（float） 布尔型（bool） 真 True 非0数 - - 非零即真 假 False 0 复数型（complex） 主要用于科学计算。例如： 平面场问题、波动问题、电感电容等问题 非数字型 字符串 列表 元组 字典 提示：在 Python 2.x 中，整数 根据保存数值的长度还分为： int（整数） long（长整数） 使用 type 函数可以查看一个变量的类型 1type(name) 不同类型变量之间的计算数字型变量 之间可以直接计算 在 Python 中，两个数字型变量是可以直接进行 算数运算的 如果变量是 bool 型，在计算时 True 对应的数字是 1 False 对应的数字是 0 演练步骤 定义整数 i = 10 定义浮点数 f = 10.5 定义布尔型 b = True 字符串变量 之间使用 + 拼接字符串 在 Python 中，字符串之间可以使用 + 拼接生成的字符串 12345first_name = \"三\"last_name = \"张\"first_name + last_name 字符串变量 可以和 整数 使用 * 重复拼接相同的字符串1\"-\" * 50 数字型变量 和 字符串之间不能进行其他计算12345first_name = \"zhang\"x = 1x + first_name 变量的输入与输出 所谓 输入，就是 用 代码 获取 用户通过 键盘 输入的信息 例如：去银行取钱，在 ATM 上输入密码 在 Python 中，如果要获取用户在 键盘 上的输入信息，需要使用到 input 函数 关于函数 一个 提前准备好的功能（别人或者自己写的代码），可以 直接使用，而 不关心内部的细节 目前已经学习过的函数 函数 说明 print(x) 将 x 输出到控制台 type(x) 查看 x 的变量类型 input函数实现键盘输入 在 Python 中可以使用 input 函数从键盘等待用户的输入 用户输入的 任何内容 Python 都认为是一个 字符串 语法如下： 1字符串变量 = input(\"提示信息：\") 类型转换函数 函数 说明 int(x) 将 x 转换为一个整数 float(x) 将 x 转换到一个浮点数 变量输入演练 – 超市买苹果增强版需求： 收银员输入 苹果的价格，单位：元 / 斤 收银员输入 用户购买苹果的重量，单位：斤 计算并且 输出 付款金额 演练方式1 1234567891011121314151617181920# 1. 输入苹果的单价price_str = input(\"苹果的单价：\")# 2. 输入苹果的重量weight_str = input(\"苹果的重量：\")# 3. 计算支付的总金额# 注意： 两个字符串变量之间是不能直接用乘法的# money = price_str * weight_str# 1> 将价格转换成小数price = float(price_str)# 2> 将重量转换成小数weight = float(weight_str)# 3> 用两个小数来计算最终的金额money = price * weightprint(money) 提问 演练中，针对 价格 定义了几个变量？ 两个变量 变量1：字符串类型的变量， 记录了客户从控制台输入的苹果价格的字符串 变量2：浮点型的变量，记录把用户输入的价格字符串转换为小数数值，以方便最后计算金额 思考 —— 如果开发中，需要用户通过控制台输入 很多个 数字，针对每一个数字都要定义两个变量，方便吗？ 演练方式 2 —— 买苹果改进版 定义 一个 浮点变量 接收用户输入的同时，就是用 float 函数进行转换 1price = float(input(\"请输入价格：\")); 改进后的好处： 节约空间，只需为一个变量分配空间 起名字方便，不需要为中间变量起名字 改进后的 ”缺点“ 初学者需要知道，两个函数能够嵌套使用，稍微有一些难度 提示：如果不是一个数字，程序执行时会出错 变量的格式化输出 苹果单价 9.00 元/斤，购买了 5.00 斤，需要支付 45.00 元 在 Python 中可以使用 print 函数将信息输出到控制台 如果希望输出文字信息的同时，一起输出 数据，就需要使用到 格式化操作符 % 被称为 格式化操作符，专门用于处理字符串中的格式 包含 % 的字符串，被称为 格式化字符串 % 和不同的 字符 连用，不同类型的数据 需要使用 不同格式化的字符 格式化字符 含义 %s 字符串 %d 有符号十进制整数，%06d 表示输出的整数显示位数，不足的地方使用 0 补全 %f 浮点数，%.02f 表示小数点后只显示两位 %% 输出 % 语法格式如下 12print(\"格式化字符串\" % 变量1)print(\"格式化字符串\" % （变量1,变量2...）) 格式化输出演练 —— 基本练习需求 定义字符串变量 name ，输出 我的名字叫 小明，请多多关照！ 定义整数变量 student_no。输出 我的学号是 000001 定义小数 price、weigh、money，输出 苹果单价 9.00 元/斤，购买了 5.00斤，需要支付 45.00 元` 定义一个小数 scale ，输出 数据比例是 100% 123456789101112131415161718# 定义字符串变量 `name` ，输出 我的名字叫 小明，请多多关照！name = \"小明\"print(\"我的名字叫 %s，请多多关照！\" % name)# 定义整数变量 student_no。输出 我的学号是 000001student_no = 1print(\"我的学号是 %06d\" % student_no)# 定义小数 `price`、`weigh`、`money`，# 输出 苹果单价 9.00 元/斤，购买了 5.00斤，需要支付 45.00 元price = 8.5weight = 7.5money = price * weightprint(\"输出 苹果单价 %.2f 元/斤，购买了 %.2f 斤，需要支付 %.2f 元\" % (price, weight, money))# 定义一个小数 scale ，输出 数据比例是 100%scale = 0.25print(\"数据比例是 %.2f%%\" % (scale * 100)) 变量命名目标 标识符和关键字 变量的命名规则 标识符 标识符就是程序员定义的 变量名、函数名 名字 需要有 见名知义 的效果，如下图： 标识符可以有 字母、下划线 和 数字 组成 不能以数字开头 不能与关键字重名 关键字 关键字 就是在 Python 内部已经使用的标识符 关键字 具有特殊的功能和含义 开发组 不允许定义和关键字相同名字的标示符 通过以下命令可以查看 Python 中的关键字 12import keywordprint(keyword,kwlist) import 关键字 可以导入一个 ”工具包“ 在 Python 中不同的工具包，提供有不同的工具 变量的命名规则 命名规则 可以被视为一种 惯例，并无觉得与强制 目的是为了 增强代码的识别和可读性 注意 Python 中的 标识符 是 区分大小写的 在定义变量时，为了保证代码格式，= 的左右应该各保留一个空格 在 Python 中，如果 变量名 需要由 二个 或 多个单词 组成时，可以按照以下方式命名 每个单词都是用小写字母 单词与单词之间使用 _下划线 连接 例如：first_name、last_name 、qq_number 、qq_password 驼峰命名法 当 变量名 是由二个或多个单词组成时，还可以利用驼峰命名法来命名 小驼峰式命名法 第一个单词以小写字母开始，后续单词的首字母大写 例如： firstName 、lastName 大驼峰式命名法 每一个单词的首字母都采用大写字母 例如： FirstName 、LastName 、CamelCase","categories":[],"tags":[]},{"title":"","slug":"Python/06_程序执行原理（科普）","date":"2019-05-14T10:33:32.644Z","updated":"2019-05-12T05:10:22.302Z","comments":true,"path":"2019/05/14/Python/06_程序执行原理（科普）/","link":"","permalink":"http://yoursite.com/2019/05/14/Python/06_程序执行原理（科普）/","excerpt":"","text":"目标 计算机中的 三大件 程序执行的原理 程序的作用 计算机中的三大件计算机中包含较多的硬件，但是一个程序要运行，由 三个 核心的硬件，分别是： 1.CPU 中央处理器，是一块超大规模的集成电路 负责 处理数据/计算 2.内存 临时 存储数据（断电之后，数据会消失） 速度快 空间小（单位价格高） 3.硬盘 永久 存储数据 速度慢 空间大（单位价格低） 思考题 计算机中哪一个硬件是负责执行程序的？ CPU 内存 的速度还是 硬盘的速度快？ 内存 我们的程序是安装在内存中的，还是安装在硬盘中的？ 硬盘 我买了一个内存条，由 500G 的空间！！！这句话对吗？ 错误。 内存条空间相对比较小，eg：4G、8G、32G 再大暂时没有了 计算机关机之后，内存中的数据都会消失，这句话对吗？ 正确。内存只是临时存储数据 程序执行原理 程序 运行之前，程序是 保存在硬盘 中的 当要 运行一个程序时 操作系统会首先让 CPU 把程序复制到 内存 中 CPU 执行 内存 中的 程序代码 程序要执行，首先要被加载到内存 Python 程序执行原理 操作系统会首先让 CPU 把 Python 解释器 的程序复制到 内存 中 Python 解释器 根据语法规则，从上到下 让 CPU 翻译 Python 程序中的代码 CPU 复制执行翻译完成的代码 Python 的解释器有多大？ 执行以下终端命令可以查看 Python 解释器的大小 123456# 1.确认解释器所在位置Which python# 2.查看 python 文件大小（只是一个软链接）ls -lh /usr/bin/python# 3.查看具体文件大小ls -lh /usr/bin/python2.7/ 提示：建立 软链接 的目的，是为了方便使用者不用记住使用的解释器是 哪一个具体版本 程序的作用 程序 就是 用来处理数据 的！ 新闻软件 提供的 新闻内容、评论……. 是数据 电商软件 提供的 商品信息、配送信息…… 是数据 运动类软件 提供的 运动数据…… 是数据 地图类软件 提供的 地图信息、定位信息、车辆信息……. 是数据 即时通讯类软件 提供的 聊天信息、好友消息…… 是数据 …… 思考 QQ 程序启动过程 QQ 在运行之前，是保存在 硬盘 中的 运行之后， QQ 程序就会被加载到 内存 中了 思考 QQ 程序的 登陆 过程 读取用户输入的 QQ号码 读取用户输入的 QQ密码 将 QQ号码 和 QQ密码 发送给腾讯的服务器，等待服务器确认用户信息 思考1 在 QQ 这个程序将 QQ号码 和 QQ密码 发送给服务器之前，是否需要先存储以下 QQ号码 和 密码？ 答案： 肯定需要！ – 否则 QQ 这个程序就不知道把什么内容发送给服务器了！ 思考2 QQ 这个程序把 QQ号码 和 QQ密码 保存在哪里？ 答案： 保存在 内存 中，因为 QQ 程序自己就在内存中 思考3 QQ 这个程序是怎么保存用户的 QQ号码 和 QQ密码 的？ 答案： 在内存中为 QQ号码 和 QQ密码 各自分配一块空间 在 QQ程序结束之前，这两块空间是由 QQ程序 负责管理的，其他任何程序都不允许使用 在 QQ 自己使用完成之前，这两块空间始终都只负责保存 QQ号码 和 QQ密码 使用一个 别名 标记 QQ号码 和 QQ密码 在内存中的位置 在程序内部，为 QQ号码 和 QQ密码 在内存中分配的空间叫做 变量 程序就是用来处理数据的，而变量就是用来存储数据的","categories":[],"tags":[]},{"title":"","slug":"Python/05算术运算符","date":"2019-05-14T10:33:32.631Z","updated":"2019-05-11T00:57:07.718Z","comments":true,"path":"2019/05/14/Python/05算术运算符/","link":"","permalink":"http://yoursite.com/2019/05/14/Python/05算术运算符/","excerpt":"","text":"算术运算符计算机、顾名思义就是负责进行 数学计算 并且 存储计算结果 的电子设备 目标 算术运算符的基本使用 算术运算符 算术运算符是 运算符的一种 是完成基本的算术运算使用的符号，用来处理四则运算 运算符 描述 实例 + 加 10 + 20 = 30 - 减 10 - 20 = -10 * 乘 10 * 20 = 200 / 除 10 / 20 = 0.5 // 取整除 返回除法的整数部分（商） 9//2 输出结果 4 % 取余数 返回除法的余数 9 % 2 = 1 ** 幂 又称次方、乘方，2 ** 3 = 8 Python 中 * 运算符还可以用于字符串，计算结果就是字符串 重复指定次数 的结果 12\"-\" * 50# 结果： '--------------------------------------------------' 算术运算符的优先级 和数学中的运算符的优先级一致，在 Python 中进行数学计算时，同样是： 先乘除后加减 同级运算符 从左至右 计算 可以使用 () 调整计算的优先级 以下表格的算术优先级由高到最低顺序排列 运算符 描述 ** 幂（最高优先级） * / % // 乘、除、取余数、取整除 + - 加法、减法 例如： 2 + 3 * 5 = 17 ( 2 + 3 ) * 5 = 25 2 * 3 + 5 = 11 2 * ( 3 + 5 ) = 16","categories":[],"tags":[]},{"title":"","slug":"Python/04_注释","date":"2019-05-14T10:33:32.617Z","updated":"2019-05-12T05:02:16.164Z","comments":true,"path":"2019/05/14/Python/04_注释/","link":"","permalink":"http://yoursite.com/2019/05/14/Python/04_注释/","excerpt":"","text":"目标 注释的作用 单行注释（行注释） 多行注释（块注释） 注释的作用 使用自己熟悉的语言，在程序中对某些代码进行标注说明，增强程序的可读性 单行注释（行注释） 以 # 开头, # 右边的所有东西都被当成说明文字，而不是正真要执行的程序，只起到补助说明作用 示例代码如下： 12# 这是一个单行注释print(\"hello python\") 为了保证代码的可读性， # 后面建议先添加一个空格，然后再编写相应的说明文字 在代码后面增加的单行注释 在程序开发时，同样可以使用 # 在代码的后面（旁边）增加说明性的文字 但是，需要注意的是，为了保证代码的可读性，注释和代码之间 至少要有 两个空格 示例代码如下： 1print(\"hello python\") # 输出 \"hello python\" 多行注释（块注释） 如果希望编写的 注释信息很多，一行无法显示，就可以使用多行注释 要在 Python 程序中使用多行注释，可以用一对 连续的 三个 引号（单引号和双引号都可以） 示例代码如下： 123456\"\"\"这是一个多行注释在多行注释之间，可以写很多很多的内容......\"\"\"print(\"hello python\") 什么时候需要使用注释 注释不是越多越好，对于一目了然的代码，不需要添加注释 对于 复杂的操作，应该在操作开始前写上若干行注释 对于 不是一目了然的代码，应在其行尾添加注释（为了提高可读性，注释应该至少离开的代码2个空格） 绝不要描述代码，假设阅读代码的人比你更懂 Python，他只是不知道你的代码要做什么 在一个正规的开发团队，通常会有 代码审核 的惯例，就是一个团队中彼此阅读对方的代码 关于代码的规范 python 官方提供由一系列 PEP（Python Enhancement Proposals）文档 其中第八篇文档专门针对 Python 的代码格式 给出了建议，也就是俗称的 PEP 8 文档地址： https://www.python.org/dev/pens/pep-0008/ 谷歌有对应的中文文档：http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/ 任何语言的程序员，编写出符合规范的代码，是开始程序生涯的第一步","categories":[],"tags":[]},{"title":"","slug":"Python/03_多文件项目演练","date":"2019-05-14T10:33:32.598Z","updated":"2019-05-12T11:38:20.679Z","comments":true,"path":"2019/05/14/Python/03_多文件项目演练/","link":"","permalink":"http://yoursite.com/2019/05/14/Python/03_多文件项目演练/","excerpt":"","text":"开发 项目 就是开发一个 专门解决一个复杂业务功能的软件 通常每一个项目 就具有一个 独立专属的目录，用于保存 所有和项目有关的文件 一个项目通常会包含 很多源文件 目标 在项目中添加多个文件，并且设置文件的执行 多文件项目演练 在 01_python 基础 项目中新建一个hm_02_第二个Python 程序.py 在 hm_02_第二个Python 程序.py 文件中添加一句 print('hello') 点击右键执行 hm_02_第二个Python 程序.py 提示 在 PyCharm 中，要让哪一个 Python 程序能够执行，必须首先通过 鼠标右键的方式执行 一下 对于初学者而言，在一个项目中设置多个程序可以执行，是非常方便的，可以方便对不同知识点的练习和测试 对于商业项目而言，通常在一个项目中，只有一个 可以直接执行的Python源程序","categories":[],"tags":[]},{"title":"","slug":"node.js/Node.js介绍","date":"2019-05-14T10:33:32.546Z","updated":"2019-05-10T05:14:31.981Z","comments":true,"path":"2019/05/14/node.js/Node.js介绍/","link":"","permalink":"http://yoursite.com/2019/05/14/node.js/Node.js介绍/","excerpt":"","text":"(toc) 为什么学习 Node.js 企业需求 具有服务端开发经验更好 front-end 前端 back-end 后端 全栈开发工程师 全干 基本的完整开发能力 服务端 前端 运维部署 案例：多人社区 学习 Node.js 的目的就是帮助大家打开服务端这个黑盒子 只用懂了解服务端才能更好的配合服务端开发人员进行协同开发 Node.js 是什么 打开服务端的黑盒子，那么 Node 就能帮你打开 下面列举一些同样也能够打开服务端黑盒子的语言: Java PHP Python Ruby .Net（dot Net） 。。。 Node.js Node.js 采用 Javascript 进行编程； 使用它来学习服务端，不用为了学习后台而重新学习一门新的语言 一个 Javascript，everywhere Node官网官方网站：nodejs.org 所有技术相关一般以 .org、io 结尾 org（organization）：组织机构 一般的技术方面网站都喜欢称为 .org，应为他们是一个团体、技术社区组织 io（input、output）：输入输出 官方简介 Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js 不是一门语言 Node.js 不是库、不是框架 Node.js 是一个 JavaScript 运行时 环境 简单点来讲 就是 Node.js 可以解析和执行 JavaScript 代码 以前只有浏览器可以解析执行 JavaScript代码 也就是说现在的 JavaScript 可以 完全脱离浏览器 来运行，一切都归功于 Node.js 浏览器的 JavaScript由三部分组成 EcmaScript 只有基本的语法 if var function Object Array BOM DOM Node.js 中的 JavaScript 没有 BOM、DOM 只有EcmaScript 在 Node 这个 JavaScript 执行环境中为 JavaScript 提供了一些服务器级别的操作 API ，例如： 文件读写 网络服务的构建 网络通信 http 服务器 等处理。。。 构建与 Chrome 的 V8 引擎 之上 代码只是具有特点格式的 字符串 而已 引擎可以认识它，引擎可以帮你去 解析和执行 Goole Chrome 的 V8 引擎 是目前公认的解析执行 JavaScript 代码最快的 Node.js 的作者把 Google Chrome 中的 V8引擎移植出来，开发了一个独立的 JavaScript 运行时环境 Node.js uses an event-driven,non-blocklng I/O model that makes it lightweight and efficient. event-driven 事件驱动 non-blocklng I/O model 非阻塞IO模型（异步） lightweight and efficient 轻量和高效 随着课程慢慢的学习你会明白什么是事件驱动、非阻塞IO模型 Node.js package ecosystem,npm,is the largest ecosystem of open source libaries in the world npm 是世界上最大的开源库生态系统 绝大多数 JavaScript 相关的包都存放在了 npm 上，这种做的目的是为了让开发人员更方便的去下载使用 eg：npm install jquery","categories":[],"tags":[]},{"title":"页面第四屏","slug":"Bootstrap/页面第四屏","date":"2019-05-09T10:06:25.000Z","updated":"2019-05-10T12:01:16.583Z","comments":true,"path":"2019/05/09/Bootstrap/页面第四屏/","link":"","permalink":"http://yoursite.com/2019/05/09/Bootstrap/页面第四屏/","excerpt":"","text":"第四屏包含 标签、 透明的滑动区域 以及 背景图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.fourpage{ height: 700px; background-color: green; margin-top: 800px;}.coursexingging-text{ color: #ffffff; margin-top: 100px; width: 100%; text-align: center;}.coursexingging-text p{ margin-top: 25px; font-size: 20px;}.fourpage .container .carousel{ margin-top: 100px;}.carousel-control .left{ background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, .5) 0%, rgba(0, 0, 0, .0001) 100%); background-image: -o-linear-gradient(left, rgba(0, 0, 0, .5) 0%, rgba(0, 0, 0, .0001) 100%); background-image: -webkit-gradient(linear, left top, right top, from(rgba(0, 0, 0, .5)), to(rgba(0, 0, 0, .0001))); background-image: linear-gradient(to right, rgba(0, 0, 0, .5) 0%, rgba(0, 0, 0, .0001) 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#80000000', endColorstr='#00000000', GradientType=1); background-repeat: repeat-x;}.carousel-control.right{ background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0,0) 100%); background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0,0) 100%); background-image: -webkit-gradient(linear, left top, right top, from(rgba(0, 0, 0,0)), to(rgba(0, 0, 0,0))); background-image: linear-gradient(to right, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0,0) 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#80000000', endColorstr='#00000000', GradientType=1); background-repeat: repeat-x;}control .glyphicon-chevron-left { left: -20%; }control .glyphicon-chevron-right { left: -20%; } 1234567891011121314151617181920212223242526272829303132 要学习，那就马上滚出去 怎样才能让自己不学习，想不出就给我滚？","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"页面第四屏","slug":"Bootstrap/实例/页面第四屏","date":"2019-05-09T10:06:25.000Z","updated":"2019-05-09T11:36:16.526Z","comments":true,"path":"2019/05/09/Bootstrap/实例/页面第四屏/","link":"","permalink":"http://yoursite.com/2019/05/09/Bootstrap/实例/页面第四屏/","excerpt":"","text":"第四屏包含 标签、 透明的滑动区域 以及 背景图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.fourpage{ height: 700px; background-color: green; margin-top: 800px;}.coursexingging-text{ color: #ffffff; margin-top: 100px; width: 100%; text-align: center;}.coursexingging-text p{ margin-top: 25px; font-size: 20px;}.fourpage .container .carousel{ margin-top: 100px;}.carousel-control .left{ background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, .5) 0%, rgba(0, 0, 0, .0001) 100%); background-image: -o-linear-gradient(left, rgba(0, 0, 0, .5) 0%, rgba(0, 0, 0, .0001) 100%); background-image: -webkit-gradient(linear, left top, right top, from(rgba(0, 0, 0, .5)), to(rgba(0, 0, 0, .0001))); background-image: linear-gradient(to right, rgba(0, 0, 0, .5) 0%, rgba(0, 0, 0, .0001) 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#80000000', endColorstr='#00000000', GradientType=1); background-repeat: repeat-x;}.carousel-control.right{ background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0,0) 100%); background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0,0) 100%); background-image: -webkit-gradient(linear, left top, right top, from(rgba(0, 0, 0,0)), to(rgba(0, 0, 0,0))); background-image: linear-gradient(to right, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0,0) 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#80000000', endColorstr='#00000000', GradientType=1); background-repeat: repeat-x;}control .glyphicon-chevron-left { left: -20%; }control .glyphicon-chevron-right { left: -20%; } 1234567891011121314151617181920212223242526272829303132 要学习，那就马上滚出去 怎样才能让自己不学习，想不出就给我滚？","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"页面第三屏","slug":"Bootstrap/实例/页面第三屏","date":"2019-05-09T09:26:16.000Z","updated":"2019-05-09T11:42:48.401Z","comments":true,"path":"2019/05/09/Bootstrap/实例/页面第三屏/","link":"","permalink":"http://yoursite.com/2019/05/09/Bootstrap/实例/页面第三屏/","excerpt":"","text":"第三屏比较简单，背景图片、 文字 以及 下方的按钮 123456789101112131415161718192021222324252627282930313233343536.threepage{ position: absolute; width: 100%; height: 800px;}.threepage-bg{ position: absolute; height: 100%; width: 100%; background-position: center center; background-repeat: no-repeat; background-size: cover;}#threepagebg{ background-image:url(\"http://img.pconline.com.cn/images/upload/upc/tx/itbbs/1108/23/c3/8745157_1314096215781_1024x1024it.jpg\");}.treepagecontent{ width: 100%; margin: 0 auto; text-align: center;}.treepagetext{ margin-top: 100px;}.treepagetext p{ margin-top: 20px; color: #000000; font-size: 20px; line-height: 32px; }.threepagebtncontent{ margin-top:450px; font-size: 25px;} 1234567891011 为什么我这么帅 我就是帅我就是帅我就是帅我就是帅我就是帅我就是帅我就是帅我就是帅我就是帅我就是帅我就是帅我就是帅我就是帅我就是帅 不要学习，滚出去","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"PyCharm的初始设置","slug":"Python/相关/PyCharm的初始设置","date":"2019-05-09T06:54:40.000Z","updated":"2019-05-12T05:08:43.375Z","comments":true,"path":"2019/05/09/Python/相关/PyCharm的初始设置/","link":"","permalink":"http://yoursite.com/2019/05/09/Python/相关/PyCharm的初始设置/","excerpt":"","text":"目标 恢复 PyCharm 的初始设置 第一次启动 PyCharm 新建一个 Python 项目 设置 PyCharm 的字体显示 PyCharm 的升级以及其他 恢复 PyCharm 的促使设置PyCharm 的 配置信息 是保存在 用户家目录下 的 .PyCharmxxxx.x 目录下的， xxxx.x 表示当前使用的 PyCharm 的版本好 【 . 】 表示隐藏文件 如果要恢复 PyCharm 的初始设置，可以按照以下步骤执行： 关闭正在运行的 PyCharm 在终端中执行以下终端命令，删除 Pycharm 的配置信息目录 rm -r ~/.PyCharmxxxx.x 重新启动 PyCharm 第一次启动PyCharm 导入配置信息 选择许可协议 配置初始界面 导入配置信息 在第一次启动 PyCharm 时，会首先提升用户是否导入 之前的配置信息 如果是第一次使用，直接点击 OK 按钮 选择许可协议 PyCharm 是一个付费软件，购买费用为 199$ /年 或者 19.90$ /月 不过 PyCharm 提供了对 学生和教师免费使用的版本 下载地址是： https://www.jetbrains.com/pycharm-edu/download/#section-linux 商业版本会提示输入注册信息，或者选择免费评估 PyCharm 的配置初始界面 在初始配置界面，可以通过 Editor colors and fonts 选择 编辑器的配色方案 欢迎界面 所有基础配置工作结束之后，就可以看到 PyCharm 的 欢迎界面 了，通过 欢迎界面 就可以开始开发 Python 项目了 新建/打开一个 Python 项目项目简介 开发 项目 就是开发一个 专门解决一个复杂业务功能的软件 通常每 一个项目 就具有一个 独立专属的目录，用于保存 所有和项目相关的文件 一个项目通常会包含 很多源文件 打开 Python 项目 直接点击 Open 按钮，然后浏览到之前保存的 Python 文件的目录，即可以打开项目 打开之后，会在目录下新建一个 .idea 的目录，用于保存 显目相关的信息，例如：解释器版本、 项目包含的文件 等等 第一次打开项目，需要耐心等待 PyCharm 对项目 进行初始设置 设置项目使用的解释器版本 打开的目录如果不使 PyCharm 建立的项目目录，有的时候 使用的解释器版本是 Python 2.x 的，需要 单独设置解释器的版本 通过 File/Settings… 可以打开设置窗口，入下图所示： 新建项目命名规则 以后 项目名 前面都以 数字编号，随着知识点递增，编号递减 例如：01_Python基础、 02_分支、 03_循环… 每个项目下的 文件名 都以 hm_xx_知识点 方式来命名 其中 xx 是演练文件的序号 注意 命名文件名时建议只使用 小写字母、数字 和 下划线 文件名不能以数字开始 通过 欢迎界面 或者菜单 File/New Project 可以新建项目 演练步骤新建 01_Python基础 项目，使用 Python 3.x 解释器文件->new project 手动新建一个目录 修改 python 我们需要的 不同版本的解释器 在项目下新建 hm_01_hello.py Python 文件右击项目 -> new -> Python File 编写 print(“Hello,Python”) 代码第一次运行程序，需要右键新建的 .py 文件，选择 run 之后 右上角的 启动按钮 就会变绿，即可以点击该按钮启动 程序 设置PyCharm的字体显示 Pycharm的升级以及其他 PyCharm 提供了对 学生和教师 提供了免费使用的版本 教育部下载地址：https://www.jetbrains.com/pycharm-edu/download/#section=linux 专业版下载地址：https://www.jetbrains.com/pycharm/download/#section=linux 安装和启动步骤 执行以下终端命令，解压缩下载后的安装包 1tar -zxvf pycharm-professional-2017.1.3.tar.gz 将压缩后的目录移动到 /opt 目录下，可以 方便其他用户使用 /opt 目录 用户存放给主机额外安装的软件 1sudo mv pycharm-2017.1.3/ /opt/ 切换工作目录 1cd /opt/pycharm-2017.1.3/bin 启动 PyCharm 1./pycharm.sh 注意：安装完成后第一次打开 PyCharm时，右上角的执行按钮还是灰色的，我们可以看到右下角的进度条： 这个进度条在初始设置工作结束之前，是不能启动任何 python 程序的 第一次显示的进度条：这是在第一次启动 PyCharm 的时候，需要做一些初始设置工作， 第二次显示的进度条：更新当前 IDE环境 中的 python 环境，速度比第一次快 设置专业版启动图标 在 专业版中，选择菜单 Tools/Create Desktop Entry 可以设置任务栏启动图标 注意：设置图标时，要勾选 Create the entry for all users 卸载之前版本的PyCharm程序安装 程序文件目录 将安装包解压缩，并且移动到 /opt目录下 所有的相关文件都保存在解压缩的目录中 配置文件目录 启动 PyCharm后，会在用户家目录下建立一个 .PyCharmxxx 的隐藏目录 保存 PyCharm 相关的配置信息 快捷方式文件 /usr/share/applications/jetbrains-pycharm.desktop 在Ubuntu中，应用程序启动的快捷方式通常都保存在 /usr/share/applications/目录 程序卸载 删除 程序目录 1sudo rm -r /opt/pycharm-2016.3.1 删除家目录的 配置目录 1rm -r ~/.PyCharm2016.3/ 删除快捷方式 如果不再使用PyCharm还需要将 /usr/share/applications下的 jetbrains-pycharm.desktop删掉 教育版安装演练1234561. 解压缩下最后的安装包 tar -zxvf pycharm-edu-3.5.1.tar.gz2. 将解压缩后的目录移动到 /opt 目录下，就可以方便其他用户使用 sudo mv pycharm-edu-3.5.1/ /opt/3. 启动 PyCharm /opt/pycharm-edu-3.5.1/bin/pycharm.sh 操作家目录之外的目录，都要使用 sudo (root) 身份来执行 设置启动图标 编辑快捷方式文件 1sudo gedit /usr/share/applications/jetbrains-pycharm.desktop 按照以下内容修改文件内容，需要注意指定正确的 pycharm 目录 打开之后将 图标 、可执行文件 的文件目录 替换 成教育版的即可","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"从零开始的Python学习","slug":"从零开始的Python学习","permalink":"http://yoursite.com/tags/从零开始的Python学习/"}]},{"title":"页面第二屏","slug":"Bootstrap/实例/页面第二屏","date":"2019-05-08T09:28:06.000Z","updated":"2019-05-08T10:32:01.356Z","comments":true,"path":"2019/05/08/Bootstrap/实例/页面第二屏/","link":"","permalink":"http://yoursite.com/2019/05/08/Bootstrap/实例/页面第二屏/","excerpt":"","text":"CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081.twopage{ padding: 2px 0 0 2px; height: auto; background-color: snow; position: relative;}.twopage-text{ width: 100%; text-align: center;}.twopage-text-h1{ margin-left: 120px; letter-spacing: 2px; margin-top: 80px; margin-bottom: 0; padding: 20px 0 0 0;}.twopage-text-h1 img{ width: 120px; margin-top: -20px;}.twopage .row{ margin-left: 0px; margin-right: 0px;}.twopage-course{ float: left; background: #ffffff; padding: 0 2px 2px 0; position: relative; overflow: hidden;}.twopage-course >a{ width: 100%; height: 100%; float: left; text-align: center; position: relative;}.classicon h3{ margin-top: 120px; color: #d1e973;}.classicon h3{ color: #fff5e1}.classicon{ width: 100%; height: 100%; position: absolute; left: 0; top: 0; color: #fff; opacity: 0;}.classicon:hover{ background: #1eb450; opacity: 0.9; transition: opacity 0.5s; -webkit-transition: opacity 0.5s;}.twopagebtn{ width: 100%; margin: 0 % auto; text-align: center;}.twopagebtn .btn-lg{ font-size: 25px;}#twopage-easy{ margin: 50px 0; margin-bottom: 100px;} HTML12345678910111213141516171819202122232425262728293031323334353637383940414243 选择你的第一节课程进行学习 不要学习哦 学了也会忘记的 不要学习哦 学了也会忘记的 不要学习哦 学了也会忘记的 如果你想学习，那就滚出去","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"页面第一屏","slug":"Bootstrap/实例/页面第一屏","date":"2019-05-08T08:52:07.000Z","updated":"2019-05-08T10:32:49.049Z","comments":true,"path":"2019/05/08/Bootstrap/实例/页面第一屏/","link":"","permalink":"http://yoursite.com/2019/05/08/Bootstrap/实例/页面第一屏/","excerpt":"","text":"注意： 引入 Css样式表 顺序,由于我们会覆盖掉 Bootstrap 原本的一些效果，所以引入的时候先引入 Bootstrap，再引入我们自己的样式表，这样才能进行覆盖 CSS12345678910111213141516171819202122232425262728293031h1,h3,p,a,button{ font-family:\"微软雅黑\";}.onepage{ height: 750px;}.onepage-bg{ height: 800px; width: 100%; position: absolute; background-position: center center; background-size: cover;}#onepagebg{ background-image: url(\"http://uploads.5068.com/allimg/171116/1-1G116115I2.jpg\")}.headh1content{ margin-top: 150px; line-height: 75px;}.title-text{ margin-left: 50px}.headfontsize h1{ font-size: 50pt; color: #ffffff;}.headfontsize p{ color: #ffffff;} HTML1234567891011121314151617181920 姚的博客 在这里你可以 为所欲为 只要你有耐心，相信程序对你而言，小菜一碟，你一定是可以失败的你一定是可以失败的你一定是可以失败的你一定是可以失败的 立即放弃，不要学习","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"下拉菜单（二）","slug":"Bootstrap/下拉菜单（二）","date":"2019-05-08T08:36:11.000Z","updated":"2019-05-09T10:11:47.320Z","comments":true,"path":"2019/05/08/Bootstrap/下拉菜单（二）/","link":"","permalink":"http://yoursite.com/2019/05/08/Bootstrap/下拉菜单（二）/","excerpt":"","text":"Bootstrap 官网 介绍了 实例、 用法、 方法 和 事件 事件处理： 1234567891011121314151617 下拉菜单 1 2 3 4 这里面每一项我们可以自己去设置，都非常方便，其他的属性可以去官方文档进行查阅，文档 中对于方法的使用以及事件的处理的描述写的非常清楚","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"第一个Python程序","slug":"Python/02_第一个Python程序","date":"2019-05-08T06:01:11.000Z","updated":"2019-05-10T10:59:59.874Z","comments":true,"path":"2019/05/08/Python/02_第一个Python程序/","link":"","permalink":"http://yoursite.com/2019/05/08/Python/02_第一个Python程序/","excerpt":"","text":"目标 第一个 HelloPython 程序 Python 2.x 与 3.x 版本简介 执行 Python 程序的三种方式 解释器 ———— python/python3 交互式 ———— ipython 集成开发环境 ———— Pycharm 第一个 HelloPython 程序Python 源程序的基本概念 Python 源程序就是一个 特殊格式的文本文件，可以 使用任意文本编辑软件 做 Python 的开发 Python 程序的 文件扩展名 通常是 .py 演练步骤 再桌面下，新建 认识Python 目录 再 认识Python 目录下新建 01-HelloPython.py 文件 使用 gedit 编辑 01-HelloPython.py 并且输入以下内容 12print(\"hello python\")print(\"hello world\") 在终端中输入以下命令执行 01-HelloPython.py 1python 01-HelloPython.py print 是 python 中 我们接触到的第一个 函数print 函数的作用，可以把 “” 内部的内容，输出到屏幕上 演练扩展关于错误 编写的程序不能正常运行，或者执行的结果不是我们期望的 俗称 BUG，是程序员在开发时非常常见的，初学者常见的错误原因包括： 手误 对已学习过的知识理解还存在不足 对语言还由需要学习和提升的内容 在学习语言时，不仅要学会语言的语法，而且还要学会如何认识错误和解决错误的方法 每一个程序员都是在不断地修改错误中成长的 常见错误 手误 将多条 print 写在一行 每行代码负责完成一个动作 缩进错误 Python 是一个格式非常严谨的程序设计语言 目前而言，大家记住每行代码前面都不要增加空格 python 2.x 默认不支持中文 目前市场上由两个 Python 版本并存着，分别是 Python 2.x 和 Python 3.x Python 2.x默认不支持中文，具体原因，等到介绍字符编码时讲解 Python 2.x的解释器名称是 python Python 3.x的解释器名称是 python3 ASCII 字符只包含 256 个字符，不支持中文 Python 2.x 与 3.x 版本简介目前市场上由两个 Python 版本并存着，分别是 Python 2.x 和 Python 3.x 新的 Python 程序 建议使用 Python 3.0 的语法 Python 2.x 是 过去的版本 解释器的名称是 python Python 3.x 是 现在和未来 主流的版本 解释器的名称是 python3 相对于 Python 的早期版本，这是一个 较大的升级 为了不带如过多累赘， Python 3.0 在设计的时候 没有考虑向下兼容 许多早期 Python 版本 设计的程序都无法再 Python 3.0 上正常运行 Python 3.0 发布与 2008年 到目前为止，Python 3.0 的稳定版本已经由很多年了 Python 3.3 发布与 2012 Python 3.4 发布与 2014 Python 3.5 发布与 2015 Python 3.6 发布与 2016 为了照顾现有的程序，官方提供了一个 过渡版本 ———— Python 2.6 基本使用了 Python 2.x 的语法和库 同时考虑了向 Python 3.0 的迁移，允许使用 部分 Python 3.0 的语法和函数 2010年终推出的 Python 2.7 被确定为 最后一个 Python 2.x 版本 提升：如果开发时，无法立即使用 Python（还有极少的第三方库不支持 3.0 的语法），建议 先使用 Python 3.0 版本进行开发 然后使用 Python 2.6、 Python 2.7 来执行，并且做一些兼容性的处理 执行Python程序的三种方式Python的解释器 使用 python 2.x 解释器 python xxx.py 使用 python 3.x 解释器 python3 xxx.py 其他解释器（知道）Python的解释器 如今又多个语言的实现，包括： CPython – 官方版本的 C语言实现 Jython – 可以运行在Java平台 IronPython – 可以运行在 .NET 和 Mono 平台 PyPy – Python 实现的，支持 JIT 即时编译 交互式运行Python程序 直接再终端中运行解释器，而不需要输入要执行的文件名 再 Python 的 Shell 中直接输入 Python代码，会立即看到程序的执行结果 交互式运行 Python 的优缺点优点 适合于 学习/验证 Python 小的语法或者小的局部代码 缺点或者局部代码 代码 不能保存 不适合运行太大的程序 退出 官方的解释器 直接输入 exit() exit() 使用 热键 退出 再 python 解释器中，按热键 ctrl + d 可以退出解释器 IPython IPython 中的 “ i “ 代表 交互 interactive 特点 IPython 是一个 python 的 交互式shell，比默认的 python shell 好用很多 支持 自动补全 自动缩进 支持 bash shell 命令 内置了许多很有用的功能和函数 IPython 是基于 BSD 开源的 版本 Python 2.x 使用的解释器是 ipython Python 3.x 使用的解释器是 ipython3 要退出解释器可以有以下两种方式 直接退出 exit 使用热键退出 在 IPython 解释器中，按热键 ctrl + d, IPython 会询问是否退出解释器 Python的IDE – Pycharm集成开发环境（IDE）集成开发环境（IDE，Integrated Development Environment）– 集成了开发软件所需要的所有工具，一般包括以下工具： 图形用户界面 代码编辑器（支持 代码补全/自动缩进） 编译器/解释器 调试器（断点/单步执行） … Pycharm介绍 PyCharm 是 Python 的一款非常优秀的集成开发环境 PyCharm 除了具有一般的 IDE 所必备功能外，还可以在 Windows、 Linux、 macOS 下使用 PyCharm 适合开发大型项目 一个项目通常会包含 很多源文件 每个 源文件 的代码行数都是有限的，通常在几百行之内 每个 源文件 各司其职，共同完成复杂的业务功能 PyCharm 快速体验 文件导航区域 能够 浏览/定位/打开 项目文件 文件编辑区域 能够 编辑 当前打开的文件 控制台区域 能够： 输出程序执行内容 跟踪调试代码的执行 右上角的 工具栏 能够 执行（SHIFT + F10）/调试（SHIFT + F9）代码","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"从零开始的Python学习","slug":"从零开始的Python学习","permalink":"http://yoursite.com/tags/从零开始的Python学习/"}]},{"title":"认识Python","slug":"Python/01_认识Python","date":"2019-05-07T04:20:36.000Z","updated":"2019-05-08T04:47:56.370Z","comments":true,"path":"2019/05/07/Python/01_认识Python/","link":"","permalink":"http://yoursite.com/2019/05/07/Python/01_认识Python/","excerpt":"","text":"人生苦短，我用 Python –Life is short,you need Python 目标 Python 的起源 为什么要用 Python Python 的特点 Python 的优缺点 Python 的起源 Python 的创始人 为 吉多·范罗范姆（Guido van Rossum） 1989年的圣诞节期间，吉多·范罗范姆为了在阿姆斯特丹打发时间，决心开发一个新的 解释程序，作为 ABC语言的一种继承（感觉下什么叫牛人） ABC是由吉多参加设计的一种教学语言，就吉多本人看来，ABC这种语言非常优美和强大，是专门为 非专业程序员设计 的。但是 ABC语言并没有成功，究其原因，吉多 认为是 非开放 造成的。吉多决心再 Python 中避免这一错误，并获得了非常好的效果 之所以选择 Python（蟒蛇） 作为程序的名字，是因为他是BBC电视剧–蒙提·派森的飞行马戏团（Monty Python’s Flying Circus）的爱好者 1991年，第一个 Python 解释器 诞生，它是用 C语言 实现的，并能够调用 C语言的库文件 解释器（科普）计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。将其他语言翻译成机器语言的工具，被称为解释器 编译器翻译的方式有两种： 编译：统一编译一次性执行 解释：翻译一行执行一行 两种方式之间的区别在于翻译时间点不同。当编译器以解释方式运行的时候，也称之为解释器 执行速度的区别 编译型语言执行速度快，因为最终生成的可执行文件中，就是硬件执行的机器语言，执行这个语言的时候，没有任何翻译的动作， CPU 可以很快的执行，不需要任何的介入。 解释性 语言不同，在执行的时候，必须翻译一行执行一行，因此解释性语言的执行速度就相对慢一些，这就是编译器语言与解释性语言在速度上的对比 跨平台所谓跨平台就是在开发完成的程序既可以在 Window 上运行，又可以在 Linux 上运行，还可以在 mac上运行，一次编写在任何平台上都能运行，这种方式就叫做跨平台 编译型语言的特点如果我们使用了某一个操作系统的编译器，那么该最终生成的可执行文件，就只能在 这个操作系统 中执行，它不能再其他 操作系统上 运行，这就是编译型语言的特点； 因为真正 负责跟硬件打交道的，是 由操作系统来负责 的。 解释性语言的特点在不同的操作系统上安装不同的解释器，源代码写好后，就可以丢给解释器去执行，由解释器进行翻译和执行，既然在每个操作系统上都已经安装了解释器，那么源代码就不需要修改，这就是解释性语言在跨平台上的优势； 即程序员只要把注意力专注在源代码的编写上就可以，至于程序的执行，是解释器的工作，我们只要在不同操作系统中安装不同的解释器，同一份代码就可以在不同的操作系统中快乐的执行了 总结开发完成的源程序，要想执行，就 必须找一个翻译，编译型语言要找的翻译叫 编译器，解释型语言要找的翻译叫 解释器。 执行效率上讲，编译型语言的执行效率要比解释型语言执行效率高 从跨平台角度来讲，解释性语言跨平台能力比编译型语言跨平台能力要强 Python的设计目标1999年，吉多·范罗范姆 向DARPA提交了一条名为 “Computer Programming for Everybody” 的资金申请，并在后来说明了他对 Python 的目标 一门 简单直观的语言 并与主要竞争者一样强大 开源，以便任何人都可以为它做贡献 代码像纯英语那样容易理解（阅读起来简单） 适用于 短期 开发的日常任务 这些想法中的基本都以已经成为现实，Python已经成为一门流行的编程语言 Python的设计哲学 优雅 明确 简单 Python 开发者的哲学是：用一种方法，最好是只有一种方法来做一件事 如果面临多种选择，Python开发组一般会拒绝花俏的语法，而选择明确没有或者很少有歧异的语法 在 Python 社区，吉多被称为 “仁慈的独裁者” 为什么选择 Python？ 代码最少 … 同一样问题，用不同的语言解决，代码量差距还是最多的，一般情况下 Python 是 Java 的 1/5，所以说 人生苦短，我用 Python Python 特点 Python 是 完全面向对象 的语言 函数、模块、数字、字符串 都是对象，在 Python 中一切皆对象 完全支持继承、重载、多重继承 支持重载运算符，也支持泛型设计 Python 拥有一个 强大的标准库 ，Python 语言的核心只包含 数字、字符串、列表、文件 等常见类型和函数，而有 Python 标准库提供了 系统管理、网络通信、文本处理、数据库接口、图形系统、XML处理 等额外的功能 Python 社区提供了 大量的第三方模块，使用方式与标准库类似。它们的功能覆盖 科学计算、 人工智能、 机器学习、 Web开发、 数据库接口、 图形系统 多个领域 面向对象的思维方式 面向对象 是一种 思维方式，也是一门 程序设计技术 要解决一个问题前，首先考虑 由谁 来做，怎么做事情是 谁 的职责，最后把事情做好就行！ 对象 就是 谁 要解决复杂的问题，就可以找 多个不同的对象，各司其职，共同实现，最终完成需求 Python 的优缺点优点 简单、 易学 免费、 开源 面向对象 丰富的库 可扩展性 如果需要一段代码运行得更快或者希望某些算法不公开，可以把这部分程序用 C 或 C++ 编写， 然后再 Python 中使用他们 … 缺点 运行速度 国内市场较小 中文资料匮乏","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"从零开始的Python学习","slug":"从零开始的Python学习","permalink":"http://yoursite.com/tags/从零开始的Python学习/"}]},{"title":"其他命令","slug":"Linux/Linux基础-Ubuntu/其他命令","date":"2019-05-06T09:08:34.000Z","updated":"2019-05-08T06:40:34.663Z","comments":true,"path":"2019/05/06/Linux/Linux基础-Ubuntu/其他命令/","link":"","permalink":"http://yoursite.com/2019/05/06/Linux/Linux基础-Ubuntu/其他命令/","excerpt":"","text":"目标 查找文件 find 软链接 ln 打包和压缩 tar 软件安装 apt-get find - 查找文件工作中，有一种情况，随着我们工作的递进，可能会在我们工作文件夹下的文件越来越多，这时候，有一种情况就出现了，就是我们只记得文件的文件名部分内容，而不记得完整的文件名，那么怎么 快速的定位 到这个文件？ 这时候就可以使用 find 命令 find 命令功能非常强大，通常用来在特定的目录下 搜索符合条件的文件； 并且除了 可以 搜索文件名 之外，我们还可以 搜索文件的大小、 文件的修改时间、 文件的权限 等等 进行各种各样的搜索 命令 作用 find [路径] -name “*.py” 查找指定路径下扩展名是 .py 的文件，包括子目录 如果省略路径，表示再当前文件夹下查找 之前学些 通配符，在使用 find 命令时同时可用 演练搜索桌面目录下，文件名包含 1 的文件 首先使用 tree 查看桌面文件夹下的文件以及目录结构 使用 find 命令查找文件，可以看到 桌面文件夹下所有带 1 的文件 都被显示出来 搜索桌面目录下，所有以 .txt 为扩展名的文件 为了方便搜索，我们直接用 cd 切换到 Desktop 目录，接下来 使用 find 命令可以省略 路径，表示直接在当前文件夹查找 可以看到它将桌面文件夹下的所有文本文件都显示出来，并且有一个做梦文件就是在当前桌面文件夹下，另外两个文件 是在 demo 文件夹下的 b目录下 ； 搜索桌面目录下，以数字 1 开头的文件 输入 find 命令查找文件，结果如下： ln - 文件的软链接 命令 作用 ln -s 被链接的源文件 链接文件 建立文件的软链接，用通俗的方式讲类似于 Windows 下的 快捷方式 注意： 1.没有 -s 选项建立的是一个 硬链接文件 两个文件占用相同大小的硬盘空间，工作中几乎不会建立文件的硬链接 2.源文件要使用绝对路径，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用 演练目标第一步 移动文件1.桌面目录下的 01.py 移动 到 demo/b/c 目录下 首先使用 cat 命令查看文件内容 使用 tree 命令 确认移动的目标路径 使用 mv 命令 移动 01.py 文件 到当前路径 可以看到桌面上 01.py 文件 不见了，接着再次使用 tree 命令 查看文件是否在 目标目录 第二步 创建链接2.在桌面目录下新建 01.py 的 软链接 FirstPython 分别使用 相对路径 和 绝对路径 建立 FirstPython 的软连接 接下来使用 ln -s 来创建 01.py 文件的软连接，使用 相对路径 与 绝对路径 两种方式，并且把软链接保持在桌面目录下 相对路径使用 ln 命令创建软链接，并且源文件使用相对路径，可以看到桌面多了一个文件，同时在图标的右下角有一个小箭头 使用 cat 查看创建 的链接的内容，可以看到仍然是 01.py 的文件内容 使用 ls 命令 查看 刚刚创建的 软连接文件，我们可以看到 桌面文件夹下 多了一个 01_xiangdui 文件,同时在这个软链接后面有一个键头，这个键头指向了相对桌面文件夹下 demo/b/c/01.py 绝对路径使用 ln 命令 用 绝对路径 创建一个软链接，可以看到 桌面 出现了一个 软链接 文件 使用 cat 同样可以把 源文件的内容显示出来 再使用 ls 命令 来确认一下，可以看到桌面文件夹下有两个软链接，第一个软链接指向的是 绝对路径，第二个软链接指向的是 相对路径 第三步 链接的区别3.将FirstPython 移动 到 demo 目录下，对比使用 相对路径 和 绝对路径 的区别 在 Desktop文件夹 下，我们可以使用 cat 命令 看到，这两个软链接都是正常使用的，因为都是在桌面目录下创建的，所以使用起来是没有差别的 使用 tree 确认一下目录结构 接下使用 mv命令 配合通配符 将移动 两个 软链接 文件 移动到 demo文件下 再次使用 tree 查看目录结构，并且查看文件是否被成功的移动，我们可以看到 绝对路径的软链接 颜色仍然是 亮蓝色，但是 相对路径的软链接 颜色变成了 红色，同时键头后面指向的文件变白了 接下来却换到 demo目录，并且使用 ls 查看文件的详细信息，可以看到仍然是一个亮蓝色一个红色 下面使用 cat 命令 这两个 软链接 能否 显示 01.py 的内容，首先查看 绝对路径 的内容，可以看到绝对路径能够显示正常的内容 再使用 cat 命令 查看相对路径软链接的内容，终端提示我们没有 哪个文件或目录 再使用 tree 查看当前目录的结构，现在相对文件的软链接出现了问题，可以看到现在我们所在文件的目录是桌面文件下的 demo 目录，而相对路径的软链接是再 demo 文件夹下的又有一个 demo，由于此时 demo文件夹下没有 demo 文件夹，因此再这个时候使用相对路径软链接就出问题了，而我们之前用绝对路径创建的问什么没问题？ 因为这个软链接拥有都是以 根目录 开始，永远都是一个最完整的路径 总结： 如果我们再建立软链接的时候使用的是绝对路径，那么这个软链接无论移动到哪个文件下，都是可以访问到它对应链接的文件 一旦使用相对路径建立的软连接，这个软链接就不能被移动位置 硬链接简介（知道）再使用 ln 创建链接时，如果 没有 -s 选项，会创建一个 硬链接，而不是软链接 硬链接演练 第一步1.在 ~/Desktop/demo 目录下建立 ~/Desktop/demo/b/c/01.py 的硬链接 01_hard 首先使用 tree 查看文件目录结构，现在在 demo目录下 有两个软链接，这两个软链接 都是指向 01.py，同时使用 相对路径 的软链接并不能正常的工作，这是demo 目录下 的文件情况。 接下来使用 ln 命令 在 demo目录下 建立 01.py的硬链接 使用 ln 命令 建立硬链接，并且使用 tree 查看目录的结构，可以看到 demo 目录下 多了一 个 绿色的 01_hard，注意： 01_hard 后面并没有键头 第二步2.使用 ls -l 查看文件的 硬链接数（硬链接–有多少方式可以访问文件或者目录） 使用 ls -l 查看当前目录的情况，可以看到之前两个软链接后面都有键头，这个键头是指向链接文件的位置，而 01_hard 后面并没有键头，看起来就像一个正常的文件 使用 cat 查看 硬链接文件的内容，可以看到同样能够输出 源文件的信息 第三步3.删除 ~/Desktop/demo/b/c/01.py ，并且使用 tree 来确认 demo 目录下的三个链接文件 使用 rm 删除 源文件，并且使用 tree命令 查看文件目录的结构，可以看到 c 目录下的 01.py 已经不见了，同时之前建立的两个软链接都变成了 红色，但是 01_hard 仍然是 绿的 使用 cat文件 查看三个链接内容 硬链接文件 依旧 正常运行 软链接的绝对路径：提示文件或目录不存在，因为软链接指向的 01.py 已经被删除 使用 ls 确认当前目录的文件情况，可以看到两个软链接都变红了，但是硬链接文件 还是绿的，而且硬链接数变成了数字 1 ，这个就是硬链接的作用 硬链接的作用： 我们建立了一个 硬链接，当我们把硬链接的源文件删除之后，硬链接的文件内容并不会受到影响，只有软链接的内容才会受到影响 硬链接和软链接的区别 在 Linux 中，文件名 和 文件的数据 是 分开存储 的 文件和文件名分开存储的概念源文件 是用来存储数据，这些数据是保存在磁盘上的一个位置，想要访问这些数据，只需要使用保存在磁盘上 另外一个位置 的 文件名， 就可以访问到文件中的数据了。 即 文件名（链接文件） 和 文件数据 是保存在磁盘上不同位置的 软链接的概念建立软链接的时候，同样会生成一个软链接的文件名，文件中保存着链接到源文件的完整路径，通过这个完整路径就可以访问到链接文件的文件数据； 软链接类似于 Window 中的 快捷方式，通过 快捷方式 就可以找到链接部分的 完整路径，通过这个路径就可以访问文件中存储的数据； 所以删除了源文件，对应的软链接 也就失效了 硬链接的概念硬链接就是文件的另外一个文件名； 譬如文件名 是文件数据 的 小名，我们无论通过大名 或者 小名，都可以访问到 存储在磁盘中另外一个 位置 的文件数据； 即便我们删除了 源文件，但是因为硬链接的存在，所以文件数据仍然会保留，只有把一个文件的所有文件名，也就是所有硬链接全部删除之后，这个文件数据才会真的从磁盘上删除 打包压缩 打包压缩 是日常工作中备份文件的一种方式 在不同操作系统中，常用的 打包压缩 方式是不同的 Windows 常用 rar Mac 常用 zip Linux 常用 tar.gz 打包/解包 tar 是 Linux 中最常用的 备份工具，此命令可以 把一系列文件 打包到一个 大文件夹中，也可以把一个 包的大文件夹恢复成一系列文件： tar 只负责打包不负责压缩 tar命令格式如下： 打包命令 tar -cvf 打包文件.tar 被打包的文件/路径 … 解包文件 tar -xvf 打包文件.tar tar 选项说明 选项 含义 c 生成档案文件，创建打包文件 x 解开档案文件 v 列出归档解档的详细过程，显示进度 f 指定档案文件名称 ，f后面一定是 .tar 文件，所以必须放选项最后 注意： f 选项必须放在最后，其他选项顺序可以随意 打包解包演练第一步1.删除桌面下的所有内容 使用 rm 命令 删除桌面 上的文件，并且使用 ls 命令查看当前目录，可以看到 当前目录为空 第二步2.在桌面下新建三个空白文件 01.py、 02.py、 03.py 使用 touch 命令分别创建 三个文件 第三步3.将着三个文件打一个 py.tar 的包 使用 tar 命令 打一个 py.tar 包 并且桌面上出现了一个 py .tar 我们用 ls 命令 查看 桌面上的文件信息，可以看到 py.tar 这个文件有 10k，因为 tar 这个命令 在打包的时候不负责压缩 第四步4.新建 tar 目录，并且将 py。tar 移动到 tar 目录下 使用 mkdir 命令 新建一个 tar 目录，此时桌面上多了一个 tar 目录 使用 mv 将 py.tar 文件移动到 新建的目录下，并且用 tree 来检查当前的文件结构，可以看到 py.tar 已经移动到 tar 目录里 第五步5.解包 py.tar 解包前使用 cd 命令切换到 tar 目录下 使用 tar 命令 进行解包，可以看到有三个文件的显示 使用 ls 查看当前目录 确认，可以看到这三个文件已经被 解包 出来了 压缩/解压缩gzip tar 与 gzip 命令结合可以实现文件 打包和压缩 tar 只负责打包文件，但不压缩 用 gzip 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.gz 在 Linux 中，最常见的压缩文件格式就是 xxx.tar.gz 在 tar 命令中有一个选项 -z 可以调用 gzip ，从而可以方便的实现压缩和解压缩的功能 命令格式如下： 压缩文件 tar -zcvf 打包文件.tar.gz 被解压的文件/路径 解压缩文件 tar -zxvf 打包文件.tar.gz 解压缩到指定路径 tar -zxvf 打包文件.tar.gz -C 目标路径 选项 含义 -C 解压缩到指定目录， 注意：要解压缩的目录必须存在 压缩解压缩演练压缩文件使用 tar -z 压缩文件，并且使用 ls 命令查看 文件信息 可以看到 压缩的文件只有 134 个字节，而打包文件大小有 10k，小了非常非常多 解压缩文件首先 使用 mkdir 创建一个 gz 目录，并且使用 mv命令 将压缩文件 py.tar.gz 移动到 gz目录 下，并且使用 tree 命令查看当前的 目录结构，可以看到压缩文件已经移动到目录下 接下来 切换到 gz 目录下，并且 使用 tar 命令 解压缩文件，然后使用 ls 查看 当前目录信息，可以看到 解压出来的 三个文件 bzip2（two） tar 与 bzip2 命令 结合可以使用实现文件 打包和压缩（用法和 gzip 一样） tar 只负责打包文件，但不压缩 用 bzip2 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.bz2 在 tar 命令中有一个 选项 -j 可以通过调用 bzip2，从而可以方便的实现压缩和解压缩的功能 命令格式如下： 压缩文件 tar -jcvf 打包文件.tar.bz2 解压缩的文件/路径… 解压缩文件 tar -jxvf 打包文件.tar.bz2 压缩解压缩演练压缩文件使用 tar -j 命令 压缩桌面上的三个文件，并且使用 ls 查看文件的信息，对比 使用 gzip方式 压缩的文件，可以看到这两种压缩的方式基本差不多 解压缩文件 选项 含义 -C 解压缩到指定目录， 注意：要 解压缩的目录必须存在 eg：如果指定目录不存在，终端会报错 这种方式适用于 gzip 压缩方式，也同样适用于 bzip2压缩方式 首先使用 mkdir 命令 创建一个 bz2 目录，并且使用 tree 查看当前 目录结构，可以看到 bz2 目录 下没有任何的内容 然后再 使用 tar 命令 解压缩文件 并且将 解压缩文件移动带 bz2目录 再使用 tree 来确认 bz 目录下是否有 解压后的文件，可以看到对应的文件，即解压成功 软件安装通过 apt安装/卸载 软件 apt是 Advanced Packaging Tool，是 Linux 下的一款 安装包管理工具 可以再终端中方便的 安装/卸载/更新 软件包 命令格式如下： 安装软件 sudo apt install 软件包 卸载软装 sudo apt remove 软件名 更新已安装的包 sudo apt upgrade sudo 的作用： 是 让我们以 root 身份来执行对系统的维护和管理工作，在 Linux 中，我们平时都是以标准的用户来使用的，而标准用户都是在自己家目录中活动。 但是当我们想要执行一些系统维护管理工作的时候，就需要使用 sudo 以 root 身份来执行。 如果我们想安装一个软件或者卸载一个软件，就意味着当这个软件安装完成之后，系统中所有用户都 能够使用这个软件，因此安装软件也好，卸载软件也好，都应该在前面接上 一个 sudo 安装演练小火车提示 sudo apt install sl 使用 apt 命令 安装 软件，当重新回到终端的命令提示之后，这一款软件就安装完成 接下来输入 sl 测试 软件的效果，可以看到 屏幕被清空并且 有一个小火车从屏幕右侧跑到屏幕左侧 查看进程排名软件 sudo apt install htop 之前学习过，top 命令 可以查看当前系统中所有正在执行进程的 CPU 占用情况 和 内存占用情况 使用 apt 命令 安装 软件 接下来敲入 htop 查看 安装的软件，可以看到一个彩色的界面出来了，会告诉我们 当前 CPU 的 情况、 内存的情况以及当前有多少个任务在执行，并且把 CPU、 内存 占用率比较高的程序显示在最前面 退出 按 q 即可 配置软件源 安装软件过程： Ubuntu 提供了一个主服务器，主服务器提供了所有可以通过 apt 命令 安装程序的软件安装包，当 使用 apt 来安装软件的时候，apt 会首先默认再主服务器上查找有关安装包，如果找到之后，apt就会先把安装包下载到本地，下载完成之后再开始执行安装的动作，安装完成之后，就可以使用这款软件了 如果希望在 Ubuntu 中安装软件更加快速，可以通过设置镜像源，选择一个访问网速更快的服务器，来提供软件下载/安装服务 提示： 更换服务器之后，需要一个相对比较长时间的跟新过程，需要耐心等待。 更新完成后，再安装软件都会从新设置的服务器下载软件了 镜像源，就是所有服务器的内容都是相同的（镜像），但是根据所在位置不同，国内服务器通常速度会快一些 设置镜像源图形界面设置右上角->系统设置->软件和更新->设置下载自->其他站点->中国->选择最佳服务器 当我们更新了镜像源之后，需要做一个 重新载入 的动作，这个重新载入的动作时间比较长，需要耐心等待 从 新的服务器把所有软件源的信息做一个统一的更新，当所有软件源更新完毕后，我们以后下载的软件，就会从 新的服务器下载，而且速度会非常快","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"从零开始的Python学习","slug":"从零开始的Python学习","permalink":"http://yoursite.com/tags/从零开始的Python学习/"}]},{"title":"系统信息相关命令","slug":"Linux/Linux基础-Ubuntu/系统信息相关命令","date":"2019-05-06T06:28:52.000Z","updated":"2019-05-06T09:01:39.696Z","comments":true,"path":"2019/05/06/Linux/Linux基础-Ubuntu/系统信息相关命令/","link":"","permalink":"http://yoursite.com/2019/05/06/Linux/Linux基础-Ubuntu/系统信息相关命令/","excerpt":"","text":"本节内容主要是为了方便通过 远程终端维护服务器时，查看服务器上当前 系统日期和时间 / 磁盘控件占用情况 / 程序执行情况 本小节学习的终端命令基本都是 查询命令，通过这些命令对 系统资源的使用情况 有个了解 目标 时间和日期 data cal 磁盘和目录空间 df du 进程信息 ps top kill 时间和日期 命令 作用 date 查看 系统时间 cal calendar 查看 当前这个月的日历，-y 选项可以 查看一年的日历 date使用 date 命令查看当前的系统时间 cal查看当前月的日历 cal -y【 -y 】 可以查看一年的日历 磁盘信息 命令 作用 df -h disk free 显示 磁盘剩余空间 du -h [目录名] disk usage 显示 目录下的文件大小 du 如果不接任何目录名，就可以来查看 当前目录 的空间占用情况 选项说明 参数 含义 -h 以 人性化的方式 显示文件大小 df查看磁盘空间 此时的磁盘空间是一堆数字，并不人性化，所以在 命令 后添加 -h 选项。 可以看到，此时看到磁盘的空间占用情况就一目了然了 我们在查看磁盘空间的时候，重点放在 根目录 下，因为在 Linux 中并没有盘符的概念，Linux 中所有的文件都是从根目录开始的 注意： 在使用 df命令 查看磁盘剩余空间的时候，我们的重点应该放在 挂载点 根目录 这个位置，通过根目录我们就可以迅速的知道我们的磁盘还有多少可用空间了 du查看目录下文件大小，显示 所有子目录的占用情况，并且在最后 显示当前文件夹整体的一个空间占用情况 注意： 末尾的 52k 表示当前 桌面 文件夹下 所有文件以及子目录 共同占有 52k 文件大小 进程信息所谓 进程，通俗的说就是 当前正在执行的一个程序 命令 作用 ps aux process status 查看 进程的详细状况 top 动态显示运行中的进程并且排序 kill [-9] 进程代号 终止指定代号的进程，【 -9 】 表示强行终止 ps 默认 只会显示 当前用户 通过终端启动的应用程序 ps使用 ps 命令不带任何选项 查看进程信息 使用 ps 查看信息，可以看到终端中显示了两个命令的执行，可以看到 CMD 列，CMD 表示命令： 第一个为 bash 表示专门用来输入终端命令的，而 python这个用户 默认使用的 shell 就是 bash； 第二个为 ps ，我们刚刚执行的命令就是 ps， 统计当前正在执行的程序，而在执行统计的过程中，就会把自己顺带的也统计进来 ps 选项 注意: ps 命令使用选项时，是不需要带 减号的 。 eg： ps a ps 选项 说明功能 选项 含义 a 显示终端上的所有进程，包括其他用户的进程 u 显示进程的 详细状态 x 显示没有控制终端的进程 ps a显示终端上的所有进程，包括其他用户的进程。 可以看到这次显示的内容比单纯敲 ps 要多了两行内容 ps ups au： 通过列表的方式，让我们了解每一个程序是什么时候启动的，它对 CPU 以及 内存 的占用率是 多少 那么这两行内容是由哪一个内容来启动的呢？我们可以使用 ps u 来查看详细信息来确定 这次显示的信息就要比之前显示的信息 详细清晰很多了，现在看看我们比较关系的数据： 首先看最后一列 ， COMMAND，这个表示命令。 也就是用户在终端中 执行了哪个命令 查看倒数第二列 START TIME,这是用户执行程序的启动时间，前面三个是 启动电脑时启动的程序，而最后一个是 刚刚输入的 ps 程序 %CPU %MEM： 这两列信息显示 CPU 和 内存的 占用率 PID：进程的代号 第一列：显示哪一个用户在终端中启动的程序 ps xps x 显示没有控制 终端 的进程 ，即不是通过终端来启动的进程。 之前在使用 a 、 u 这两个选项的时候，包括不使用任何选项，都只会显示出通过终端 启动的应用程序，而 x 这个选项 就会把 当前系统中所有正在执行的程序全部显示出来，但是使用 x 这个选项 我们会看到非常非常多的内容 我们可以看到很多很多的内容，这就是当前 Linux 系统中 所有正在执行的程序，这一些程序绝大多数是 在系统启动时，由操作系统帮我们启动，并且在后台默默的运行，为用户提供服务 toptop命令 动态显示运行中的进程并且排序，一目了然的显示出当前系统中 CPU 和 内存 占用比较高的进程 ； top 这个命令在使用时非常简单，直接输入 top 回车就可以，但是要想退出 top，我们需要在终端窗口中，输入小写字母 q 就可以 可以看到一个全屏的显示信息，首先查看 下方列表的信息，显示了： PID ： 进程代号 启动命令的用户 %CPU %MEM ： cpu 占用率 以及 内存 占用率 TIME+ ： 命令的运行时间 COMMAND ： 具体的命令名称 通过 top 这个命令 ，可以一目了然的把当前系统中 CPU 占用率 和 内存占用率 占用率比较高的程序直接就显示出来，通过这种方式我们就可以在 短时间内 发现当前这个系统中是否有哪一个进程异常，如果发现异常，我们可以做一些特殊的处理；想要退出 top ，输入小写 q 即可 ； top 是一个 实时监控的程序，通过 top 就可以发现 那些程序的 cpu 和 内存 占用比较高； 并且它是一个 实时监控，不会停下来的程序 kill一旦我们发现某个程序占用比较高，或者内存占用比较高，以及影响系统的正常运行，我们就可以使用 kill 这个终端命令，把这些异常的程序杀死，这就是 kill命令 的作用 首先使用 ps 命令 查看所有用户 在终端启动的 进程： 我们可以看到 python 用户启动了 一个进程 bash，bash 有个 进程代号 2587，我们再打开一个终端，再次使用 ps 命令进行查看，可以看到 又出现了一个 bash 进程，并且它们的 进程代号都不相同 接下来 使用 命令 kill 以及对应的 进程代号 关闭新打开的终端窗口 如果 单纯使用 kill 关闭不了进程，我们可以添加 选项 【 -9 】，表示强行终止该进程 注意： 一定要使用 ps 命令 确认要关闭的进程代号 提示： 使用 kill 命令时，最好只终止当前用户开启的进程，而 不要终止 root 身份开启的进程，否至可能导致系统奔溃 要退出 top 可以直接输入 q","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"从零开始的Python学习","slug":"从零开始的Python学习","permalink":"http://yoursite.com/tags/从零开始的Python学习/"}]},{"title":"模态框使用","slug":"Bootstrap/模态框使用","date":"2019-05-05T12:08:48.000Z","updated":"2019-05-06T12:50:41.147Z","comments":true,"path":"2019/05/05/Bootstrap/模态框使用/","link":"","permalink":"http://yoursite.com/2019/05/05/Bootstrap/模态框使用/","excerpt":"","text":"模态框的触发我们上一篇已经完成了基本的模态框，但事实上它肯定是通过 一些触发的，比如说按钮和控件。 不可能直接调用，这里我们添加一个按钮，通过按钮来直接触发它 123456789101112131415161718192021222324252627282930313233343536 启动Modal & times; Modal title Content close Save //这里由于有按钮控制，所以不需要使用 js 来触发 //$(\"#myModal\").modal(\"show\"); 可以看到一个按钮，点击就启动了当前的模态框 模态框的尺寸我们这个模态框就不把所有的内容、 部分全部写完 fade：具有过渡效果的类 12345678910111213141516171819202122232425262728 启动大 Modal 这是一个大的模态框Modal 启动小 Modal 这是一个小的模态框Modal 两个按钮点击分别出现 宽度较宽 和 宽度较窄，这就是大与小的区别，当然再点击的同时，会有一个慢慢展示出来的效果，如果想把过度效果去掉，只需要将 fade 去掉的即可。 这个是 过渡、 添加与删除、 启动大的和小的模态框的区别 包含表单的模态框其实这个模态框当中承载的内容可以有很多，不如可以承载一些表单，表单中还可以填写一些默认的信息，这些通过 js 也可以来实现 1234567891011121314151617181920212223242526272829 Open modat & times New Message Recipient Close Send 点击按钮，可以弹出一个效果框。并且我们会发现我们给了一个 【 data-whatever=”@mdo” 】，这个消息可以放在 input 当中，我们可以使用 JavaScript 实现，eg： 1234567$(\"#exampleModal\").on(\"show.bs.modal\",function(event){ var button = $(event.relatedTarget) var recipient = button.data(\"whatever\") //获取 whatever var modal = $(this); //声明 modal modal.find(\".modal-title\").text(\"New Message to\"+ recipient); //放置到标题 modal.find(\".modal-body input\").val(recipient) //放置到 输入框}) 第一个参数是事件、 第二个参数是回调函数 可以看到 标题 与 input 中多加了一个 whatever 获取的内容，这个比较有用，在很多 用户体验方面都需要这样好的提示， 同时，Bootstrap也给我们提供了","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"基本模态框","slug":"Bootstrap/基本模态框","date":"2019-05-04T11:24:12.000Z","updated":"2019-05-04T12:37:14.224Z","comments":true,"path":"2019/05/04/Bootstrap/基本模态框/","link":"","permalink":"http://yoursite.com/2019/05/04/Bootstrap/基本模态框/","excerpt":"","text":"基本描述JQuery插件 为 Bootstrap组件赋予了生命，可以简单地引入所有的插件，也可以逐个引入到页面当中。 但是建议一次全部引入，也就是只引入一个它已经压缩过的插件 引入方式： 一次性引入当前文件 引入压缩过的文件 也可以一个一个去引入 引入文件引入单个插件以下是一个一个引入的插件 文件，它包含在一个 js 文件夹，里面包含了很多 js文件 接下来我们来看一下这些文件的作用： 最后一个是针对过渡动画效果的，还有 tab、 tooltip、 提示、 已经模态框、 button 等等，这些我都可以单独的去引用，如果只需要其中之一的话 引入所有文件也可以一次性引入编译过后的 bootstrap.min.js、或者位编译的 bootstrap.js，这样比较方便 描述描述当中包含 文件的引入 API属性 编程方式 命名空间避免冲突 事件 版本 浏览器对 Javascript 的禁止情况 第三方工具 过渡过渡效果我们可以根据之前了解过的一些效果，比如说： 我们有两个 table 切换的效果，这就是属于一个过渡的效果，事实上它的过度效果比较多，选项卡知识其中之一，比如说接下来我们要演示的一些： 弹出框（模态框） 警告框 图片轮播 这些都是用到了一些渐变的效果，需要注意的是，这些都是通过 Css3 来进行实现的，所以低版本的浏览器在这里是不具备这些过渡效果的，在使用的时候一定要注意，所以关于 过渡 我们通过接下来要讲解的模态框 来详细的来观察它过渡的具体效果 模态框的注意事项 不支持模块框的重叠 如果想要重叠，需要 手动 写额外的来写 js 代码来进行实现 模态框 HTML 代码 放置的位置，务必要将 HTML代码放在文档的最顶级，也就是 body 标签直接的子元素下面，避免其他组件冲突，影响模态框的展示和功能 手机方面的使用说明，这里给出了关于焦点的使用方法 实例首先引入文件，这里为了方便，直接引入压缩之后的文件 bootstrap.min.js 注意： bootstrap的 .css 和 .js 是要 通过 JQuery 来支持的 12345678910111213141516171819202122232425262728293031 & times; Modal title Content close Save //不调用没有效果 $(\"#myModal\").modal(\"show\"); 可以看到一个模块框出现了，有 close 有 save 按钮，点击 x 可以关闭，点击 close 依然可以关闭，并且点击空白处它也会消失 注意： 如果不引入 js 文件是没有任何效果的，所以需要引入 js 文件， 并且 JQuery文件 在 js 文件的上方，即 js文件 是 基于 JQuery文件 的","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"列表组","slug":"Bootstrap/列表组","date":"2019-05-03T12:22:43.000Z","updated":"2019-05-03T13:07:47.676Z","comments":true,"path":"2019/05/03/Bootstrap/列表组/","link":"","permalink":"http://yoursite.com/2019/05/03/Bootstrap/列表组/","excerpt":"","text":"列表组在网站中应用还是很广泛的，通常用它来承载消息队列，在 Bootstrap 中 也给我们提供了列表组的使用，包含 基本的列表组 徽章式列表 可点击的（链接） 被禁用的条目 情景类 定制内容 基本的列表组在列表组中可以放一些内容，当然，放的内容是不固定的，有时候可以放一些 可点击的属性，也可以放一些不可点击的属性。 当然它们承载的内容都是互通的 12345678 姚大帅哥 姚超级帅哥 姚无敌帅哥 姚究极帅哥 在这里我们不难看出这是一个列表，当然大小以及放置的位置都是我们自己去调整的，可以根据 栅格系统进行调整 徽章式列表12345678 10姚大帅哥 姚超级帅哥 1姚无敌帅哥 30姚究极帅哥 可以看到不同的消息提示，这种属于徽章式的 可点击的列表123456 姚超级帅哥 姚大帅哥 姚究极帅哥 姚无敌帅哥 可以看到，当鼠标经过，会有一个一个效果，也可以添加选中项 被禁用的条目只需要在 class 中添加 disabled属性 即可 123456 姚超级帅哥 姚大帅哥 姚究极帅哥 姚无敌帅哥 可以看到第四个不允许我们选中，因为他被我们禁用了 情景类的列表组也就是根据我们所应用的环境不同，而改变它们的 颜色 123456 姚超级帅哥 姚大帅哥 姚究极帅哥 姚无敌帅哥 可以看到呈现出不同颜色，根据所应用的场景不同，而改变它的内容 定制内容我们不可能每一项只放一条内容，可能里面还有其他内容，有标题、 标题的描述 还有 具体文字 ，这种情况下需要我们定制内容 1234567891011121314151617181920212223 极客学院 这里是一个学习的地方，希望大家维护好这个环境 极客学院 这里是一个学习的地方，希望大家维护好这个环境 极客学院 这里是一个学习的地方，希望大家维护好这个环境 极客学院 这里是一个学习的地方，希望大家维护好这个环境 它不单单可以放这种文字型的内容，它也可以放图片，甚至超链接什么都可以放，只要你能想到的内容都可以放进来，这就是定制。 其实就是在 a标签 中添加不同的内容 我们在使用 Bootstrap 的时候，一定要去找它有没有提供我们要用到的东西，基本上我们在网站上应用的东西他都有提供，除非是及其特殊的情况下，所以在大部分情况下，我们直接需要去找就可以了，不要自己去写、不要自己去定义，这是我们使用 Bootstrap 的一个很重要的问题，注意这些问题会给我们 节省很多时间","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"进度条","slug":"Bootstrap/进度条","date":"2019-05-03T10:46:53.000Z","updated":"2019-05-03T13:10:41.918Z","comments":true,"path":"2019/05/03/Bootstrap/进度条/","link":"","permalink":"http://yoursite.com/2019/05/03/Bootstrap/进度条/","excerpt":"","text":"进度条分为很多种： 基本的进度条 带有提示的、标签的进度条 情景变化 条纹 动画效果 堆叠效果 基本的进度条1234567891011121314 body{ margin:10 0; } 50% 可以看到这样一个进度条，它处于 50% 的状态 带有提示的、标签的进度条12345 60% 这样会更好的标识当前的进度 情景变化12345 可以根据它提供的不同效果，可以在不同的情景下使用 条纹有的时候我们会看有条纹的会舒服一点，证明他在一点点往前走,Bootstrap 也提供了这种效果 12345 40% 动画效果上面演示的都是静态的，我们有时希望看到动态的，Bootstrap 也支持动画效果，而且 它的动画效果是非常简单的，只需要叫一个 active属性 即可 12345 40% 可以看到条纹动起来了 堆叠效果1234567 可以看到两个颜色的进度条堆叠在一起了","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"用户权限相关命令","slug":"Linux/Linux基础-Ubuntu/用户权限相关命令","date":"2019-05-03T09:35:49.000Z","updated":"2019-05-06T06:27:03.054Z","comments":true,"path":"2019/05/03/Linux/Linux基础-Ubuntu/用户权限相关命令/","link":"","permalink":"http://yoursite.com/2019/05/03/Linux/Linux基础-Ubuntu/用户权限相关命令/","excerpt":"","text":"在接下来小节中，要学习的这些终端命令，在日常工作中 使用频率 并不是很高，因为 有关 用户以及权限的设置，应该有 系统管理员 来操作才合理，同时在开发团队中，只有当开发团队的人员发生变化之后，才会由系统管理员来做添加用户以及删除用户的操作 接下来的学习过程中，应该把 重点放在理解用户以及权限的概念 上，同时对 用户管理、 组管理 以及 修改权限 这些终端命令的基本使用有一个印象 目标 用户 和 权限 的基本概念 用户管理 终端命令 组管理 终端命令 修改权限 终端命令 用户和权限的基本概念 用户 是 Linux系统工作中重要的一环，用户管理包括 用户 与 组 管理 在 Linux系统 中，不论由本机或是远程登录系统，每个系统都必须拥有一个账号，并且对于 不同的系统资源有不同的使用权限 在 Linux 中，可以指定 每一个用户 针对 不同文件或者目录 的 不同权限 在 Linux 中，可以指定 每一个用户 针对 不同的文件或者目录 的不同权限 序号 权限 英文 缩写 数字代号 1 读 read r 4 2 写 write w 2 3 执行 excute x 1 组 为了方便用户管理，提出了 组 的概念，eg： 在实际应用中，可以预先针对 组 设置好权限，然后 将不同的用户添加到对应的组中，从而 不用依次为每一个用户设置权限 ls -l 扩展 ls -l 可以查看文件夹下文件的详细信息，从左到右依次是： 权限，第一个字符如果是 d 表示目录 硬链接数，通俗地讲，就是有多少种方式，可以访问到当前目录/文件 拥有者，家目录下文件/目录的拥有者通常都是当前银狐 组，在 Linux 中，很多时候，会出现组名和用户名相同的情况 大小 时间 名称 r：可读 w：可写 x：可执行 硬链接数表示有几种方式能够访问到该文件 eg：访问到 aaa目录的几种方式： 硬链接数为3的原因： 任何地方使用绝对路径访问 在当前路径使用相对路径访问 子文件夹返回到 aaa目录 结论： 绝大多数文件的 硬链接数 通常都是 1，而 目录 的 硬链接数 取决于目录包含有多少个子目录 chmod 简单使用（重要） chmod 可以修改 用户/组 对 文件/目录 的权限 命令格式如下： chmode +/-rwx 文件名|目录名 提示： 以上方法会一次性修改 拥有者/组 权限 修改文件权限禁用所有权限首先使用 ls 查看 01.py 文件的权限 可以看到该文件当前拥有 可读、可写权限，接下来使用 chmod 来修改该文件的权限 可以看到该文件的权限都为 【 - 】 ，就表示我们对该文件没有任何的权限，并且文件图标上出现了小锁头： 接下来打开文件测试，可以看到 系统提示我们没有打开文件的权限 恢复权限输入 chmod 恢复权限，可以看到现在我们又具有了 可读、 可写 权限 添加可执行权限可以看到文件名变绿了 注意： 在 Linux 终端中，要想执行某一个文件，是由一些细节的 ，首先要敲一个 【 . 】 表示当前目录，再加一个 【 / 】 表示当前目录下要执行哪一个文件 接下来执行文件： 注意： 执行的时候需要在 文件中加入以下内容（python 后面回讲述，这里不作分析） 输入执行命令，可以看到 文件可以执行： 修改目录权限首先新建一个目录，并且查看目录的权限，可以看到新建目录 默认权限 对拥有者而言是 可读可写可执行 修改可执行权限接下来使用 chmod 取消 目录的可执行权限： 当取消可执行权限时，我们就无法 切换、查看 该目录,而且提示我们权限不够，并且无法执行目录下的文件 注意： 一个目录如果没有可执行权限，我们就 不能对这个目录执行其他的终端命令 ，因此要想针对目录执行终端命令，就必须给目录增加可执行权限 修改读写权限使用 chmod 取消 目录的 读写权限 ，并且查看该目录权限 接下来尝试切换到该目录，可以看到成功切换，因为此时我们拥有 可执行权限 当时无法 读取目录中的内容，因为我们没有 可读权限： 接下来添加 可读权限， 测试 可写权限， 可以看到 提示 无法创建，权限不够，因为此时我们没有 可写权限 总结对于目录而言 可读权限 就是阅读目录的内容 可写权限，就是修改目录的内容 想在目录下 执行 终端命令，就必须要有 可执行权限 超级用户 Linux 系统中的 root账户 通常用于 系统的维护和管理，对操作系统的所有资源 具有所有访问权限 在大多数版本的 Linux 中，都不推荐 直接使用 root 账号登录系统 在 Linux 安装的过程中， 系统会自动创建一个用户账号，而这个默认用户就称为 标准用户 sudo su 是 substitute user 的缩写，表示 使用另一个用户的身份 sudo 命令用来以其他身份来执行命令，预设的身份为 root 用户使用 sudo 时，必须先输入密码，之后又 5分钟 的有效期限，超过预期则必须重新输入密码 若其未经授权的用户企图使用 sudo，则会发警告邮件给管理员 组管理 终端命令 提示：创建组/删除组 的终端命令都需要通过 sudo 执行 序号 命令 作用 1 groupadd组名 添加组 2 groupdel 组名 删除组 3 cat /etc/group 确认组信息 4 chgrp -R 组名 文件/目录名 递归 【 -R 】 修改 文件/目录 的所属组 提示： 组信息保存在 /etc/group 文件中 /etc 目录是专门用来保存 系统配置信息 的目录 添加组如果我们不输入 sudo 直接添加一个组，系统会提示我们： 权限不够 无法写入 /etc/group文件 接下使用 sudo 来添加一个组，终端会要求我们输入一个密码，并且使用 ls 在 /etc/group 文件下使用 cat命令 确认是否创建成功，可以看到在最末尾有 dev组，表示我们创建成功 删除组使用 sudo 使用 groupdel 删除组，并且使用 cat命令 查看是否删除成功，可以看到 dev组 已经消失，表示操作成功 关于 cat /etc/group这个文件不需要死记硬背，因为只要在 执行操作组的信息时，不加上 sudo ，就可以看到 group文件 的路径，通过这个提示我们就知道，有关组的信息，都是保存在 etc 下 group文件 修改文件/目录所属组目标 再 python用户 的桌面文件夹下创建 【 mkdir 】 Python学习 目录 新建 【 groupadd 】 dev组 将 Python学习 目录的组修改为 dev 建立 Python学习 目录 新建 【 groupadd 】 dev组 修改 Python学习 目录 的组，修改为 dev 首先使用 ls命令 查看 目录 当前所在组 建立一个 目录或者组时，会自动建立与文件和目录的拥有者的用户名 相同名称 的组 使用 chgrp 修改 Python学习 目录 的组名，并且再次使用 ls命令 查看该目录的信息，可以看到 Python学习 目录的所属组变成了 dev 可以发现 dev组的权限是 可读可写可执行，就意味着将来我们把用户添加到 dev组，那么 dev 组的所有成员都对 该目录拥有 可读可写可执行 的权限 用户管理 终端命令 提示： 创建用户/删除用户/修改其他用户密码 的终端命令都需要通过 sudo 执行 创建用户/设置密码/删除用户 序号 命令 作用 说明 1 useradd -m -g 组新建用户名 添加新用户 -m 自动建立用户家目录； -g 指定用户所在的组，否则会建立一个和同名的组 2 passwd用户名 设置用户密码 如果是普通用户，直接用 passwd； 可以修改自己的账户密码 3 userdel -r 用户名 删除用户 -r 选项会自动删除用户目录 4 cat/etc/passwd ㅣ grep 确认用户信息 新建用户后，用户信息会保存在 /etc/passwd文件中 在 Linux 中要添加一个新用户，必须要使用两个终端命令 第一个终端命令负责创建新用户 第二个终端命令负责指定用户的密码 创建用户 所有用户的 家目录 都默认保存在根目录的 home 文件夹下 添加一个用户，并且系统自动提示我们输入密码 输入完成，我们可以看到，home 目录下出现了相对应的文件夹，表示用户创建成功 接下来使用 ls 命令 确认它是否是 新的用户，可以看到它的 文件拥有者 就是 新建的用户 zhangsan，同时目录的所属组为 dev： 注意： 对于 zhangsan 的家目录，dev 这个群组只有 可读可执行权限，并没有可选的权限，也就意味着，默认情况下，dev群组中的人 只能对 zhangsan 家目录读取，而不能修改 zhangsan 家目录内部的内容, 这样是合理的，否则 别的 用户就可以对 zhangsan 的文件进行操作，所以这个群组默认对家目录的权限 没有可写权限 设置密码此时用户还没有创建完成，因为我们只是创建了用户，并没有设置用户的密码 注意： 没有设置密码，我们就没有办法在远程通过用户来登录系统 接下来使用 passwd命令 设置用户的密码 接下来使用 客户机 进行测试，并且使用 pwd 查看当前的工作目录，可以看到当前在 zhangsan的家目录中，表示成功登陆 删除用户useradd 的 -m 选项目标： 在新建用户时，如果不使用 -m 选项， 会出现什么情况？ 同时确认一下在使用 useradd 添加新用户时，新用户的信息保存在哪里？ 注意事项： 没有使用 sudo： 系统会提示没有权限使用 useradd 系统提示还提示了 没有权限修改 /etc/passwd passwd文件使用 ls 查看 passd文件 的详细信息，我们可以看到 passwd文件 的拥有者是 root，并且对这个文件有 可读可写 的权限，而 passwd 的 组成员 和其他成员都只有 只读权限，没有写的权限 接下来使用 cat命令 来查看 passwd 的内容，可以看到，我们创建的 zhangsan用户 是保存在第 49行，这这一行的末尾有一个 /home/zhangsan ，这个目录是 zhangsan 用户的家目录。 通过这个验证，我们没有在 useradd命令 前面增加 sudo，确认了 用户信息 是保存在 /etc/passwd，同时在这个文件盒中，还记录了用户的家目录信息 -n 表示 显示行号 不添加 -m 创建用户现在不使用 -m 选项创建用户 lisi，可以看到，文件中并没有出现 lisi 的 家目录，我们再使用 cat 命令查看 passwd 文件，看看 lisi用户 是否已经添加 我们可以看到在 50行 多了一条 lisi 的 信息，同时 lisi 的家目录是 /home/lisi ，但是由于我们在新建用户时没有使用 -m 选项，所以添加完用户后，系统并没有帮我们创建 liss 的家目录，这就是不使用 -m 选项 带来的后果 提示： 创建用户时，如果忘记添加 -m 选项指定新用户的家目录 –最简单的方法就是 删除用户，重新创建; 否则我们就得用 终端命令 创建命令，并且手动设置权限 非常麻烦 创建用户时，默认会创建一个用户名同名的组名用户信息保存在 /etc/passwd 文件中 删除用户使用 userdel 命令删除 用户， -r 选项表示自动删除用户家目录，可以看到 它提示了没有找到 邮件目录 和 主目录，因为这两个邮件都不存在 接下来使用 cat 查看 passwd 文件 是否发生了变化 可以看到现在已经 没有了 lisi用户，表示已经成功删除 查看用户信息 序号 命令 作用 1 id[用户名] 查看用户 UID 和 GID 信息 2 who 查看当前所有登陆的用户列表 3 whoami 查看当前登录用户的账户名 用户代号 和 组代号使用 id 查看 用户 lisi 的 用户代号（UID）以及 组代号（GID） 用户带号（UID）：是保存在 /etc/passwd 文件下的 组代号（GID）：是保存在 /etc/group 文件下的 passwd 文件使用 cat 命令 查看 passwd 文件下 lisi 的相关信息; 可以看到 lisi用户 的信息在 passwd的 第50行， 并且可以看到 在 passwd文件中是以 冒号 【 ： 】 来分隔信息 的 ，每一个冒号分隔一段信息 /etc/passwd 文件存放的是用户的信息，由 6 个分号组成的7个信息，分别是 用户名 密码（x， 表示加密的密码） UID（用户标识） GID（组标识） 用户全名或本地账号 （如果没有设置就使用 用户名作为 全名） 家目录 登陆使用的 Shell，就是登陆后，使用终端命令， ubuntu 默认是 dash group 文件使用 cat命令 查看 group文件 中的 dev组 可以看到开发组的组代号是 1001，所以 用 id命令 查看 lisi用户 的信息的时候， lisi用户 的信息也是 1001 id命令如果不指定 用户 直接输入 id，就是查看 当前用户的信息 输入完成后我们可以看到， 当前用户 python 的用户组还是很多的，先看前两项， python的用户带号 和 组代号 都是 1000，并且在使用 useradd命令 添加用户的时候，如果没有指定用户的组，会自动建立一个同名的组，因此，虽然有两个 1000，但是前面一个1000是用户代号，后面一个1000是组代号 接下来分别使用 cat 命令查看， passwd文件 与 group文件 中 python 用户的内容 在 group文件中，我们可以看到 ，在 67行 定义了一个 python的组，这里的 组代号 与 passwd 中的 组代号 是完全一样的； 接下俩再看看 group文件 中其他几个带 python 的 第 5 行：有一个adm，在后面有一个 python，这个 python 标识的是 passwd文件中 记录的python用户，而不是在 group 中第67行 定义的 python组， 表示 python用户 具有 管理员这个组的权限 第 18 行 的 python 用户可以访问系统的光驱 第 21 行 表示 python 这个用户可以 用 sudo 即 root 的身份 来执行系统管理和维护的工作 这里所有带 python 用户的组名，跟我们使用 id 命令查询出来的结果是完全一样的，这是 Linux 中 管理用户权限的一个非常重要的特点，我们可以定义一个用户，然后把用户放到不同的组里面，这样这个用户就可以拥有不同组所具有的权限 who 与 whoami 命令 作用 who 查看当前所有登陆的用户列表 whoami 查看当前登录用户的账户名 who： 查看当前所有登陆的用户列表， Linux 是个多用户操作系统，在同一时间允许多个用户同时使用一个电脑，使用 who 可以查看当前这一时刻有多少个用户登陆到系统中 whoami： 只是显示一下当前登陆用户的账户名 whoami使用 whoami命令 查看当前用户名 who使用 who命令 查看当前登陆额账户名 系统会 告诉我们 当前登陆的是 python 用户在 最后面有一个地址 【 (:0) 】 ，表示从当前这台计算机登陆的 中间的时间： 表示上一次开机的时间，如果中间没有重新启动计算机，那么这个数值将不变 接下来使用 windows系统的 Xshell 来登陆 Ubuntu,测试 who显示的多用户登陆，首先在 Xshell登陆 用户 zhangsan 登陆后，返回 Ubuntu中 使用 who 命令，测试是否能够看到 zhangsan 这次登陆，系统会告诉我们，这次有两个用户登陆到 Ubuntu 中，一个是 本机用户 【 (:0) 】， 另外一个是从 IP地址 【 (172.16.140.133) 】 登陆过来的，并且告诉我们系统的登陆时间 结论： who命令 可以查看 当前登陆的所有用户 以及 用户的来源，这个就是 who 的作用 usermodusermod 可以用来设置 用户的 主组 / 附加组 和 登陆 Shell，命令格式如下; 主组：通常在新建用户时指定，再 etc/passwd 的第4列 GID对应的组 附加组：再 etc/group 中最后一列表示该组的用户列表，用于指定 用户的附加权限 提示：设置了用户的附加组之后，需要重新登陆才能生效！ 修改用户的主组（passwd 中的 GID） usermod -g 组 用户名 修改用户的附加组 usermod -G 组 用户名 修改用户登录 Shell usermod -S /bin/bash 注意： 默认使用 useradd 添加的用户数没有权限使用 sudo 以 root 身份执行命令的，可以使用以下命令，将用户添加到 sudo 附加组中 usermod -G sudo 用户名 回顾id命令： 如果不指定用户 ，就默认查看当前的信息 通过系统返回的命令，我们可以看到： python 的 用户表示是 1000 主组标识 也是 1000 【 组= 】 后面的内容： 第一个组 是 python用户的 主组 1000 其余 4(adm) 、24()cdrom) 、27(sudo)… ，这一些组都是附加组，是用来指定 python 用户的附加权限的 使用 cat命令 确认 python用户的 主组标识 和 附加组 标识 第三列： python用户 的用户标识 第四列： python用户的 主组标识 再使用 cat命令 查看 group 文件 中 python用户 67行python的 组代号是 1000 其余的组后面都有一个 python，再后面这个 python 表示的是 python 用户 而不是 python组，如果 用户在某个组的后面，就说明用户拥有该组的权限。 譬如： 21行的附加组叫 sudo，因此 python这个用户可以使用 sudo 以 root身份 来执行系统维护的相关命令 如果没有附加组下面使用命令 id 查询用户 zhangsan的信息 我们可以看到 ，张三的用户标识是 1001，张三的组标识是 1001 ，但是后面的 【 组= 】 只有 zhangsan 的主组，并没有附加组 那么，如果我们在终端中，以张三这个用户登陆，张三能使用 sudo 来执行系统管理相关的命令吗？ 肯定不行。接下来在 Window计算机 中 使用 Xshell 远程登陆 Ubuntu系统： 可以看到系统提示 【 提示我们 zhangsan 不再 sudders 文件中 】 那么现在 wangwu 这个用户被创建 了吗？ 使用 cat 命令 查看 passwd文件 确认下： 可以看到回车之后最后一个用户仍然是 lisi 并没有 wangwu这个用户 总结： 通过这个实验可以知道，Ubuntu中默认用 useradd 新建出来的 zhangsan用户 并不能使用 sudo 来执行系统维护权限的 设置用户的附加组如果我们想让 zhangsan用户 拥有权限可以 把 该用户添加到 sudo 这个附加组 中 就可以了。 要想给用户添加附加组，我们就要使用 usermod 这个命令 修改用户的主组（passwd 中的 GID） usermod -g 组 用户名 修改用户的附加组 usermod -G 组 用户名 修改用户登录 Shell usermod -S /bin/bash 注意：通常用户的主组 我们是在新建用户时指定的，新建用户之后我们很少会修改用户的 主组，绝大多数我们都是通过 -G 的选项来增加用户的附加权限 下面给 zhangsan 用户 增加 权限： 现在 zhangsan 这个用于已经被添加到 sudo 这个附加组了，我们使用 cat 文件 查看 group 确认一下： 我们可以看到 在 21 行 sudo这个附加组中，除了之前看到的 python用户之外，又多了一个 zhangsan用户，即添加成功 但是如果们想要 zhangsan 这个用户执行系统管理权限，我们必须要退出之前的终端，否则同步 Ubuntu 中配置的信息，重新启动后再次 使用 cat 命令 查看 passwd文件，可以看到已经成功的使用了 sudo 命令： 设置用户登陆的 shell我们要想使用终端命令，首先应该点击任务栏上的终端图标，点击之后 Ubuntu 会帮我们打开终端窗口，我们在终端窗口中就可以输入中断过命令，下图的所示的窗口就是 shell shell： 所谓shell，就是可以输入终端命令的窗口，shell是一个软件 ； shell的显示情况当前这个python用户，在 Ubuntu系统下，shell 的显示情况，我们每次输入终端命令的时候，在输入前 都有一个 【 $ 】 符号， 而在前面会显示一个当前的用户名 紧接着 【 @ 】 符号 以及当前计算机的名字，然后 在 【 ： 】 后面会跟上一个 【 ~ 】 号，这个 【 ~ 】 就表示当前所在的工作目录。 这个就是当前 python 用户使用shell的显示情况 Windows系统的 Xshell： 可以看到，在 Xshell 里面，查看文件的时候没有颜色 可以看到浅蓝色是 目录，亮蓝色是 文件，目录和文件一目了然，并且在 【 $ 】 符号前面既可以看到当前的用户名，也可以看到当前所在的工作目录； 可以发现 Ubuntu 中使用的 Shell 和 Window 中使用的 Xshell并不一样 为什么两者会有区别？ 在 ubuntu 下使用 useradd添加的用户之后，这个用户 默认使用的 shell 是 dash dash 是一个软件，软件名叫 dash 而在 Ubuntu 下的 python用户 使用的 shell 叫 bash，注意这两个 shell 只有一个字母不同 python用户使用的是 bash 默认用户使用的是 dash 因为 Ubuntu 认为 ，dash 这个 shell 效率更高，但是在 Windows 下， dash 这个终端有一个非常严重的缺陷： 当我们按向上的键时，显示的是一堆 ^[A…， 如果按删除键，显示 ^H… 等等，这些显示显然不是我们想看到的，这个就是 dash 这个 shell 在 Window 中显示让人非常不满意的地方 那如何解决这个问题？ 我们可以指定 zhangsan 用户登陆的 shell 就可以解决 我们在 usermode 命令格式后面增加一个增加一个 【 -s 】 选项，然后指定一下用户要使用的 shell 名称，在这里使用绝对路径，根目录下，bin目录下的 dash，然后在后面跟上用户名就可以 指定 zhangsan 用户的 shell 重新在 Xshell中登陆 zhangsan 用户，可以看到现在已经又变化了，有名字有机器有工作目录，现在我们尝试查看根目录下的文件夹，看看有没有区别 可以看到颜色发生了改变，这个就是改变了 shell 之后我们看到的一个效果 shell的显示情况/etc/passwd 的 最后一个选项，就是 指定的用户登陆使用的 shell，现在回到 Ubuntu 再次确认下： 可以看到最后一列出现了 /bin/bash,而 lisi 、 wangwu 并没有指定 shell，所以末尾只有一个冒号而没有内容； 如果我们希望新建的用户 登陆到 Ubuntu 能够 看到 带颜色 显示的 shell，那么，就可以用这一小节中， usermode 命令 指定 一下用户登陆 shell 就可以解决 which（重要）which 这个命令是用来 查询 执行命令 所在位置的 /etc/passwd 是用来保存用户的信息，但是为什么这个程序还可以修改用户的密码？ etc 这个目录是专门用来保存跟系统配置相关的目录，在这个目录下有一个 passwd 文件，这个文件是专门用老保存用户信息的 文本文件，这个 passwd文件只是个文本文件，并不能执行； 而我们之前执行的修改用户密码的程序，虽然也叫 passwd，但是这个 passwd 程序是保存在 /usr/bin/passwd 这两个 passwd 虽然名字相同，但是所处的位置不同： 一个是 etc 目录下保存用户信息的文本文件 一个是在 /usr/bin 目录下 专门用来修改用户密码的程序 提示 /etc/passwd 是用于保存用户信息的文件 /usr/bin/passwd 是用于修改用户密码的程序 查找执行命令的位置/usr/bin/passwd 文件 可以看到终端中告诉我们， passwd这个文件 保存在 /usr/bin/passwd 目录下，下面使用 ls 查看 passwd文件 终端提示我们，这个 文件 保存在 /usr/bin/passwd 下，并且用一个红色的标识，并且看一下前面的权限，对于 root 而言 可读可写可执行 注意： s 也是一个可执行权限，但是它相对而言稍微特殊一点，这个 s 权限在日常使用中使用的极少，因此这里先把 s 看成可执行就可以 /etc/passwd 文件 输入命令后，终端告诉我们 ， etc 下有一个 passwd ，这个文件对于 root 而言是 可读可写 但是不能执行，可以看到这是两个不同的程序， etc 下的 passwd 不能够执行，而 /usr/bin/passwd 具有可执行权限 因此虽然两个文件都叫 passwd，但是 etc 下的 passwd 并不能执行，只是用来保存用户信息的； 而 usr 下的 passwd 是可以修改用户密码的程序 查看执行命令的所在位置Which ls 输出 /bin/ls 使用 which 命令 查看 ls命令 所在位置， 系统告诉我们 ls 是保存在 bin 目录下的 我们在用 ls 查看 这个文件，可以看到一个 绿色的 ls，同时对于 root 而言，同样是可读可写可执行，而对于其他用户而言是 可读可执行： Which useradd 输出 /usr/sbin/useradd 使用 which 查看 useradd 命令的所在位置，可以看到 useradd 这个文件 又保存在 user/sbin 文件中 接下来 使用 ls 查看 useradd 文件 信息，可以看到 一个 绿色的 useradd,同时前面写着，对于 root 而言，是可读可写可执行，对于其他用户我 可读可执行，这个就是 which 这个 终端命令 的用处 总结which 可以查询 我们 执行的终端命令 保存在 系统中的所在位置 bin 和 sbin 在 Linux 中，绝大多数可执行文件都是保存在 /bin、/sbin 、/usr/bin、 /usr/sbin /bin （binary）是二进制执行文件目录，主要用于具体应用 /sbin（system binary）是系统管理员专用的二进制代码存放记录，主要用于系统管理 /usr/bin（ust commands for applications）后期安装一些软件 /usr/sbin（super user commands for applications）超级用户的一些管理程序 bin：表示二进制的文件 usr：就是整个系统安装好之后，后期安装的软件，如果是一般日常的软件，就放在 /usr/bin 下。 而如果是跟系统管理相关的软件，通常就放在 /usr/sbin下 切换用户 命令 作用 说明 su - 用户名 切换用户，并且切换目录 -可以切换到用户家目录，否至保持位置不变 exit 退出当前登陆账户 su 中间有一个减号，如果我们在 切换用户的时候，添加减号，那么我们在 切换用户的同时把当前的工作目录切换到目标用户的家目录，这就是 减号 的作用， 如果不使用减号，则只会切换用户，而不会切换目录 注意： su 不接用户名，可以切换到 root，但是不推荐使用，因为不安全 exit 示意图如下 在实际工作中，什么时候需要切换用户？ 假如我们用 python用户 这个身份登陆 Linux 服务器，对服务器进行日常的维护和管理 但是，python 用户的权限不够，有些终端命令，python 用户并不能执行 那么 python 用户 就可以使用 su 这个终端命令把 当前的用户身份从没有权限的 python 用户，切换到有权限的用户； 切换之后，我们再执行的所有命令，都是以张三这个用户来执行，当所有特殊的终端命令执行完成之后，我们就可以再终端中执行一个 exit 终端命令： 表示退出 zhangsan 用户的身份，重新返回到 python 用户，返回回来之后，我们再敲的所有终端命令 又是以 python 这个用户身份 来执行的 这就是实际工作中切换 用户的实际场景 su不使用 【 - 】首先使用 whoami 查看当前用户信息，然后输入 su 命令 切换用户 可以看到终端中的显示 变化了，现在的显示是 zhangsan 并且 zhangsan 所在的位置 是 python 用户的家目录，我们可以使用 cd 返回 zhangsan 的家目录，并且使用 pwd 查看当前 的 工作目录 操作完成后，输入 exit 返回到 python 用户，并且使用 pwd 来进行确认 使用 【 - 】接下来在使用 su 命令时，使用 【 - 】 看看有什么效果 可以看到这一次的显示于 上面 没有使用 【 - 】 的显示 是不一样的，刚刚没有使用 【 - 】 ，我们切换到 zhangsan 用户之后，所在的目录 还是在 python 用户的家目录； 而现在使用了 【 - 】，切换用户时，工作目录也会变为 zhangsan 的家目录 不接用户名su 除了可以切换到其他用户外，如果我们在 su 中不接任何用户名，就可以切换到 root 身份，但是 root 对系统的所有资源都是有完全权限的，所以切换到 root 身份 执行终端命令是不推荐使用的，因为这种方式非常的不安全 可以看到，终端中的显示发生变化了，现在的用户叫做 root，同时前面有一个 【 ~ 】 ，并且当前所在的位置是在 /root 注意： 此时我们输入一些系统维护和管理的命令，就不需要输入 sudo。 eg： 可以看到回车之后就直接执行完成了，我们使用 cat 命令 查询 passwd 文件 确认是否添加成功 可以看到， zhaoliu 这个用户已经被添加上了 exit再切换用户之后，我们在输入的 exit，只是返回到上一级用户，如果 在 python 用户再敲一次 exit，就会退出终端 修改文件权限 命令 作用 chown 修改拥有者 chgrp 修改组 chmod 修改权限 这三个终端命令 分别对应着 ls -l 文件目录详细信息命令 的 三个列 命令格式如下： 修改文件|目录的拥有者 chown 用户名 文件名|目录名 递归修改文件|目录的组 chgrp -R 组名 文件名|目录名 递归修改文件权限 chmod -R 775 文件名|目录名 -R 表示递归修改目录下的所有子目录以及文件的组 chown修改 Python学习 目录的拥有者 可以看到 目录 的拥有者 变成了 zhangsan ，而目录所属组为 dev 并且我们可以知道 python 并不属于 dev组 ，我们可以使用 id命令 来确认 显示 用户的 组并没有 dev组，所以 python用户 对 Python学习 组 应该具有 其他用户的权限，可以看到 其他用户的权限 只有可读可执行，没有写操作， 即 python用户 就不能再对目录有写权限了，应为该目录的拥有者 是 zhangsan chgrp接下来修改 Python学习 目录的组 可以看到现在用户所属组变成了 python，而当前用户的 python 它的主组就是python，而 组用户对这个目录具有 可读可写可执行 权限，因此当我们修改了这个目录所属组之后，上面的小锁头就没有了 chmod 扩展 递归修改文件权限 chmod -R 775 文件名|目录名 7表示文件或者目录 拥有者 的权限 5表示文件或者目录 组成员 的权限 5表示文件或者目录 其他用户 的权限 chmod 再设置权限时，可以简单的使用三个数字分别对应 拥有者/组 和 其他 用户的权限 另一种方法： 直接修改文件|目录的 读|写|执行 权限，但是 不能精确到 拥有者|组|其他 chmod +/-rwx 文件名|目录名 数字对应的权限文件或者目录一共拥有三个权限 可读 、可写 、可执行,在要得到最终的数字结果之前，我们先把这三个权限进行 数字编号： 可读权限 数字代号 4 可写权限 数字代号 2 可执行权限 数字代号 1 eg： 如果我们想给用户设置 可读可写可执行权限 即 4+2+1 = 7 ; 如果我们享给用户具有 可读可写权限 即 4+2 = 6 ，如果不设置可执行权限 那么可执行权限对应的数字就是 0； 这三个权限分别用一个 数字代表，如果想指定的权限，我们就把数字写上，如果不想指定权限，我们就用 0 来设置，这三个数字相加的结果，就是我们在使用 chmod命令 时，其中一个数字的结果，如下表： 常用的数字组合有（ u 表示用户/ g 表示组/ o 表示其他） 777 ===> u = rwx , g = rwx , o = rwx 755 ===> u = rwx , g = rx , o = rx 644 ===> u = rw , g = r , o = r chmod 演练目标 使用 chmod数字表示法，只需要使用三个简单的数字，就可以精准的设定不同用户对文件的权限 将 01.py 的权限修改为 u = rwx , g = rx , o = r ，即 754 首先使用 ls -l 命令 检查 01.py 的权限，可以看到 01.py 这个文件的拥有者为 可读可写可执行，组用户为 可读可写可执行，其他用户为 可读可执行 接下来使用 chmod数字表示法 修改 文件权限，并且使用 ls -l 检查权限是否修改正确，可以看到已经成功修改: 将 123.txt 的权限修改为 u = rw , g = r , o = - ， 即 640 首先使用 ls -l 查看 该文件详细信息 使用 chmod数字表示法 并且 使用 ls -l 确认文件权限是否修改成功 将 test 目录以及目录下得 所有文件 修改为 u = rwx , g = rwx , o = rx ，即 775 当我们想修改一个目录下所有文件的权限时，就可以使用 【 -R 】 选项，即可以 以递归的方式把这个目录下的 所有文件 以及 子目录 下的 权限一次性修改 使用 chmod数字表示法 修改 目录权限，接着使用 ls -l 确认，可以看到修改成功 接下来使用 ls -l 查看 test 目录下的文件权限是否一并被修改，可以看到 test 目录下有个 01.py文件，它的权限同样变成了 775","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"从零开始的Python学习","slug":"从零开始的Python学习","permalink":"http://yoursite.com/tags/从零开始的Python学习/"}]},{"title":"警告框","slug":"Bootstrap/警告框","date":"2019-05-02T11:31:24.000Z","updated":"2019-05-02T12:20:45.343Z","comments":true,"path":"2019/05/02/Bootstrap/警告框/","link":"","permalink":"http://yoursite.com/2019/05/02/Bootstrap/警告框/","excerpt":"","text":"警告框警告框的使用是非常普遍的，我们会通过一些灵活的预定义消息，来给用户提供一些消息的反馈，这样有利于用户的体验 默认样式12345 Hello 大家好！ 在这里我们可以看到没有任何效果，是因为 Bootstrap 给我们定义了几种效果 效果如下： success info warning danger 1234567891011121314 Hello 大家好！ Hello 大家好！ Hello 大家好！ Hello 大家好！ 这就是警告框不同样式的呈现 可关闭样式因为我们这个框不是一直存在这里的，如果我们看完了可能要关闭掉它 12345678 & times; 欢迎来到极客学院！ 可以看到后面出现了一个 叉，点击消失。 注意： 添加 【 data-dismiss=”alert” 】 的原因是，我们需要添加并且跟按钮打上关系，也就是说它就是一个可操作可关闭的状态，当按钮关闭时，它也会关闭掉 超链接事实上，我们看到的警告框可能会是这么一个元素，文字可能会是一些超链接，可以点击。 因为它有可能是一个提示，提示说你要去哪里，去怎样做才能把当前这个警告去除掉，那肯定会涉及到超链接 12345678 如有问题请到 极客学院 可以看到，极客学院明显是加粗的，当鼠标移动到上面的时候，他会出现一个手势以及一个下划线，当点击之后它会跳转到另外一个页面。这是带超链接的警告框，也是经常使用到的","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"页头与缩略图","slug":"Bootstrap/页头与缩略图","date":"2019-05-02T10:02:11.000Z","updated":"2019-05-02T11:26:59.847Z","comments":true,"path":"2019/05/02/Bootstrap/页头与缩略图/","link":"","permalink":"http://yoursite.com/2019/05/02/Bootstrap/页头与缩略图/","excerpt":"","text":"页头页头一般位于 页面内部 的内容进行 隔开，所以其实我们会画一些线或者以一些其他的方式进行隔开，那Bootstrap也给我们提供了一个比较好用的方式 123 极客学院欢迎您 可以看到有一条很明显的线用于隔开，下面是页面的主题内容，这就是页头的主题设计。 当然我们可以在页头嵌入很多东西，根据页面的需求来进行嵌入，我们唯一看到的好处就是这条 线 ，不需要我们自己去实现，它已经给我们包含在里面了 缩略图缩略图有两种： 一种是默认的，只显示一张图片 另外一种是自定义内容的，也就意味着在当前的图片下面、上面、左面或者右面包含当前的一个图片，它会呈现一个带有文字带有其他内容的 自定义效果 默认1234567 可以看到，它会有一个圆角的外边框，当鼠标掠过，它会有一个颜色的改变 自定义自定义的内容 只是比默认的内容多一些文字性的描述 123456789101112 这是一个美女哦 我知道你们都是喜欢看美女的。因为，美女养眼啊！！！ 不好看选我哦 这里只是单纯的定义一个 标题，还有一些具体内容以及两个按钮，当然可以根据自己的需求来实现这个效果；在之前的课程当中，专门为了这样一个承载图片和内容的一个框，来做一个 Css 的的定义； 那么在 Bootstrap中我们可以发现，这需要简单的几行 HTML 代码就可以实现这样一个效果，而且实现起来非常方便，并且样式的调整都是非常好的","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"远程管理常用命令","slug":"Linux/Linux基础-Ubuntu/远程管理常用命令","date":"2019-05-02T03:06:16.000Z","updated":"2019-05-03T09:16:49.609Z","comments":true,"path":"2019/05/02/Linux/Linux基础-Ubuntu/远程管理常用命令/","link":"","permalink":"http://yoursite.com/2019/05/02/Linux/Linux基础-Ubuntu/远程管理常用命令/","excerpt":"","text":"目标 关键/重启 shutdown 查看或配置网卡信息 ifconfig ping 远程登录和复制文件 ssh scp 关机/重启 序号 命令 对应英文 作用 1 shutdown 选项 时间 shutdown 关机/重新启动 shutdown shutdown 命令可以 安全关闭 或者 重新启动系统 选项 含义 -r 重新启动 注意： 不指定选项和参数 ，默认表示 1分钟 之后关闭电脑 远程维护服务器时，最好不要关闭系统，而应该 重新启动系统（当我们通过 SSH 登录到服务器，就可以进行日常的维护管理，但是如果我们通过终端命令，关掉了计算机，就得专门叫人去机房开启电脑，相当麻烦 ） 常用命令示例 重新启动操作系统，其中 now 表示现在： shutdown -r now 立刻关机，其中 now 表示现在 : shutdown now 系统在今天的 20:25 会关机 ： shutdown 20:25 系统再过10分钟后自动关机 ： shutdown +10 取消之前指定的关机计划 ： shutdown -c 关机shutdown 不指定任何选项和参数时，默认为 1分钟后自动关机 取消关机命令 重新启动如果想立刻启动，可以输入 now 表示现在 查看或配置网卡信息 序号 命令 对应英文 作用 1 ifconfig configure a network interface 查看/配置计算机当前的网卡配置信息 2 ping ip地址 ping 检测到目标IP地址的链接是否正常 网卡和IP地址网卡 网卡是一个专门负责网络通讯的硬件设备 IP地址是设置在网卡上的地址信息 我们可以把 电脑 比作 电话，网卡 相当于 SIM卡，IP地址 相当于 电话号码 IP地址 每台互联网的电脑上都有 IP地址，是保证电脑之间正常通信的重要设置 注意： 每台电脑的 IP地址 不能相同，否至会出现 IP地址 冲突，并且没有办法正常通讯 ifconfig ifconfig 查看/配置计算机当前的网卡配置信息 基本用法： 查看网卡配置信息： ifconfig 查看网卡对应的 IP地址 ： ifconfig | grep inet 在使用的时候，并不需要太关心网卡的名称叫什么，因为网卡的名称只是一个标注而已，在我们查看网卡信息的时候，我们最关心的，实际上是网卡上设置的 IP地址 提示： 一台计算机中有可能会有一个 物理网卡 和 多个虚拟网卡，在 Linux 中物理网卡的名字通常以 ensXX 表示 注意： 127.0.0.1 这个地址又被叫做 本地环回地址，是专门用来测试网卡是否正常工作的 过滤信息由于输出的信息有点多，那么我们怎样快速获得想要的信息呢？ 那么我们可以使用 管道 来过滤信息，来找出有用的信息 inet6地址: inet6 对应的地址，是 ipv6的地址。 而没有 6 的，对应的是 ipv4 的地址 ping 检测到目标主机是否连接正常： ping IP地址 检测本地网卡工作正常： ping 127.0.0.1 ping 一般用于检测当前计算机到目标计算机之间的网络 是否通畅、 数字越大、速度越慢 ping 的工作原理与潜水艇的声呐相似，ping 这个命令就是取自 声呐的声音 网络管理员之间也常将 ping 用作动词 – ping一下计算机X，看它是否开着 原理： 网络上的机器都有 唯一确定的IP地址，我们给 目标IP地址 发送一个数据包，对方就要返回一个数据包，根据返回的数据包以及时间，我们可以确定目标主机的存在 提示： 在 Linux 中，想要终止一个终端程序的执行，绝大多数可以使用 CTRL + C ping IP地址 可以看到回车之后，终端会一行一行地显示信息，而且这个命令 不会停下来，接下来我们就可以按下 CTRL + C 这个热键来停止命令 在按下 CTRL + C 的瞬间， ping 的命令执行就停了下来，同时在下方就会显示一个简单的统计信息，告诉我们发送了多少个数据包，每个数据包的 最小时间、 平均时间以及 最大时间 等等 当我们输入 错误的地址或者格式 时： 我们可以看到这一次在执行的时候，ping命令 会告诉我们： 在尝试连接到 130 这个电脑的时候，会告诉我们 目标主机无法到达，这个提示就告诉我们 130 这个电脑和我们 Ubuntu 这个电脑之间并没有正确的网络链接； 这就是在使用 ping命令 时，如果无法正常的链接到目标主机，我们会看到的一个 非常常见的提示信息 工作原理： 现在我们在 Ubuntu 的电脑上发送一个 ping 的命令给 Windows XP,我们执行 ping 之后，会发送 56 个字节 给目标主机，目标的主机接收到数据包之后，会给我们一个反向的回执，回执的数据包的大小是 64个字节 ，也就是我们从 Ubuntu 发送了 56个字节 个 XP，XP 给我们回了一个 64字节 大小的数据包，当这个数据包到达 Ubuntu 电脑之后，Ubuntu 会检测这一次数据来回使用的时间，时间越小，就说明网速越快； 这个世界越大，就说明网速越慢 检测本地网卡 如果使用 ping 来 ping 127.0.0.1，可以看到正常的 回馈时间，就说明本地网卡的工作是正常的 远程登录和复制文件 序号 命令 对应英文 作用 1 ssh 用户名@ip secure shell 关机/重新启动 2 scp 用户名@ip:文件名或路径 用户名@ip:文件名或路径 secure copy 远程复制文件 ssh基础（重点）在 Linux 中 SSH 是 非常常用 的工具，通过 SSH客户端 我可以链接到运行了 SSH服务器 的远程机器上 SSH客户端 是一种使用 Secure Shell （SSH）协议链接到远程计算机的软件程序 SSH 是目前较可靠，专为远程登录回话和其他网络服务 提供安全性的协议 利用 SSH协议 可以有效防止远程管理过程中的信息泄露 通过 SSH协议 可以对所有传输的数据进行加密，也能够防止 DNS欺骗 和 IP欺骗 SSH 的另一项优点是传输的数据可以是经过 压缩 的，所以可以加快传输的速度 我们在 Ubuntu 也好，Mac 也好，SSH的服务器 和 SSH的客户端 都是默认安装的，只有在 Windows电脑下，我们才需要单独的安装一个 SSH的客户端，所以在 Windows 下，我们需要安装一个软件，才能实现日常的维护和管理工作 域名和端口号（科普）域名 由一串 用点分隔 的名字组成，例如： www.itcast.cn 是 IP地址 得别名，方便用户记忆 ping命令 也可以接收域名 端口号 IP地址：通过 IP地址 找到网络上的计算机 端口号：通过 端口号 可以找到计算机上运行的应用程序 SSH服务器 的： 默认端口号是 22，如果是默认端口号，在链接的时候，可以省略 什么是端口号、端口号的作用？ 浏览器输入了 IP地址，就可以找到百度的服务器，找到服务器后，服务器就会把百度的首页 传送给客户端，这样我们在客户端就可以看到百度的页面了。 但是我们找到了服务器是不是就是一个电脑，那么这个电脑又凭什么会把百度的首页返回给我 们，而不会把新浪的首页返回给我们？ 这个原因是在百度的服务器上，安装有一个服务器的软件，这个服务器的软件，通常我们管它叫做 Web服务器，这个 Web服务器 就是专门提供给用户浏览器访问内容的； 注意： 这个就是浏览器的软件，当我们输入地址找到这个机器之后，实际上光有地址是不够的，我们首先要输入一个 IP地址，这个 地址可以确保我们找到这台计算机，然后在地址后面接一个冒号，冒号后面接一个数字，即 端口号，这个数字就表示着 通过这个数字需要找到服务器上的 Web服务器的软件 ，由这个软件，来给用户提供要访问看到的内容，这才是真正服务器访问的结果 常见的默认端口号列表： 序号 服务 端口号 1 SSH服务器 22 2 Web服务器 80 3 HTTPS 443 4 FTP服务器 21 如果我们访问服务器的时候没有指定端口，那么浏览器就自动使用默认端口 SSH客户端的简单应用ssh [-p port] user@remote user 是在远程机器上的用户名，如果不指定的话默认为当前用户 remote 是远程机器的地址，可以是 IP/域名，或者是 后面会提到的别名 port 是 SSH Server监听的端口，如果不指定，就默认值 22 提示： 使用 exit 退出当前用户的登录 注意： ssh 这个终端命令只能在 Linux 或者 UNIX 系统下使用如果在 Windows 系统中，可以按照 Putty 或者 XShell 客户端软件即可 提示： 在工作中，SSH服务器的端口号很有可能不是 22，，如果遇到这种情况就需要使用 -p 选项，指定正确的端口号，否则无法正常连接到服务器 Mac连接UbuntuMac操作系统 是基于 Unix ，所以在 Ubuntu 中的操作命令 在Mac中几乎都是可以使用的 首先输入 ssh 命令 如果忘记了 Ubuntu 的 IP地址，可以在 Ubuntu 输入 ifconfig 查看 注意： 当我们第一次在电脑中 连接 另外一台电脑的时候，终端会给我们提示一个授权的信息，输入 yes 即可： 接下来要求输入 Ubuntu 下 用户的密码（输入的时候密码是隐藏的）： 输入完成后可以看到，提示框变成了 Ubuntu 下用户的用户名： 接下来我们就可以远程操控 Ubuntu ，进行各种操作了： 可以看到，虽然我们是在 Mac终端，但是整个对 Ubuntu 的操作，跟之前在 Ubuntu 中的操作没有任何区别 结论： 通过这个演示我们可以发现，有了 ssh， 我们就可以远程登录任何一台支持 ssh的服务器，然后通过终端命令，对服务器进行管理 注意：如果我们把远程地址设置成我们 同桌 的IP地址，然后如果我们同桌又没有修改 python 的密码，那我们就可能可以做一些 恶作剧eg： 我们可以重启他的计算机 shutdown -r now，但是: 这时 终端告诉我们 权限不够，那怎么办呢？ 我们可以在 shutdown 前面加一个 sudo 表示用超级用户的权限来执行关机的命令，接下来就会要求我们输入密码： 可以看到，我们成功的将 Ubuntu 进行了重启 Windows连接Ubuntu下面是 Windows 两款非常常用的 ssh 客户端 的安装课程，一个是 Putty ，另外一个是 XShell Putty: http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html XShell: http://xshellcn.com 这两款软件都是可以免费使用的，因此最好从 官网 上直接下载。 不要从其他下载渠道下载，因为从其他下载 渠道 下载获得的软件，有可能会下载到被其他黑客已经修改过的程序，那样安装之后可能会带来不必要的麻烦 Putty安装安装时候注意，要选择 安装桌面上的快捷方式 ： 安装完成，打开窗口我们会看到，在弹出窗口中，会要求我们输入一些信息： 这里要求我们输入 主机名称 或者 IP地址 ，端口号默认是 22，我们可以不做修改： 接下来选择 连接类型，选择 SSH： 使用 下面填写入 Ubuntu 的 IP地址，点击 open： 注意： 如果连接失败，请查看 IP地址是否正确， 或者 Ubuntu 中是否安装了 SSH服务 接下来输入登陆的用户名和密码： 登录成功我们可以看到提示信息变成了 Ubuntu 下的用户名： 接下来就可以对 Ubuntu操作系统 进行远程操作了： 注意： 如果我们像断开远程终端的链接，我们可以敲入 exit Xshell安装注意： 在官网下载好 Xshell5 后，点击安装，注意一定要选择 免费为家庭或者学校； 如果选择 商业 我们就要输入序列号了，而选择 免费 我们就不需要输入序列号了，而且功能和 商业 上的功能是完全一样的 安装完成，界面如下： 使用在工具栏可以修改语言为中文： 在回话窗口中点击新建： 我们可以看到再弹出的窗口中有一个新建会话，输入主机地址，其他保持不变，点击连接： 接下来要求我们输入用户名，我们输入 Ubuntu 中的用户名即可： 确定之后输入密码： 输入之后可以看到，提示信息变成了 Ubuntu 下的信息，表示链接成功： 接下来就可以对 Ubuntu 进行远程操作了： 而且 Xshell 的显示界面要比 puTTy 的显示界面要漂亮很多，操作完毕后，按下 exit 退出： scp（掌握） scp 就是 secure copy ，是一个在 Linux 下用来进行 远程拷贝文件的命令 它的地址格式与 ssh 基本相同，需要注意的是，在指定端口时用的是大写的 -P 而不是小写的 选项 含义 -r 若给出的源文件是目录文件，则scp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 -p 若远程 SSH服务器 的端口不是22，需要使用大写字母 -P选项 指定端口 scp的命令格式传输文件把本地目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py注意 ： 【 ： 】 后面的陆军如果不是绝对路径，则以用户的家目录作为参照路径 scp -P port 01.py user@remote:Desktop/01.py 把远程 家目录下的 Desktop/01.py 文件 复制到 本地 当前目录下的 01.py scp -P port user@remote:Desktop/01.py 01.py 传输文件夹加上 -r 选项 可以传送文件夹 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktop scp -r demo user@remote:Desktop 把远程 家目录下的 Desktop 复制到 本地 目录下的 demo 文件夹 scp -r user@remote:Desktop dem secure copy首先在客户端 远程登陆 Ubuntu 服务器，并且查看 Ubuntu 的桌面文件，由于下面使用 Ubuntu 作为客户端，所以可以直接使用 scp 命令进行操作 Mac由于 Mac 与 Ubuntu 的操作相同，这里可以使用 Ubuntu 的操作系统代替 Mac 发送文件客户端复制服务器文件到本地（接收）下面查看本地文件： 接下来使用 scp 将 远程服务器的文件 复制到 客户端 ： 可以看到 a.py 文件已经复制到了 客户端 的桌面上，我们可以打开并且进行编辑： 复制客户端文件到服务器（发送）输入 scp 命令： 在 服务器 中查看 a.py，可以看到文件已经被替换： 发送文件夹 在原来的命令中 添加 -r 选项即可 客户端复制服务器文件夹到本地（接收） 可以看到一堆文件的显示，同时桌面上显示了 Desktop文件夹，可以看到现在桌面上的文件已经文件中的内容和 服务器中的文件夹的内容是一致的 Windows介绍在 Windows操作系统中，怎样跟 Linux操作系统 进行文件传输 注意 ： scp 这个终端命令只能在 Linux 或者 UNIX 系统下使用 如果在 Windows系统中，我们可以安装 PuTTY，使用 pscp 命令行工具进行安装 FileZilla 使用 FTP 进行文件传输 跟我们之前学习的 ssh是一样的，windows中，并不能直接使用 scp 这个终端命令，而且在 windows 中使用 scp这个终端命令，也不是很方便。 因此在日常工作中，如果使用的是 windows 操作系统，绝大多数会换另外一种方式，跟 Linux 进行文件交换。 这种方式叫做 FTP（文件传输协议），在 Windows 中，有个非常方便的图形化软件 FileZilla 可以帮我们使用 FTP 这种文件传输方式，在 Windows操作系统 和 Linux服务器 之间进行文件交换 FileZilla FileZilla 官方网址： https://www.filezilla.cn/download/client FileZilla 在传输文件时，使用的是 FTP服务 而不是 SSH服务，因此端口号应该设置为 21 安装完 FileZilla 后，进入界面，我们先把注意力放在 FileZilla 的上方， 在使用远程服务器，我们有 4 项内容需要注意： 远程服务器的 IP 地址 远程服务器的用户名 用户的密码 端口（ssh的端口是 22； 但是，在 Windows 下，我们会使用另外一种服务： FTP，来实现文件传输，它使用的 端口号是 21） 注意： 如果无法连接，请查看 Ubuntu 是否安装了 ftp服务 点击 快速连接，我们可以看到右下方出现了 Ubuntu上相同的目录，表示链接成功： 接下来，只要将 服务器对应的文件（左） 拖拽 到本地文件（右） 中，就实现了远程传输 总结： 这就是在 Windows 使用 FileZilla 这个软件跟 Linux 操作系统文件传输的一个演示，这里我们需要注意，使用 FileZilla 时，端口号务必要设置成 21 SSH高级（知道）有个这两项内容在今后工作中使用频率并不是很高，因为等我们走上工作岗位之后，这两项设置通常我们只需要设置一次就 ok 了，后续的工作都是基于这两项配置的基础上展开的 免密码登陆 配置别名 提示： 有关 SSH 配置信息 都保存在用户家目录下的 .ssh目录 下 注意： 【 . 】 表示隐藏目录，我们可以 使用 ls -alh 查看所有文件： .ssh目录 .ssh目录 保存 SSH 相关的所有配置信息 known_hosts： 保存已知的主机文件，当我们第一次链接一个陌生的主机时，系统会提示我们是否授权，一旦授权之后，这个链接主机的信息就会保存到 known_hosts ，那么下一次再使用 SSH 链接时，就不会提示我们授权了 known_hosts 文件首先进入 .ssh文件夹 ，查看当前文件 接下来，使用服务器 链接 客户端： 查看客户端的文件信息： 操作完成后，按 exit 退出即可： 现在再来查看 服务器的 .ssh目录下的文件： 可以看到出现了一个 known_hosts 文件，这个文件，我们可以使用 cat 命令查看一下该文件的内容： 可以看到，这就是一个文本文件，这个文本文件，这个文件记录了在第一次连接这个主机的时候，提示我们的一个授权信息，一旦这个授权信息我们输入了 Yes 之后，那么这个主机地址的信息就会保存在 known_hosts，保存到文件中之后，当我们下一次再使用 ssh 连接这个主机的时候，就不会再有这个提示了 eg：尝试再次连接 客户端 可以看到，直接让我们输入密码，没有提示授权信息了 免密码登陆我们使用 ssh 或者 scp，都可以直接使用，而不再需要输入密码 步骤 配置公钥 执行 ssh-keygen 即可生成 SSH 钥匙，一路回车即可 上传公钥到服务器 执行 ssh-copy-id -p port user@remote，可以让远程计算机记住我们的公钥 ssh-keygen首先查看 .ssh文件中的内容，可以看到里面只有 know_hosts文件 : 这个命令会生成两个加密使用的文件，而这两个加密使用的文件，同样会保存在 .ssh目录 下，同时再执行这个终端命令的时候，会有一系列的提示，只需要一路回车就可以 再次使用 查看 目录中的文件，这时可以看到，目录中多了两个文件 ： 经过三次回车之后我们可以看到，在 .ssh目录下，出现了两个文件，这两个文件就是我们在远程登录时，用来 加密使用的文件 接下来，用一个终端命令，把服务器上的 id_rsa.pub 传递到 客户端 的 【 .ssh目录 】 中。 .ssh目录 是用来保存 ssh配置信息 的 ssh-copy-id让远程计算机记住我们的公钥 可以看到，回车之后，终端会提示我们添加了一段 密钥，这个密钥就 拷贝到了 客户端的 .ssh目录 中： 打开该文件我们可以看到： 这个文件的末尾有一个 python@ubuntu，这个就是 服务器 的用户名。并且这个文件的内容与 服务器中 id_rsa.pub文件 的内容是相同的 最后，再次测试 远程登录是否需要密码： 可以看到，回车之后，直接就直接登录上 客户端，不需要再次输入密码 总结：我们只需要在终端中执行这两个终端命令。 第一个终端生成 加密文件； 第二个终端命令输入后，把我们生成的加密文件，复制到远程计算机中，用户的 .ssh 文件下，并且追加到授权文件中，经过这两个设置后，再链接远程服务器都不再需要使用密码了 免密码登录工作原理 要设置免密码登录： 第一步：设置 ssh-keygen 命令，这个命令生成两个文件 id_rsa.pub（公钥） ：公共加密的钥匙 id-rsa（私钥）：私用加密的钥匙 非对称加密算法（加密和解密使用的钥匙是不同的）： 使用 公钥 加密的数据，需要使用 私钥 解密 使用 私钥 加密的数据，需要使用 公钥 解密 第二步：使用 ssh-copy-id 把 公钥 文件复制到服务器，在客户端有一个私钥的密钥，现在 公钥 在服务器，私钥 在本地。 网络传输数据加密： 如果我们要把客户端发送到服务器，那么首先在客户端，会对要发送的数据，使用 私钥 进行加密，之后将加密之后的数据通过网络 传输给服务器； 服务器接受到 加密的数据，就要进行 解密。 这时就可以 使用我们传输过来的 公钥 来进行解密。 服务器使用公钥解密之后，就可以知道这一段数据中 存储的真实内容。服务器在处理完之后，要给客户端回传数据，当服务器想给客户端回传数据时，同样会对数据 进行加密，这时服务器会使用 公钥对数据进行加密，加密完成之后，才会通过网络发送给客户端，而客户端接收到数据之后，因为是公钥加密的，所以客户端就直接使用 私钥 解密，解密之后，客户端就可以知道 接受的数据保存的真实内容 第三部：这样就可以保证在网络上传输的所有数据都是加密的，既然已经保证了数据是加密的，因此就不再需要额外的输入用户的密码，这就是免密码输入的工作原理 别名每次都输入 ssh -p port user@remote ，时间久了会觉得很麻烦，特别是 user，remote 和 port 都得输入，而且还不好记忆 而 配置别名 可以让我们进一步偷懒，譬如用： ssh mac 来代替上面这么一长串，那么就在 ~/.ssh/config 里面追加一下内容 保存之后，即可用 ssh mac 实现远程登陆了，scp同样可以使用 创建config文件先查看 .ssh目录，然后在该目录下创建 config文件： 如果在 终端中想打开某个文件，就可以输入 【 gedit 文件名 】 打开，eg： 配置信息 第一行：设置主机的别名第二行：设置远程计算机的IP地址第三行：用户名第四行：端口号 ssh 别名输入 ssh myserver 验证 配置别名 是否成功： 成功的 链接到 远程的计算机： 有了 别名之后我们在想要登录到远程计算机，就非常容易了，不再需要输入用户名、 IP地址 以及端口 scp 别名接下来要将 服务器 的桌面文件夹的内容 ，复制到 客户端的桌面文件夹下。（注意：添加 -r 选项）： 注意：别名之后需要 【 ：目录 】 可以看到复制的过程，表示成功复制到 客户端 总结： 设置了别名之后，使用 scp 、ssh 命令都变得非常简单了。 设置了 别名之后，命令格式已经和 cp 的命令格式非常相似了，要复制一个文件夹，就指定一个 -r 的选项，然后指定源文件的目录，再通过别名指向 远程计算机上要复制的目标文件夹 的名字 就可以了","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"从零开始的Python学习","slug":"从零开始的Python学习","permalink":"http://yoursite.com/tags/从零开始的Python学习/"}]},{"title":"徽章与巨幕","slug":"Bootstrap/徽章与巨幕","date":"2019-05-01T10:54:00.000Z","updated":"2019-05-01T11:59:02.921Z","comments":true,"path":"2019/05/01/Bootstrap/徽章与巨幕/","link":"","permalink":"http://yoursite.com/2019/05/01/Bootstrap/徽章与巨幕/","excerpt":"","text":"徽章普通样式徽章在手机端比较常见，比如：信息的个数提示，以及交流或者语言框提示的消息的数量 123 短信消息30 可以看到短信消息后面有提示，30可能这一种看起来不太美观，接下来介绍一种美观的效果 按钮样式123 Messages 100 这就是徽章的效果，可能在 IE8 不被支持，所以使用的时候多注意些细节 表格样式那么它能不能放入 table 中呢？ 12345 Home 10 Profile 100 Message 5 可以看到其实这是一个列表组 巨幕登录一些网页经常会看到在网页上会有一个很大的标题。 这就是一块巨幕，整体非常大，摆在首页以及其他显眼的地方，用来展示重要的信息 12345 Hello,world 欢迎来到我的博客，希望您能在这学到更多知识，丰富自己，提示自己 learn more 我们可以看到 hello，world 以及 p 标签承载的元素 和可点击的按钮选项都已经存在了，只不过有点难看。所以我们对它进行调整： 我们用一种简单的方式，把当前所有的展示内容 除了巨幕 全部承载在一个容器当中，那么这个容器肯定是 Container类 1234567 Hello,world 欢迎来到我的博客，希望您能在这学到更多知识，丰富自己，提示自己 learn more 看起来好多了！！ 我们还可以用其他的方式来调整，比如居中、居右 等 都是可以的，只需要覆盖 Bootstrap 默认效果即可","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"分页与标签","slug":"Bootstrap/分页与标签","date":"2019-05-01T08:20:23.000Z","updated":"2019-05-01T09:18:10.434Z","comments":true,"path":"2019/05/01/Bootstrap/分页与标签/","link":"","permalink":"http://yoursite.com/2019/05/01/Bootstrap/分页与标签/","excerpt":"","text":"分页是我们在应用当中非常常见的，在一些类似于问答区、文章等 会存在分页，当内容过多，一个页面无法展示的时候，分页的功能就会被提上日程 分页引导功能1234567891011 & laquo; 1 2 3 4 5 & raquo; 可以看到一个向前和向后的两个标识，以及 数字 禁用效果在 前、后 按钮中给一个不可点击效果即可 1234567891011 & laquo; 1 2 3 4 5 & raquo; 当鼠标移动到 被禁用的按钮上，我们可以看见，它是不可点击的，因为当前在第一页 自适应尺寸Bootstrap 既然是响应式布局，那么它就有尺寸的分配 1234567891011121314151617181920212223242526272829303132333435 & laquo; 1 2 3 4 5 & raquo; & laquo; 1 2 3 4 5 & raquo; & laquo; 1 2 3 4 5 & raquo; 我们可以看到，大的、默认的、最小的，它们分别适应于 显示器、pad 以及 手机屏幕 翻页效果普通效果有的时候我们的页数没有那么多，单纯的一个翻页效果即可，在这个时候，我们可以给他们添加一个翻页的效果 123456 下一页 上一页 我们可以看到 上一页、下一页，而且是一种居中的效果 另一种效果有时候，这种效果并不能满足我们，我们需要一个箭头有更明确的指示 123456 & larr;向前 & rarr;向后 可以看到两个 按键 分别位于窗口的两边 标签我们也可以称它为标识，以程序的角度来说，我们更喜欢标识这种称呼。 我们在一些网站上经常看到不同颜色，或者是 按钮 来表示当前是一个怎样的 状态。 比如： 我们在程序调试的时候，红色一般表示错误、 黄色是警告、 蓝色是信息、 绿色是成功 等等.. 123456默认默认默认默认默认默认 一般很多标识会放在 标题 的后面，有的也会否承载在标题当中进行使用。 eg： 1这是一个主标题这是关于标题的描述 可以看到它随着标题默认变大","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"Well","slug":"Bootstrap/Well","date":"2019-04-30T12:08:29.000Z","updated":"2019-04-30T12:40:02.391Z","comments":true,"path":"2019/04/30/Bootstrap/Well/","link":"","permalink":"http://yoursite.com/2019/04/30/Bootstrap/Well/","excerpt":"","text":"概要 具有响应式特性的嵌入内容 Well 具有响应式特性的嵌入内容根据嵌入的内容，我们可以给它指定一个容器，那么这个容器也会自动的去创建一个固定的 比，我们不叫常见的可能有 16 : 9 、 4 : 3 。那么我们可以使用这两种 比 来进行实现 它适用于 < iframe> 、 < embed> 、 < video> 、< object> 注意： 我们在使用 iframe 的时候，不需要使用边框，因为它本身就已经存在了 12345 我们可以看到整个的页面，因为它是 16 : 9 ，所以两边是空白的。 当我们把当前页面进行缩小的时候，可以看到他的比例也在相应的缩小，即它是 响应式 的 wellwell 的使用比较简单，把 well 用在元素上，能有 嵌入 的简单效果 12345 Look,i'm in a well. 可以看到，这是一个 well 的默认效果，它还给我们提供了适应不通种分辨率的类，默认是适应正常的屏幕，lg 是大的、 sm 是小的 12345 Look,i'm in a well. 可以看到它变小了，我们可以根据需求的不同，来进行相应的调整","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"面板","slug":"Bootstrap/面板","date":"2019-04-30T11:14:37.000Z","updated":"2019-04-30T12:05:55.546Z","comments":true,"path":"2019/04/30/Bootstrap/面板/","link":"","permalink":"http://yoursite.com/2019/04/30/Bootstrap/面板/","excerpt":"","text":"面板类别 基本的实现 带标题的面板 情景效果 带表格的面板 含有列表面板 虽然面板不是每一次都会使用到，但是有的时候需要在将一些盒子包含在盒子当中，对于这种情况我们可以尝试使用面板 基本的实现12345 hello World! 我们看到，表现出来的效果并不是很好看，是因为我们在当前的 div 中并没有承载当前要显示的盒子的内容，所以接下来在 面板 中再创建一个div： 1234567 hello World! 带标题的面板12345678910111213 学习网站 希望你能来我的博客，我永远欢迎你 希望你能来我的博客，我永远欢迎你 希望你能来我的博客，我永远欢迎你 希望你能来我的博客，我永远欢迎你 可以看到题目有背景加深的效果，下方是具体的内容 有的时候不单单会带标题，有可能会带脚注，下方也希望有一个备注 12345678910111213141516 学习网站 希望你能来我的博客，我永远欢迎你 希望你能来我的博客，我永远欢迎你 希望你能来我的博客，我永远欢迎你 希望你能来我的博客，我永远欢迎你 blog.yz0.top 我们可以看到一个带脚备注的面板 情景效果我们要根据不同的需求来提供不通种的情景效果，更改 panel-default 即可，eg: 12345678910111213141516 学习网站 希望你能来我的博客，我永远欢迎你 希望你能来我的博客，我永远欢迎你 希望你能来我的博客，我永远欢迎你 希望你能来我的博客，我永远欢迎你 blog.yz0.top 可以看到了头部和底部的颜色发生了编号 带表格的面板1234567891011121314151617181920212223242526272829303132333435363738394041 表格面板 以下是表格面板演示 表格标题 表格标题 表格标题 表格单元格 表格单元格 表格单元格 表格单元格 表格单元格 表格单元格 表格单元格 表格单元格 表格单元格 表格单元格 表格单元格 表格单元格 可以看到，在文字内容 下方多添加了一个表格，当然可以根据需要对 颜色 或者 内容进行修改 带列表面板123456789101112131415161718192021222324252627 Hello World hello1 hello1 hello1 hello1 hello1 可以看到一个列表的面板","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"Vue-js第三课","slug":"Vue/Vue-js第三课","date":"2019-04-30T04:44:06.000Z","updated":"2019-05-10T13:08:29.582Z","comments":true,"path":"2019/04/30/Vue/Vue-js第三课/","link":"","permalink":"http://yoursite.com/2019/04/30/Vue/Vue-js第三课/","excerpt":"","text":"这一课，要基于之前学习的 Vue-resource来实现品牌管理的改造，之前我们都是在本地来创建数据，现在我们可以用 Vue-resource 来请求 远端的数据库了 先开启node服务器： 创建一个html 注意：要导入 v-resource 的包 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 添加品牌 Name： Id Name Ctime Operation {{ item.id }} {{ item.name }} {{ item.ctime }} 删除 123456789101112131415var vm = new Vue({ el: '#app', data: { name: '', list: [ { id: 1, name: '五菱宏光', ctime: new Date() }, { id: 2, name: '众泰', ctime: new Date() } ] }, methods: { add(){ } }}); 品牌数据列表发起请求 提供的地址： http://www.liulongbin.top:3005/api/getnewslist请求方式： get作用： 获取品牌数据 json 数据返回数据格式： json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 添加品牌 Name： Id Name Ctime Operation {{ item.id }} {{ item.name }} {{ item.ctime }} 删除 123456789101112131415161718192021222324252627282930313233343536373839404142var vm = new Vue({ el: '#app', data: { name: '', list: [//存放所有品牌列表的数组 { id: 1, name: '五菱宏光', ctime: new Date() }, { id: 2, name: '众泰', ctime: new Date() } ] }, created(){//当 vm 实例的 data 和 methods 初始化完毕后，vm实例 会自动执行 created 这个生命周期函数 this.getAllList() }, methods: { add(){ }, getAllList(){//获取的所有的品牌列表 //分析： //1.由于已经导入了 Vue-resource这个包，所以，可以直接通过 this.$http 来发起数据请求 //2.获取列表的时候，要发起一个 get请求 //3.this.$http.get('url').then(function(result){}) //4.当通过 then 指定回调函数之后，在回调函数中，可以拿到数据服务器返回的 result //5.先判断 result.status 是否等于0，如果等于0，就成功了，可以把 result.message 赋值给 this.list；如果不等于0，可以弹框提醒获取失败！ this.$http.get('http://www.liulongbin.top:3005/api/getnewslist').then(result => { //注意：通过 $http 获取到的数据，都在 result.body 中放着 var result = result.body if(result.status === 0){ //成功了 //覆盖 list this.list = result.message } else { //失败了 alert('获取数据失败') } }) } }}); 页面加载的时候就会加载 Vue实例对象。 当 new 一个 Vue 的时候，并不是直接 new 就可以了，而是在 整个 new 的过程中，会执行一系列的生命周期函数执行到 beforeCreate()函数 的时候，我们只是单纯创建了 Vue实例，只是把生命周期函数和一些内置的事件触发好了，但是 data 和 method 这两个属性都没有初始化执行到 created()函数 ，data 和 methods 初始化完毕，我们可以把函数放在 created() 中， 让 vm 实例自己帮我们调用该方法，这时候就会发起一个 ajax 请求。 过程解析：这时候，一边在发 ajax请求的时候，服务器也在继续往后执行，随着继续编译模板的时候，可能在编译的时候，数据就已经请求回来了，此时还没有放到页面中去，但是数据已经请求回来了，已经被放到了 list 上，只要页面已被挂载，数据就可以看到了。 所以 发 ajax 要尽早 ，这样能够让我们去并行的完成各项操作，提前的将数据放进 data 或者 method 中。 比如：能不能调用 mounted 来发数据？ 在这个时候发送则不合适，因为这个时候发的话，虚拟DOM 已经挂载到了页面上，这时候只有一些假数据。如果这时候发送 ajax请求，服务器 发送过来的数据就没法在 页面上显示，就很矛盾了 添加功能 地址：http://vue.studyit.io/api/addproduct作用描述：添加品牌数据请求方式：Post传入 api 的参数： name: ‘品牌名称’返回数据格式： Json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 添加品牌 Name： Id Name Ctime Operation {{ item.id }} {{ item.name }} {{ item.ctime }} 删除 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var vm = new Vue({ el: '#app', data: { name: '', list: [//存放所有品牌列表的数组 { id: 1, name: '五菱宏光', ctime: new Date() }, { id: 2, name: '众泰', ctime: new Date() } ] }, created(){//当 vm 实例的 data 和 methods 初始化完毕后，vm实例 会自动执行 created 这个生命周期函数 this.getAllList() }, methods: { getAllList(){//获取的所有的品牌列表 //分析： //1.由于已经导入了 Vue-resource这个包，所以，可以直接通过 this.$http 来发起数据请求 //2.获取列表的时候，要发起一个 get请求 //3.this.$http.get('url').then(function(result){}) //4.当通过 then 指定回调函数之后，在回调函数中，可以拿到数据服务器返回的 result //5.先判断 result.status 是否等于0，如果等于0，就成功了，可以把 result.message 赋值给 this.list；如果不等于0，可以弹框提醒获取失败！ this.$http.get('http://www.liulongbin.top:3005/api/getnewslist').then(result => { //注意：通过 $http 获取到的数据，都在 result.body 中放着 var result = result.body if(result.status === 0){ //成功了 //覆盖 list this.list = result.message } else { //失败了 alert('获取数据失败') } }) }, add(){ //添加品牌列表到后台服务器 //分析： //1. 经过查看 数据API接口，要发送一个 Post 请求， this.$http.post //2. this.$http.post() 中接受三个参数 // 2.1 第一个参数： 要请求的URL地址 // 2.2 第二个参数： 要提交给服务器的数据， 要以对象形式提交给服务器 { name: this.name } // 2.3 第三个参数： 是一个配置对象，要以哪种表单数据类型提交过去， // { emulateJSON: true }：以普通表单格式，将数据提交给服务器 // application/x-www-form-urlencoded //3. 在 post 方法中， 使用 .then 来设置成功的回调函数，如果想要拿到成功的结果， //需要 result.body this.$http.post('http://www.liulongbin.top:3005/api/getnewslist',{ name: this.name },{ emulateJSON: true }).then(result => { if(result.body.status === 0){ //成功了 //添加完成后，只需要手动再调用一下 getAllList 就能刷新品牌列表了 this.getAllList() // 清空 name this.name = '' } else { //失败了 alert('添加失败！') } }) } }}); 删除数据 地址 ： http://vue.studyit.io/api/delproduct/:id作用描述 ： 删除品牌数据请求方法 ： Get传入api的参数 ： id返回数据格式 ： Json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 添加品牌 Name： Id Name Ctime Operation {{ item.id }} {{ item.name }} {{ item.ctime }} 删除 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576var vm = new Vue({ el: '#app', data: { name: '', list: [//存放所有品牌列表的数组 { id: 1, name: '五菱宏光', ctime: new Date() }, { id: 2, name: '众泰', ctime: new Date() } ] }, created(){//当 vm 实例的 data 和 methods 初始化完毕后，vm实例 会自动执行 created 这个生命周期函数 this.getAllList() }, methods: { getAllList(){//获取的所有的品牌列表 //分析： //1.由于已经导入了 Vue-resource这个包，所以，可以直接通过 this.$http 来发起数据请求 //2.获取列表的时候，要发起一个 get请求 //3.this.$http.get('url').then(function(result){}) //4.当通过 then 指定回调函数之后，在回调函数中，可以拿到数据服务器返回的 result //5.先判断 result.status 是否等于0，如果等于0，就成功了，可以把 result.message 赋值给 this.list；如果不等于0，可以弹框提醒获取失败！ this.$http.get('http://www.liulongbin.top:3005/api/getnewslist').then(result => { //注意：通过 $http 获取到的数据，都在 result.body 中放着 var result = result.body if(result.status === 0){ //成功了 //覆盖 list this.list = result.message } else { //失败了 alert('获取数据失败') } }) }, add(){ //添加品牌列表到后台服务器 //分析： //1. 经过查看 数据API接口，要发送一个 Post 请求， this.$http.post //2. this.$http.post() 中接受三个参数 // 2.1 第一个参数： 要请求的URL地址 // 2.2 第二个参数： 要提交给服务器的数据， 要以对象形式提交给服务器 { name: this.name } // 2.3 第三个参数： 是一个配置对象，要以哪种表单数据类型提交过去， // { emulateJSON: true }：以普通表单格式，将数据提交给服务器 // application/x-www-form-urlencoded //3. 在 post 方法中， 使用 .then 来设置成功的回调函数，如果想要拿到成功的结果， //需要 result.body this.$http.post('http://www.liulongbin.top:3005/api/getnewslist',{ name: this.name },{ emulateJSON: true }).then(result => { if(result.body.status === 0){ //成功了 //添加完成后，只需要手动再调用一下 getAllList 就能刷新品牌列表了 this.getAllList() // 清空 name this.name = '' } else { //失败了 alert('添加失败！') } }) }, del(id){ //删除品牌 this.$http.get('http://www.liulongbin.top:3005/api/getnewslist/'+id).then(result => { if(result.body.status === 0){ //删除成功 this.getAllList() } else { //删除失败 alert('删除失败！') } }) } }}); 全局配置数据接口的根域名问题： 每次发起 ajax 的时候，前面都带了一个 服务器的根地址，这样写不便于后期的改造，假如说将来 api 的域名换了，那么就得挨个挨个去改。 所以我们最好 不要将地址写死了，要通过一个变量去承载它 方法一：使用 Vue-resource 提取根域名 eg：Vue.http.options.root=’http://vue.studyit.io'; this.$http.get(‘api/getprodlist’).then(…) 注意： 如果想要 root属性 生效，请求的路径必须为相对路径。 eg：相对路径 Vue.http.get(‘someUrl’)，会自动拼接， 而 Vue.http.get(‘/someUrl’) 则不会自动拼接 总结： 如果我们配置了全局配置了服务器请求的 数据接口的根域名，则 在每次单独发起 http请求 的时候，请求的 url路径 应该以相对路径开头，前面不能带斜线 / ,否则不会启用根路径拼接 方法二：导入配置文件上面的方法替换的还不够彻底。 我们还可以给它处理一个 配置文件，每次只要从配置文件里面导入就行了 全局配置emulateJSON选项如果每次都要传 { emulateJSON: true }，也不太合理，我们查看官方文档，来看看有没有解决的方法： 可以看到，可以直接将该选项在 全局启动 为 true： 【 Vue.http.options.emulateJSON = true; 】 ： 将该选项启用为 true 接着在请求 ajax 的时候我们就可以 省略该步骤，eg： Vue中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能 动画它本质的目的不是效果多么好看就一定好，一个好的动画，是要帮助用户更好的理解页面中的功能 注意： 这里面的动画和 CSS3 中的不一样，CSS3学的动画非常炫酷，不如： 翻转、 3D视图… 但是，在 Vue中 不会有，Vue 中的动画有 淡入淡出、 位置、 透明度的渐变 过渡动画简介 这是一个完整的动画，有进入、 有离开，这才是一个完整的动画，他把一个完整的动画分成了 两部分： 左面：表示进入， 一个进入的动画分为 两个时间地点、 一个时间段 v-enter 表示进入之前元素的初始状态 v-enter-to 动画进入完成之后的结束状态 v-enter-active 动画的时间段 右面：表示离开 v-leave 表示即将离开之前，即起始状态 v-leave-to 表示离开完成之前，即结束状态 v-leave-active 动画的时间段 虽然它给我们分成了两个半场动画，但是可以发现，中间两个样式是一样的，即 v-enter-to、 v-leave， 还有 v-enter 、 v-leave-to ，即可将 类似的动画 分别写进一组 无动画样式 点击按钮，让按钮显示或隐藏 123456 这是一个H3 1234567var vm = new Vue({ el: '#app', data: { flag: false }, methods: {}}); 过渡动画样式但是现在的效果很突兀，那能否让它渐渐的展示出来，再渐渐的消失 需求： 使用 transition 元素，把 需要被 动画控制的元素 包裹起来 transition 元素是 Vue 官方提供的 自定义两组样式来 控制 transition 内部元素 实现动画 v-enter 【 这是一个时间点 】 是进入之前，元素的起始状态，此时还没有开始进入 v-leave-to 【 这是一个时间点 】 是动画离开之后，离开的终止状态，此时，元素 动画已经结束 v-enter-active 【 入场动画的时间段 】 v-leave-active 【 离场动画的时间段 】 最后为 v-enter 与 v-leave-to 添加一个 位移，实现位移效果 【 transition: all 0.4s ease 】： 参数分别是 设置 哪些属性、 花费的时间、 过渡的状态 123456789101112131415161718192021 .v-enter,.v-leave-to{ opacity: 0; transform: translateX(80px); } .v-enter-active,.v-leave-active{ transition: all 0.4s ease; } 这是一个H3 1234567var vm = new Vue({ el: '#app', data: { flag: false }, methods: {}}); 自定义 前缀为什么 样式 的前面要带个 v ？ 注意： transition默认 必须要带一个 【 v- 】 前缀，以标明这是 Vue 中特有的样式，来实现动画 如果你想自定义，不让它带 【 v- 】 可以看到当前 两组 类，都控制在 transition中 123456789101112131415161718192021222324252627282930313233343536373839404142 .v-enter,.v-leave-to{ opacity: 0; transform: translateX(80px); } .v-enter-active,.v-leave-active{ transition: all 0.4s ease; } .my-enter,.my-leave-to{ opacity: 0; transform: translateY(70px); } .my-enter-active,.my-leave-active{ transition: all 0.8s ease; } 这是一个H3 这是一个H6 12345678var vm = new Vue({ el: '#app', data: { flag: false, flag2: false }, methods: {}}); 不管你是 flag1 还是 flag2，这两个都是 公用上面定义的类， 但是有时候我们需要 不同效果的动画，比如说：一个从左边、 一个从右边 这时候，可以给 transition 加一个 name属性,这就表示 将来 h6 所有的动画前面的前缀不再是 v- 了，而是 my-,这就是前缀的作用，能够 区分不同组的变化 使用第三方类实现动画animate.css ： 提供了很多常见的动画效果，现在我们要使用它来帮我们实现 特殊的 入场和出场效果 入场使用 bounceIn 离场使用 bounceOut 这里我们使用了第三方来实现动画，就不用自己去写样式 注意： 进行入场和出场之前，还要再加一个 基本类 animated 123456789 这是一个H3 1234567var vm = new Vue({ el: '#app', data: { flag: false }, methods: {}}); duration设置动画时长 duration： 表示动画 花费的时间, 冒号表示 属性绑定 分别定义入场的时间和离场的时间 使用 【 ：duration=”{ enter: 200,leave: 400 } 】，分别来设置入场的时长，和离场的时长 123456789 这是一个H3 1234567var vm = new Vue({ el: '#app', data: { flag: false }, methods: {}}); 钩子函数实现半场动画温故知新 第一种实现方法：自定义 v-enter、 v-leave 第二种实现方法：使用第三方的 animate 实现动画 前两种都是一个完整的动画，eg：有进入、 有离开。 有的时候只需要静茹的动画，不需要离开的动画，即半场动画。 但是第一种 与 第二种 都无法实现半场动画 第三种实现方法：钩子函数实现半场动画 半场动画： 只有入场的，没有离开的 钩子函数 动画的生命周期函数： 入场钩子函数：上半部分的函数 离场构造函数：下半部分的函数 钩子函数入场钩子函数： before-enter：进入之前 enter：进入 after-enter：进入之后 分为三个阶段，所以说把这些叫做动画的生命周期函数 出场钩子函数： before-leave：离开前 leave：离开 after-leave：离开之后 可以看到每个函数前面都有一个 v-on，这代表这是一个事件。 这个事件要对应处理函数，一共要写 8 个事件，但是如果只有 入场的动画，只需要写入场的几个就可以了 实例：小球的半场动画 注意： 动画钩子函数第一个参数 : el，表示 要执行动画的那个DOM元素，是个原生的 JS DOM 对象，这个 el 可以认为是通过 document.getElementByid(‘’) 获取到的原生对象 钩子函数： beforeEnter 表示动画入场之前，此时，动画尚未开始，可以 再 beforeEnter 中，设置元素开始动画之前的起始样式 enter 表示动画 开始之后的样式，这里，可以设置小球完成动画之后的，结束状态 动画完成之后，会调用 afterEnter 1234567891011121314151617181920 .ball{ width: 15px; height: 15px; border-radius: 50%; background-color: red; } 123456789101112131415161718192021222324252627var vm = new Vue({ el: '#app', data: { flag: false }, methods: { beforeEnter(el){ //设置小球开始动画之前的起始位置 el.style.transform = \"translate( 0 , 0 )\" }, enter(el,done){ //这句话没有实际的作用，如果不写则没有动画效果 //可以认为 el.offsetWidth 会强制动画刷新 el.offsetWidth el.style.transform = \"translate( 150px , 450px )\" el.style.transition = 'all 1s ease' //这里的 done ，其实就是 afterEnter 这个函数，也就是说： done 是一个函数的引用 done() }, afterEnter(el){ console.log(\"OK\") this.flag=!this.flag } }}); transition-group元素实现列表动画在实现列表过渡的的时候，如果需要过渡的元素，是通过 v-for 循环渲染出来的，不能使用 transition 包裹，需要使用 transitiongroup 如果要为 v-for 循环创建的元素设置动画，必须为每一个元素设置 【 :key 】 .v-move 和 .v-leave-active 配合使用能够实现列表后续的元素，渐渐的飘上来的效果 .v-move：当一个子节点被更新，从屏幕上的位置发生改变，它将会获取应用v-move样式 transition-group 属性appear： 给 transition-group 添加 appear 属性，实现页面刚展示出来时候，入场时候的效果 tag： 通过tag属性，指定 transition-group 将来要渲染为一个什么元素； 如果不指定，则默认渲染为 span 12345678910111213141516171819202122232425262728293031li{ border: 1px dashed #999; margin: 5px; line-height: 35px; padding-left: 5px; font-size: 12px; width: 100%}.v-enter,.v-leave-to{ opacity: 0; transform: translateY(80px)}.v-enter-active,.v-leave-active{ transition: all 0.6s ease;}li:hover{ background-color: hotpink; transition: all 0.8s ease;}.v-move{ transition: all 0.6s ease;}.v-leave-active{ position: absolute;} 12345678910111213141516171819202122 Id: Name: {{ item.id }} --- {{ item.name }} 12345678910111213141516171819202122var vm = new Vue({ el: '#app', data: { id: '', name: '', list: [ {id: 1, name: '赵高'}, {id: 2, name: '秦桧'}, {id: 3, name: '严嵩'}, {id: 4, name: '魏忠贤'} ] }, methods: { add(){ this.list.push({ id: this.id, name: this.name }) this.id = this.name = '' }, del(i){ this.list.splice(i,1) } }}) 个人总结： 【 .v-enter 】, 【 .v-leave-to 】 表示动画进入时/动画离开时 的动画，而 【 进入完成之后 】 和 【 离开完成之前 】 没有设置，则保存默认，即当前状态 定义组件什么是组件？ 组件的出现，就是为了拆分 Vue实例的代码里的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么功能，就可以去调用对应的组件即可 ； 模块化 和 组件化 的区别： 模块化：是从代码逻辑角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化：是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用； 全局组件定义的三种方式1.通过Vue.extend()创建组件 直接调用 Vue.extend() 传递一个 对象 template template 就是组件要 展示的具体内容 调用 Vue.extend() 会 返回一个组件的模板对象 调用 Vue.compoent() 把 Vue.extend() 返回的模板对象 注册为一个真正的具有名称的组件 将来在页面中就可以 标签 引用名称，把它放到页面中去使用即可 注意： 如果在 Vue.component() 中使用了 驼峰命名，那么在页面标签使用该模板对象的时候，就需要将大写字母转换为小写，并且在两个字母中间加 【 - 】; 如果不使用驼峰，则直接拿名称来引用即可 eg： 12345678910111213141516171819 //1.1 使用 Vue.extend 来创建全局的Vue组件 var com1 = Vue.extend({ template: '这是使用 Vue.extend 创建的组件' //通过 template 属性，制定了组件要展示的HTML结构 }) //1.2 使用 Vue.component('组件的名称',创建出来的组件模板对象) Vue.component('myCom1', com1) var vm = new Vue({ el: '#app', data: {}, methods: {} });","categories":[{"name":"Vue学习","slug":"Vue学习","permalink":"http://yoursite.com/categories/Vue学习/"}],"tags":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/tags/前端知识/"}]},{"title":"媒体对象（评论模块）","slug":"Bootstrap/媒体对象","date":"2019-04-29T09:22:11.000Z","updated":"2019-04-29T11:35:06.480Z","comments":true,"path":"2019/04/29/Bootstrap/媒体对象/","link":"","permalink":"http://yoursite.com/2019/04/29/Bootstrap/媒体对象/","excerpt":"","text":"默认样式这是一个抽象的样式，用以后就不同类型的组件，这些组件具有文本内容，在左边或者在右边有对其的一些图片，像一些评论、或者模仿推特来做的一些消息等 1234567891011121314151617181920212223body{ margin:10px 0;} 欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客 可以看到左边有一张 64*64的图片，右边有一个标题是关于他的描述，下面是一个具体的内容描述 由于 Bootstrap版本问题，图片的位置可能不会改变，可以试用下面两个类： 老版本使用：pull-left 新版本使用：media-right 如果多复制几次，可以出现以下效果，模仿一些类似于 推特评论或者博客等等： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客 对象的继承关系有的时候需求并不是所有的都在一排，可能当前第二个评论的内容它属于第一个内容，它有一个继承关系，有一个属于关系，它就不应该在它的同行，它应该向后退格 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客 图片置右将 图片代码的div 移动到 内容div 的下面，然后修改 media-left 为 media-right 即可 1234567891011121314151617 欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客 图片垂直方向的位置为实现第三个功能，首先添加一下文字区域的内容； 可以看到，现在图片是居于内容的左上角的，有的时候我们需要让图片居中显示，也有的时候需要图片居底显示 在包含图片的 a标签 中添加 media-middle（居中） 或者 meida-bottom（置底） 即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客 欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客欢迎来到Yaoremu的博客 本人测试 media-left、 media-middle 等 均无法剩下，可能是因为 Bootstrap版本问题… 使用列表方式创建由于现在的所有内容都是经过 div 进行展示的，意味着要不停的去创建 div，不太合理 Bootstrap 给我们提供了列表方式去实现该内容,除了最外层的 div 换成了 列表 的方式，其他方面没有变化 12345678910111213141516 欢迎来到YaoRemu的博客 欢迎来到YaoRemu的博客欢迎来到YaoRemu的博客欢迎来到YaoRemu的博客欢迎来到YaoRemu的博客欢迎来到YaoRemu的博客 欢迎来到YaoRemu的博客欢迎来到YaoRemu的博客欢迎来到YaoRemu的博客欢迎来到YaoRemu的博客欢迎来到YaoRemu的博客 欢迎来到YaoRemu的博客欢迎来到YaoRemu的博客欢迎来到YaoRemu的博客欢迎来到YaoRemu的博客欢迎来到YaoRemu的博客 欢迎来到YaoRemu的博客欢迎来到YaoRemu的博客欢迎来到YaoRemu的博客欢迎来到YaoRemu的博客欢迎来到YaoRemu的博客 可以看到，这比我们使用 多个 div 来创建要好很多，这就是媒体对象的列表","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"导航条","slug":"Bootstrap/导航条","date":"2019-04-29T07:59:43.000Z","updated":"2019-04-29T09:20:46.899Z","comments":true,"path":"2019/04/29/Bootstrap/导航条/","link":"","permalink":"http://yoursite.com/2019/04/29/Bootstrap/导航条/","excerpt":"","text":"简介 基本的导航 表单 按钮 文本 非导航的链接 组件排列 固定在顶端或者底部 反色的导航条 路径导航 基本的导航1234567891011121314151617 蕾姆 Link Link Link 导航添加表单12345678910111213141516171819202122232425 蕾姆 Link Link Link 搜索 组件排列相应的控件添加 navbar-left 即可 此处需要使用 JS脚本 进行操作 1234567891011121314151617181920212223242526272829303132333435363738394041 蕾姆 Link Link Link 搜索 Link 点我 hello1 hello2 hello3 hello4 1234$(\"#mytab a\").click(function(e){ e.preventDefault(); $(this).tab(\"show\");}) 固定在顶端或者底部 Bootstrap导航 默认固定在顶端 在 nav标签添加 nav-fixed-bottom 类即可 12345678910111213141516171819202122232425 蕾姆 Link Link Link 搜索 反色的导航条默认是白色，我们可以把它改为黑色，修改 nav标签 中的 navbar-default类 即可 12345678910111213141516171819202122232425 蕾姆 Link Link Link 搜索 路径导航路径导航，在文档中出现较多 role属性： 增加标签的可访问性 1234567 Home Library Data","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"透视","slug":"绘画/透视","date":"2019-04-28T13:00:26.000Z","updated":"2019-04-28T13:26:49.508Z","comments":true,"path":"2019/04/28/绘画/透视/","link":"","permalink":"http://yoursite.com/2019/04/28/绘画/透视/","excerpt":"","text":"三点透视 两点透视第一种 第二种 一点透视 五点透视","categories":[{"name":"素描","slug":"素描","permalink":"http://yoursite.com/categories/素描/"}],"tags":[{"name":"画画","slug":"画画","permalink":"http://yoursite.com/tags/画画/"}]},{"title":"导航","slug":"Bootstrap/导航","date":"2019-04-28T08:52:40.000Z","updated":"2019-04-28T09:36:18.986Z","comments":true,"path":"2019/04/28/Bootstrap/导航/","link":"","permalink":"http://yoursite.com/2019/04/28/Bootstrap/导航/","excerpt":"","text":"导航分为几个方向： 标签页 胶囊式标签页 两端对齐标签页 禁用的链接 添加下拉菜单 基本的标签页 role 的添加会导致一些问题的避免 HTML1234567891011 home Hello World JavaScript1234$(\"#mytab a\").click(function(e){ e.preventDefault(); $(this).tab(\"show\");} 由于没有点击选中的效果，所以需要引入它需要使用的一个插件 胶囊式标签页胶囊我们都看过，其实就是颜色不一样 HTML1234567891011 home Hello World JavaScript1234$(\"#mytab a\").click(function(e){ e.preventDefault(); $(this).tab(\"show\");} 另外，如果我们希望垂直展示，我们只需要在外层 ul 添加一个垂直展示的方式 【 nav-stacked 】 即可 两端对齐标签页两端对齐的标签页只需要添加一个 class 【 nav-justified 】 即可 HTML1234567891011 home Hello World JavaScript1234$(\"#mytab a\").click(function(e){ e.preventDefault(); $(this).tab(\"show\");} 禁用的链接有时候需要一些 使用户无法点击的情况，只需要在不想让用户点击的 li 标签中禁止点击即可 HTML1234567891011 home Hello World JavaScript1234$(\"#mytab a\").click(function(e){ e.preventDefault(); $(this).tab(\"show\");} 添加下拉菜单如果 world 下有很多子分类，意味着我们需要给 world 添加一个可下拉式的菜单效果 HTML123456789101112131415161718192021 home Hello World hello1 hello2 hello3 hello4 JavaScript1234$(\"#mytab a\").click(function(e){ e.preventDefault(); $(this).tab(\"show\");}","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"Bootstrap输入框组","slug":"Bootstrap/Bootstrap输入框组","date":"2019-04-28T07:31:48.000Z","updated":"2019-04-28T09:04:11.001Z","comments":true,"path":"2019/04/28/Bootstrap/Bootstrap输入框组/","link":"","permalink":"http://yoursite.com/2019/04/28/Bootstrap/Bootstrap输入框组/","excerpt":"","text":"主要内容 输入框组 导航 导航条 输入框组 基本的输入框 输入框的尺寸 多添加的多选框和单选框 多添加按钮 多添加下拉式按钮 多添加分裂式按钮下拉菜单 基本的输入框1234567891011121314151617 @ .00 $ .00 输入框的尺寸输入框的尺寸是根据屏幕的自适应来操作的，比如：响应式布局，针对于手机 、 ipad 和 显示器 时的显示是不一样的,根据不同的屏幕选择不同的内容 1234567891011121314151617 @ .00 $ .00 多添加的多选框和单选框12345678910 多添加按钮12345678910 Go！ 多添加下拉式按钮通常会在输入框前面有一个下拉菜单，因为选项特别多，所以在前面还可以添加下拉菜单的效果 1234567891011121314151617181920 Action Hello Hello Hello Hello Hello","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"文件和目录常用命令","slug":"Linux/Linux基础-Ubuntu/文件和目录常用命令","date":"2019-04-28T06:40:28.000Z","updated":"2019-05-02T03:02:59.930Z","comments":true,"path":"2019/04/28/Linux/Linux基础-Ubuntu/文件和目录常用命令/","link":"","permalink":"http://yoursite.com/2019/04/28/Linux/Linux基础-Ubuntu/文件和目录常用命令/","excerpt":"","text":"目标 查看目录内容 ls 切换目录 cd 创建和删除操作 touch ： 创建文件 rm ： 删除文件和目录 mkdir ： 创建目录 拷贝和移动工具 cp mv 查看文件内容 cat more grep 其他 echo 重定向 > 和 >> 管道 | 查看目录内容终端实用技巧自动补全 在敲出 文件/目录/命令 的前几个字幕之后，按下 tab 键 如果输入没有歧义，系统会自动补全 如果还存在其他 文件/目录/命令 ，再按一下，系统会提示可能存在的命令 曾经使用过的命令 按 上/下 光标键可以在曾经使用过的命令之间来回切换 如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c ls命令说明 ls 是英文单词list的简写，其功能为列出目录的内容，是用户最常用的命令之一，类似于 DOS 下的 dir命令 Linux下文件和目录的特点 Linux 文件 或者 目录 名称最长可以由 256 个字符 以 【 . 】 开头的文件为隐藏文件，需要用 -a 参数才能显示 eg ： 创建隐藏文件 eg ： 使用 -a 参数显示隐藏文件 【 . 】 代表当前目录 【 .. 】 代表上一级目录 eg ： 返回上一级目录 ls常用选项 参数 含义 -a 显示指定目录系所有子目录与文件，包含隐藏文件 -l 以列表方式显示文件的详细信息 -h 配合 -l 以人性化的方式显示文件大小 在 ubuntu 中 默认情况下，敲入 ls 终端命令之后，显示文件的方向是以水平方向 横排显示 的，同时 ubuntu 中默认情况下： 文件夹，会使用蓝色字体显示 文件，会使用白色字体显示 -l 选项 我们可以看到，文件列表以纵向方向来显示的，同时我们可以看到文件的详细信息，我们可以看到文件夹以及文件创建的 时间以及日期、磁盘空间大小 另外，前面出现了两列 python ，等在后面章节讲到用户已经群组的时候会单独的介绍 然后，在终端窗口的最前面，有一堆的字母，其中第一列字母是小写字母 d，如果是目录，会在第一列中以小写字母 d 来标识，如果不是目录，就没有小写字母 d -h 选项单独使用 ls -h 是 没有效果的。 eg： 因为 -h 需要配合 -l 一起使用。 eg： 我们可以看到，整体显示的信息与 只使用 -l 的结果是差不多的，唯一的区别是 文件和目录大小，这就是以人性化的方式来显示文件大小。 eg： 扩展命令的输入方式在 linux 中，终端命令的选项，如果我们要有多个选项，我们可以 分开来输入，也可以 合在一起 来输入。 eg： 注意： 所有的选项输入的先后顺序是没有关系的 隐藏文件 【 . 】 开头的文件表示文件是隐藏的 注意：隐藏文件和隐藏文件夹是怎么出现在 用户 的家目录中？ 因为我们在 Ubuntu 中，安装有各种各样的软件，这些隐藏文件夹和隐藏文件，就是来专门配置系统上安装的各个应用软件的，所以在我们日常使用的时候，不需要理会这些文件。 例如： 【 .vim 】 是专门用来配置终端上的配置器软件。 在日常使用中，这些隐藏文件和隐藏文件夹保持不变即可 计算机中文件大小的表达方式（科普） 单位 英文 含义 字节 B（Byte） 在计算机中作为一个数字单元，一般为8位2进制数 千 B（Kibibyte） 1KB = 1024B，千字节（1024 = 2**10） 兆 k（Mebibyte） 1MB = 1024KB，百万字节 千兆 B（Gigabyte） 1GB = 1024MB，十亿字节，千兆字符 太 B（Terabyte） 1TB = 1024GB，万亿字节，太字节 拍 B（Petabyte） 1PB = 1024TB，千万亿字节，拍字节 艾 B（Exabyte） 1EB = 1024PB，白亿亿字节，艾字节 泽 B（Zettabyte） 1ZB = 1024EB，十万亿亿字节，泽字节 尧 B（Yottabyte） 1YB = 1024ZB，一亿亿亿字节，尧字节 通配符的使用应用场景： 工作中，远程维护服务器的时候，需要把某一个目录下的某些文件进行修改，但是，这个目录下的文件非常非常多，试想一下：如果这个目录下的文件很多很多，我们单纯敲一个 ls ，有可能会出现 “刷刷刷” 好几屏的情况。 如个应用 ls 快速定位到我们需要修改的这几个文件，此时，通配符 就可以排上用处了。 所谓通配符，是指一些特殊的符号，而这些特殊的符号可以用来代表其它的字符，这个就叫做通配符。 在日常工作中，有两种通配符是最常使用的，一个是 【 * 】， 另一个是 【 ？ 】 通配符 含义 * 代表任意个数个字符 ? 代表任意 一个字符，至少1个 [] 表示可以匹配字符组中的任一一个 [abc] 匹配 a、b、c 中的任意一个 [a-f] 匹配从 a 到 f 范围内的任意一个字符 【 * 】 演示 查找开头为 1 的文件 查找结尾为 1 的文件 注意： 需要加上扩展名，声明文件的类型。 否则无法查找 另外一种方法查找结尾的文件 直接在 相应的节点 前后输入 【 * 】 通配符 【 ？ 】 演示问号只能代表查找一个字符 注意：【 ? 】 只能代表一个字符，而且必须是一个字符，而 【 * 】 号可以代表任意一个字符，即也可以表示无字符 【 [] 】 中括号定义一个匹配的字符组，如果查找到的文件名与 中括号 中的字符相匹配，则输出。eg： 【 [a-f] 】表示 a 到 f 范围内的任意一个字符 切换目录 cd 是英文单词 change directory 额简写，其功能为更改当前的工作目录，也是用户最常用的命令之一 注意：Linux 所有 目录 和 文件名 都是 大小写敏感 的 命令 含义 cd 切换到当前用户的主目录（/home/用户目录） cd ~ 切换到当前用户的主目录（/home/用户目录） cd . 保持在当前目录不变 cd .. 切换到上级目录 cd - 可以在近两次工作目录之间来回切换 相关命令解析 注意： $ 符号前面会提示现在所在的工作目录，我们即便不用 pwd ，同样可以确认当前所在的目录 cd切换到当前用户的主目录（/home/用户目录） cd ~切换到当前用户的主目录（/home/用户目录） cd .保持在当前目录不变 cd ..切换到上级目录 cd -可以在 最近两次 工作目录之间来回切换 相对路径和绝对路径 相对路径 在输入路径时，最前面不是 / 或者 ~ ，表示相对 当前目录 所在的目录位置 绝对路径 在输入路径时，最前面是 / 或者 ~ ，表示从 根目录/家目录 开始的具体目录位置 绝对路径所谓绝对路径，不管当前的所在工作目录是哪里，通过 cd 这个命令，给一个绝对路径的参数，我们都可以准确的切换到目标的工作目录 【 / 】表示 根目录 eg：切换到 python用户的桌面文件夹 相对路径所谓相对路径，就是相对于当前所在目录位置的一个路径，相对路径开始时通常不需要斜线，它只是相对于当前目录所对应的一个文件夹 eg：返回相对于当前路径的上一级目录 创建和删除操作touch 创建文件或修改文件时间 如果文件 不存在，可以创建一个空白文件 如果文件 已经存在，可以修改文件的末次修改日期 使用 touch 修改文件日期 可以看到，111.txt 文件末次修改时间发生了变化，这就是 touch 的作用： 如果文件 不存在，可以创建一个空白文件； 如果文件 已经存在，可以修改文件的末次修改日期 mkdir 创建一个新的目录 选项 含义 -p 可以递归创建目录 eg： 在实际工作中，可能会有一种场景，就是连续创建多个目录，譬如：在桌面文件夹下面 创建一个 a的目录， 在a的目录下创建一个 b的目录， 在 b下面再创建一个 c的目录， 在c 下面再创建一个 d的目录（a/ b/ c/ d）。 就相当于要连续创建多个目录，而这种方式我们就可以使用 -p 选项，一次性把这 4 个目录全部创建出来 这种方式就可以非常快速的连续创建多个目录 新建目录的名称 不能与当前目录中 已有的目录或文件 同名 rm 删除文件或目录 注意： 使用 rm 命令要小心，删除时直接从磁盘上删除,因此文件删除后 不能恢复 选项 含义 -f 强制删除，忽略不存在的文件，无需提示 -r 递归的删除目录下的内容， 删除文件夹 时必须加此参数 -rrm 不能直接删除目录，如果要删除目录，要带一个 -r选项， 同时，-r 选项可以一次性删除 多级目录 可以看到 a1 / b1/ c1/ d1 全部被删掉 这就是 -r 的作用 -f强制删除，忽略不存在的文件，无需提示 可以看到，如果不添加 -f 删除 不存在的文件 时，终端提示了错误信息。 如果添加了 -f ，则终端不会提示。 如果有则直接删除，如果没有也不会有任何的提示信息 rm 通配符删除以1结尾的文本文件: 删除所有目录以及文件： 注意: 在使用 linux 的时候， rm 命令删除的文件是不能恢复的，所以我们千万不能在 根目录 下 输入 rs -r ，一旦输入，整个系统就彻底完蛋了。 我们的操作基本都在 家目录中，尽量不要在系统目录下操作 拷贝和移动工具 序号 命令 对应英文 作用 1 tree[目录名] tree 以树状图列出文件目录结构 2 cp 源文件 目标文件 copy 复制文件或者目录 3 mv 源文件 目标文件 move 移动文件或者目录/文件或者目录重命名 tree 命令可以以 树状图 列出文件目录结构 选项 含义 -d 只显示目录 输入 tree 后，可以看到一个 树状图； 第一行的 【 . 】：表示当前的 工作目录； 文件夹为 蓝色字体，文件为 白色字体 显示； tree 查看家目录 首先第一行变成了 家目录，然后显示出 家目录 中可以看到的文件夹，以及每个文件夹下还包含 什么文件夹以及文件。 同时，在 最底部 还可以显示出 目录中有多少个文件以及目录 eg：创建一个多级目录，再在多级目录下创建一个文件夹，使用 tree 查看 tree -d只显示目录，不显示文件 cp cp 命令的功能室将给出的 文件 或 目录 复制 到另一个文件 或 目录 中，相当于 DOS 下的 copy 命令 格式cp 源文件 目标文件 所谓 目标文件，就是我们希望文件复制到哪里，并且叫什么名字 基本使用 注意： 【 . 】 表示当前文件夹 也可以 简写，如果源文件名不改变，只需要指定目标位置，直接用一个 【 . 】 表示将目标位置 复制 源文件 到当前位置： cp 扩展 选 项 含义 -i 覆盖文件前提示 -r 若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录、目标文件， 目标文件必须为一个 目录名 -i在复制文件的时候，如果发现文件已经存在，会给我们一个提示，接下来我们可以输入 yes 或 no 来决定是否覆盖 -rcp 这个命令，不能直接复制目录，如果想要复制目录，同样需要一个 -r 的选项 mv mv 命令可以用来 移动 文件或目录，也可以给 文件或目录重命名 格式mv 源文件 目标文件 基本使用 使用 mv命令 在移动文件和目录的时候，不需要带 选项 选项 含义 -i 覆盖文件前提示 重命名源文件和目标文件的目录相同，但是名字不同，就可以实现文件的重命名 文件覆盖当 目标文件 中有与 源文件 相同名字 的文件，那么使用 mv 时，目标文件会 替换 掉原来存在的文件，实现文件覆盖 如果出现了文件覆盖的情况，我们同样可以和 cp一样， 添加一个 -i 的选项，用 -i 的选项在覆盖的时候，会有一个提示，提高了安全性 mv修改文件夹文件夹重命名mv 也可以给目录进行重命名， eg： 查看文件内容 序号 命令 对应英文 作用 1 cat 文件名 concatenate 查看文件内容、创建文件、文件合并、追加文件内容等功能 2 more 文件名 more 分屏显示文件内容 3 grep 搜索文本 grep 搜索文本文件内容 cat cat 命令可以用来 查看文件内容、创建文件、文件合并、追加文件内容 等功能 cat 会一次显示所有的内容，适合 查看内容较少 的文本文件 选项 含义 -b 对非空输出行编号 -n 对输出的所有行编号 linux 中还有一个 nl 的命令和 cat -b 的效果等价 cat的附加功能这两个选项最大的用处就是我们在终端中查看文件的时候，通过这两个选项，可以非常快速的知道，我们的程序中 一共包含有多少行代码 -b 对于空行不会编号； -n 不论是否是空行，都会编号 -b 可以看到，输出的时候，文件内容前面会有一些序号，表示文件的行号 -n 会把所有行的行号都表示出来，不论是有内容还是没有内容的行 more more 命令可以用于分屏显示文件内容，每次只显示一页内容 适合于 查看内容较多 的文本文件 使用 more 的操作键： 操作键 功能 空格键 显示手册的下一屏 Enter键 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 退出 /word 搜索word字符串 ········ cat、more区别cat能够一次性输出文件的完整内容； more是可以分屏显示的（隐藏部分文件），可以点击空格来展示隐藏的内容 grep Linux 系统中 grep 命令是一种强大的文本收缩工具 grep 运行对文本文件进行 模式查找，所谓模式查找，又被称为 正则表达式 选项|含义-n|显示匹配行及行号-v|显示不包括匹配文本的所有行（相当于求反）-i|忽略大小写 基本使用格式： grep 搜索的字符 文件 我们可以看到，在文件中所有ba包含 as 的行，以及 as 单词都会被高亮显示 -n 行号 可以看到，行号在最前面就显示出来了，同时 as 单词同样会被高亮显示出来 -v 不包含 可以看到，所有不包含 as 的行都会被显示出来 显示所有不包含的文本， 并且输出行号，我们可以与 -n 组合使用即可： -i 不区分大小写忽略大小写 可以看到 hello 可以查找到文章中的 Hello,即不区分大小写 搜索多个单词搜索 单个单词不需要加 引号，搜索多个单词时，需要添加引号引起来 模式查找搜素文件的时候，如果希望按照某种模式，或者套路搜索对应的文本内容，我们就可以把它叫做模式查找，模式查找又可以被叫做 正则表达式 常用的两种模式查找 参数 含义 ^a 行首，搜寻以 a 开头的行 ke$ 行尾，搜索以 ke 结束的行 在日常开发的时候，有的时候可能会出现一种需求，就是来判断指定的文本必须出现在一行的行首，或者指定的文本必须出现在一行的行尾，这两种方式都可以被叫做 模式 ^ 行首匹配 可以看到，只有在行首的小写f ，才会被高亮，而没有在行首的f不会高亮，这就是我们在搜索的时候，如果指定一个向上的箭头，只会搜索文件中，每一行开始的部分 $ 行尾匹配. 每一行字母以a结尾的都会被显示出来 其他echo 文字内容 echo 会在终端显示参数指定的文字，通常会和 重定向 联合使用 为什么要再次显示一遍输入的内容？ echo 在日常使用中，很少会单独使用，通常会和 从定向来一起使用 重定向 > 和 >>概念： 把原本应该输出到终端的内容 ，重定向 到一个文件中 Linux 允许将命令执行结果 重定向 到另一个文件 将本应显示在 终端上的内容 输出/追加 到 指定文件 中 其中 >： 表示 输出，会 覆盖 文件原有的内容 >>： 表示 追加，会将内容追加到已有文件的末尾 重定向的用处 ： 有时候，终端命令输出的结果太多，而且我们希望把终端命令输出结果保存下来，就可以使用重定向这个命令 > 桌面自动创建了 文件a，并且 含有 echo命令 中的内容。 尝试将 列表显示目录下的文件 的内容 重定向 到 文件中 打开 文件a 查看，可以看到 ls 产生的结果 已经被输出到 文件a 中,并且 覆盖 原有文件 >> 可以看到，文件已经追加到文件末尾 重定向 与 touch 的区别用 echo 创建文件的同时，就可以指定文件的内容，而用 touch 这个命令，只能创建一个空文件，文件的内容还需要后续的编辑来创建，这就是 echo命令 的好处 管道 Linux 运行将 一个命令的输出 可以通过管道 作为 另一个命令的输入（负责对第一个命令的输出做二次处理） 可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里 | 的左右分为两项，左端塞东西（写），右端取东西（读） 常用的管道命令有： more： 分屏显示内容 grep： 在命令执行结果的基础上查询指定的文本 more分屏显示结果 eg： 查询目录内容的时候，能够分屏显示内容 grep能够过滤执行结果 eg： 查询目录内容的时候，查询包含某个字符的行","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"从零开始的Python学习","slug":"从零开始的Python学习","permalink":"http://yoursite.com/tags/从零开始的Python学习/"}]},{"title":"Linux终端命令格式","slug":"Linux/Linux基础-Ubuntu/Linux终端命令格式","date":"2019-04-28T04:37:52.000Z","updated":"2019-04-28T06:39:09.782Z","comments":true,"path":"2019/04/28/Linux/Linux基础-Ubuntu/Linux终端命令格式/","link":"","permalink":"http://yoursite.com/2019/04/28/Linux/Linux基础-Ubuntu/Linux终端命令格式/","excerpt":"","text":"终端命令格式command [-options] [parameter] 说明： command：命令名，相应功能的英文单词或单单词的缩写 eg：只需要输入命令就可以看到结果的命令： ls（查看当前文件夹的内容）、pwd（查看当前所在的工作文件）、clear（清空屏幕） [-options]：选项，可用来对命令进行控制（执行命令的时候可以做额外的控制），也可以省略 eg：删除目录： rm -r aaa parameter：传给命令的参数，所谓参数，就是执行命令的时候让命令具体去做的事情，我们可以 以参数的形式告诉命令。 参数可以是 零个、一个 或者 多个 eg：需要传递参数给命令的的命令： touch 文件名称（创建文件）、cd 目录名称（切换目录）、mkdir 目录名称（创建目录）、rm 文件名称（删除文件） [ ] : 代表可选（可以有，也可以没有） 查阅命令帮助信息（知道即可）在工作中，很有可能出现一种情况，当我们想使用某一个命令时，这个命令我们明明会，就是想不起来了，出现这种情况时，我们就可以用 查阅命令帮助信息 来速查一下命令对应的是哪一个选项 提示 现阶段只需要 知道 通过以下两种方式可以查询命令的帮助信息 先学习 常用命令 及 常用选项 的使用即可，工作中遇到问题可以借助 网络搜索 - -helpcommand --help 说明： 显示 command 命令的帮助信息 敲 减号 之后，后面跟的是 选项； 而如果接了两个减号，后面跟了一个 help，这是绝大多数终端命令固定的选项，这个选项就能够在终端中显示出命令的简要帮助信息 man这是 Linux 中提供的一种专门的终端命令 man， man command 说明： 查阅 command 命令的使用手册 可以看到帮助信息是满屏的，同时下方有一个帮助信息，【 q to quit 】 ，表示退出帮助信息 man 是 manual 的缩写，是Linux提供的一个 手册，包括了绝大部分的命令，函数的详细使用说明 查看帮助信息的方法使用 man 时的操作键 操作键 功能 空格键 显示手册页的下一屏 Enter键 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 退出 /word 搜索 word 字符串","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"从零开始的Python学习","slug":"从零开始的Python学习","permalink":"http://yoursite.com/tags/从零开始的Python学习/"}]},{"title":"按钮组","slug":"Bootstrap/按钮组","date":"2019-04-27T08:23:27.000Z","updated":"2019-04-29T08:02:22.243Z","comments":true,"path":"2019/04/27/Bootstrap/按钮组/","link":"","permalink":"http://yoursite.com/2019/04/27/Bootstrap/按钮组/","excerpt":"","text":"按钮组通过 按钮组容器，把一组按钮放在同一行里，建议我们与 按钮组插件 联合使用，会出现更好的样式。 现阶段先不使用插件，在后面的阶段会详细讲解插件，接下来了解 按钮组 是如何使用的 1234567 Left Middle default 我们可以看到三个按钮，三个按钮在一个组当中，因为他们连在一起，这就是按钮组最基本的使用 延伸效果：按钮工具栏我们可以根据按钮组来延伸出来一个效果，我们在使用 office办公的时候，上方会有很多很多的选项，比如居中操作，或者是居左、居右，让你的文字字体大小调节； 其实，我们可以使用按钮组来进行调节他们，可以称为： 按钮工具栏 把一组 div ，也就是我们上方演示的一个按钮组，融合在一个工具栏中，叫做 btn-toolbar ，就可以创建一个 按钮工具栏 1234567891011121314151617181920 可以看到现在就是一个工具栏的效果，只需要更换下图标，它就是一个工具栏 注意：为了能够看到图标，我们引入 Bootstrap 的 CSS包 时不使用本地引入，使用 CDN 引入 1 按钮组在不同设备下的尺寸12345678910111213141516171819202122 Left Middle default Left Middle default Left Middle default Left Middle default 嵌套按钮组与下拉菜单这里需要引入 JS文件 和 JQuery文件 1234567891011121314151617 1 2 下拉菜单 点我 点我 垂直排列而且，我们不单单可以嵌套，事实上，我们还可以确定当前的按钮组是以怎样的方式进行排列，比如： 我们现在都是水平，但是我们不要水平了，想让其垂直 1234567 Left Middle default 所以无论是垂直排列还是水平排列，都非常容易操作。 水平为默认，垂直时我们只要加上一个类即可 自适应屏幕宽度现在有一个需求，如果我们需要三个按钮在一排中，而且充满整个屏幕，要怎么操作？ 1234567891011 Left Middle Right 按钮式下拉菜单其实把任意一个按钮放入 buttongroup 中，然后加入适当的菜单标签，它就可以作为菜单的触发器 1234567891011121314151617 按钮式下拉菜单 1 2 3 4 分裂式按钮下拉菜单1234567891011121314151617 分裂式下拉菜单 1 2 3 4 可以看到，它有一个分裂效果，事实上，它是两个按钮 拼合 而成的（按钮组），而给了我们一个错觉 按钮的尺寸那么从哪里添加大小呢？ 我们只需要在 button 中添加即可，因为我们这是分列式的，所以两个都应该给添加上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 分裂式下拉菜单 nbsp; 1 2 3 4 分裂式下拉菜单 nbsp; 1 2 3 4 分裂式下拉菜单 nbsp; 1 2 3 4 分裂式下拉菜单 nbsp; 1 2 3 4 箭头向上事实上，我们还可以让向下的箭头向上，因为无论是向下和向上，在我们真正的需求当中都是有的； 我们只需要在外层的 div 当中给它添加上一个 dropup 即可 1234567891011121314151617 分裂式下拉菜单 1 2 3 4","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"常用Linux命令的基本使用","slug":"Linux/Linux基础-Ubuntu/常用Linux命令的基本使用","date":"2019-04-27T04:39:07.000Z","updated":"2019-04-27T07:22:01.709Z","comments":true,"path":"2019/04/27/Linux/Linux基础-Ubuntu/常用Linux命令的基本使用/","link":"","permalink":"http://yoursite.com/2019/04/27/Linux/Linux基础-Ubuntu/常用Linux命令的基本使用/","excerpt":"","text":"学习 Linux 终端命令的原因 Linux 刚面世时并没有图形界面，所有的操作全靠命令完成， 如 磁盘操作、 文件存取、 目录操作、 进程管理、 文件权限 设定等 在职场中，大量的 服务器维护工作 都是在 远程 通过 SSH客户端 来完成的， 并没有图形界面， 所有的维护工作都需要通过命令来完成 在职场中， 作为后端程序员， 必须要或多或少掌握一些 Linux 常用的终端命令 Linux发行版本 中命令大概有 200 多个，但是常用的命令只有10多个而已 学习终端命令的技巧 不需要死记硬背，对于常用命令，用的多了，自然就记住了 不要尝试一次学会所有的命令， 有些命令是非常不常用的， 临时遇到，临时百度就可以 常用的Linux命令的基本使用 小技巧 ctrl + shift + = ： 放大终端窗口的字体显示 ctrl + - ： 缩小终端窗口字体显示 序号 命令 对应英文 作用 1 ls list 查看当前文件夹下的内容 2 pwd print work directory 查看当前所在文件夹 3 cd[目录名] change directory 切换文件夹 4 touch[文件名] touch 如果文件不存在，新建文件 5 mkdir[目录名] make directory 创建目录 6 rm[文件名] remove 删除指定的文件名 7 clear clear 清屏 ls查看当前文件夹下的内容 pwd查看当前所在文件夹 第一个斜线表示 根目录，home表示家目录，yaoremu表示用户名 cd[目录名]切换文件夹 注意： Linux 是 区分大小写 的 touch[文件名]如果文件不存在，新建文件 mkdir[目录名]创建目录 rm[文件名]删除指定的文件名 注意： 使用 rm[文件名] 命令，最直接删除的就是一个文件。 要删除目录时需要一些额外的设置 clear清屏","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"从零开始的Python学习","slug":"从零开始的Python学习","permalink":"http://yoursite.com/tags/从零开始的Python学习/"}]},{"title":"Ubuntu图形界面入门","slug":"Linux/Linux基础-Ubuntu/Ubuntu图形界面入门","date":"2019-04-27T04:19:56.000Z","updated":"2019-04-27T04:38:25.265Z","comments":true,"path":"2019/04/27/Linux/Linux基础-Ubuntu/Ubuntu图形界面入门/","link":"","permalink":"http://yoursite.com/2019/04/27/Linux/Linux基础-Ubuntu/Ubuntu图形界面入门/","excerpt":"","text":"Ubuntu的任务栏 搜素按钮任务栏最上方的按钮可以搜素软件 窗口操作按钮 Ubuntu 中，窗口操作按钮在窗口的左上角 菜单条 注意： Ubuntu操作系统 的菜单栏在窗口的最顶端，与 Windows操作系统有区别。 另外，Ubuntu操作系统 的图形界面中同一时间激活的窗口只能有一个","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"从零开始的Python学习","slug":"从零开始的Python学习","permalink":"http://yoursite.com/tags/从零开始的Python学习/"}]},{"title":"下拉菜单","slug":"Bootstrap/下拉菜单","date":"2019-04-26T12:53:45.000Z","updated":"2019-04-29T08:02:15.656Z","comments":true,"path":"2019/04/26/Bootstrap/下拉菜单/","link":"","permalink":"http://yoursite.com/2019/04/26/Bootstrap/下拉菜单/","excerpt":"","text":"下面需要使用到 Bootstrap 的 JS文件 以及 JQuery文件 接下来讲述4个内容点： 字体图标 下拉菜单 按钮组件 按钮式下拉菜单 字体图标可以根据官网给我们的指示来看，首先，先来了解一下组件： 无数个复用的组件，包括 字体图标、 下拉菜单、 导航、 警告框、 弹出框 … Bootstrap官网 一共给我们提供了一共 200个 字体图标，当然这些字体图标也不是它自己的，这些图标是来源于 Glyphicon Halfings 的组织 如何使用 ?使用的时候，出于性能的考虑，所有的图标都需要一个 基类 和 对应图标的 子类，而且之间是有一个空格存在的 eg: 1 而且使用的时候一定要注意，不能和其他组件混合使用，它不能在同一元素上与其他类共同存在。并且，他的使用一定要基于一个 span 标签，也就是所有的图标类必须承载在 span标签 当中 下拉菜单Bootstrap 中也给我们提供了一些下拉菜单的使用 注意： Bootstrap 的 JS 文件是依赖于 JQuery ， 所以使用时先引入 JQuery 1234567891011121314151617 下拉菜单 一 二 三 四 下拉菜单的对齐添加相关类 pull-right 、 dropdown-menu-right 1234567891011121314151617 下拉菜单 一 二 三 四 下拉菜单的标题任何下拉菜单均可以添加一个标题来声明一组的动作，比如： 现在再添加一组不同的内容，有两组不不同的内容可以添加标题来标识 1234567891011121314151617181920212223 下拉菜单 大写一到四 一 二 三 四 小写1到4 一 二 三 四 下拉菜单的分割线如果你认为加字母显得特别难看，因为他会破坏整体的结构，那么可以添加一个分割线 1234567891011121314151617181920212223 下拉菜单 一 二 三 四 一 二 三 四 禁用的菜单项在网页中，当我们选择下拉框时，不是每一项都是可以选择的，有的时候有一些项是不可以选择的，这个时候，就需要一个禁用的菜单项 1234567891011121314151617181920212223 下拉菜单 一 二 三 四 一 二 三 四 可以发现，当鼠标移动到 3 的时候，它是不可以选中的，鼠标样式会变成一个表示不允许的样式","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"文件和目录（理解）","slug":"Linux/Linux基础-Ubuntu/文件和目录（理解）","date":"2019-04-26T05:00:57.000Z","updated":"2019-04-26T07:26:34.801Z","comments":true,"path":"2019/04/26/Linux/Linux基础-Ubuntu/文件和目录（理解）/","link":"","permalink":"http://yoursite.com/2019/04/26/Linux/Linux基础-Ubuntu/文件和目录（理解）/","excerpt":"","text":"目标： 理解 Linux 文件目录的结构 单用户操作系统和多用户操作系统（科普） 单用户操作系统： 指一台计算机在同一时间 只能由一个用户使用， 一个用户独自享用系统的全部硬件和软件资源 Windows XP 之前的版本都是单用户操作系统 多用户操作系统： 指一台计算机在同一时间可以由 多个用户 使用，多个用户共同享用系统的全部硬件和软件资源 Unix 和 Linux 的设计初衷就是多用户操作系统 Windows 和 Linux 文件系统的区别Windows下的文件系统 在 Windows下，打开“计算机”，我们看到的是一个个驱动器的盘符： 每个驱动器都有自己的更目录结构，这样形成了多个树并列情形，如图所示： Linux下的文件系统 在 Linux 下，我们是看不到这些驱动盘符，我们看到的是文件夹（目录）： Ubuntu 没有盘符这个概念，这有一个根目录 【 / 】 ， 所有文件都在它下面 对于初学者的我们，最关心的就是 【 /home 】 目录，上图所示，在 【 /hone 】 目录下，分别有三个文件夹，分别叫做 【 /itheima 】 、【 /python 】 、 【 /laowang 】，这三个目录表示，这一台电脑在同一时间，可以由三个用户同时来使用，这三个用户名，分别叫itheima、python和laowang； 接下来我们继续看，【 /python 】 这个用户的目录下，还有三个文件夹，分别是 【 /Desktop 】 、 【 /Documents 】 、 【 Downloads 】 ，意味着这三个文件夹，都是属于 【 /python 】 这个用户的，而不属于其他用户； 如果 【 /python 】 这个用户还想存放其他的目录，它可以在 【 /python 】 目录下面建立不同的文件夹，在不同的文件夹存放不同的文件； 在 Linux 下， 因为是多用户操作系统，所以为了保证各个用户互相不冲突，所以 Linux 下面建立了一个非常重要的目录， 【 /home 】 目录，每个用户登录进来，各自在自己的目录下操作，但是不允许到其他用户目录下面操作，这就是 Windows操作系统 和 Linux 操作系统在 目录结构 上面一个非常大的差异 Ubuntu系统结构目录演示和简介Windows首先是 盘符，然后在 盘符 下面有对应的一个有一个文件夹 WINDOWS文件夹： 存储的是 Windows系统相关的文件，如果我们把 Windows文件夹 删掉了，那么整个 Windows系统 就瘫痪了 Program Files文件夹：存储的是我们安装过的应用程序，如果我们把这个文件夹下面的某个文件夹删掉了，那么会导致我们安装的某些应用软件没有办法正常运行了 Ubuntu 上图所示，这就是 Ubuntu 的界面，如果想在 Ubuntu系统 看到我们存储的文件，请点击 文件 ： 会弹出一个窗口，这个窗口的界面结构跟我们熟悉的 WIndows 的界面结构是非常像的，在左边是文件夹的名字，而右边是当前文件夹中又存在着哪些目录 接下来点击 计算机选项， 可以看到，右侧文件夹结构完全变了，同时有一个小细节，在任务栏上面有一个 斜线（ 在 Ubuntu 的系统中，并没有盘符的概念，我们所有的文件都是存放在根目录下的目录，而在 Ubuntu 中，根目录用 【 / 】 来表示 ），现在我们看到的这些文件夹就是存储在根目录下的目录 接下来打开 【 /home 】 目录，可以看到 【 /python 】 文件夹 那么如何来确认用户呢，我们可以点击右上角的一个 小齿轮 我们可以看到，这里有一个 Python用户，这个 Python用户 就说明我们当前登录的用户名就叫做Python，而我们在文件窗口中看到的 Python 文件夹上面有一个小房子，这个小房子就表示这个文件夹就是 Python 用户的家目录，Python 用户如果想要处理文件，就应该在自己的家目录中来进行 接下来双击小房子，我们可以看到左侧的 Home 已经高亮了，同时在右侧，显示了一些文件夹，就是保存在家目录中，默认的文件夹，其中就包括了 桌面、 文档 、 下载 等等 其他的目录Ubuntu 中，根目录下面，除了 【 /home目录 】 之外，还有其他很多的文件夹，这些文件夹有什么用呢？ /: 根目录 ： Linux下面，没有 盘符 的概念，整个磁盘最开始就是从根目录开始的 /home目录： 表示在根目录下的 home文件夹 ，而我们每个用户的文件夹都是保存在家目录中的 /etc目录： 保存一些配置文件，在一些服务器相关的配置内容，而涉及到服务器相关的配置文件，通通都是保存在 【 /etc目录 】 下的 /bin目录： 在 【 /bin目录 】 下，会保存 可执行的二进制文件，绝大多数的终端命令都是保存在 【 /bin目录 】 下的 以上是现阶段需要掌握的目录，而其他的目录可以在后续对 Linux 的使用逐渐熟悉之后，通过一些网络上一些资料去了解每个文件夹下面，都是分别保存什么样类型的文件就可以了 注意： 在 Ubuntu 的系统下，除了 【 /home目录 】 之外，整个系统的文件都是保存在 【根目录文件夹】 下面的。这句话就是在提醒我们，这里面任何一个目录我们不要因为不认识就删掉，如果把这里面的一些目录删掉了，就相当于删除了系统的文件，会导致整个系统的奔溃。所以操作的时候，所有的文件操作，尽量放在我们自己的 【 /home目录 】 下进行，而千万不要动外面的根目录","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"从零开始的Python学习","slug":"从零开始的Python学习","permalink":"http://yoursite.com/tags/从零开始的Python学习/"}]},{"title":"HTML5编辑API之Range对象","slug":"HTML/HTML5编辑API之Range对象","date":"2019-04-25T12:19:29.000Z","updated":"2019-04-29T08:05:28.765Z","comments":true,"path":"2019/04/25/HTML/HTML5编辑API之Range对象/","link":"","permalink":"http://yoursite.com/2019/04/25/HTML/HTML5编辑API之Range对象/","excerpt":"","text":"课程概要 Range对象 Range对象的基本概念 selectNode / SelectNodeContents / deleteContents 方法 setStart / setEND setStartBefore / setStartAfter /setEndBefore / setENDAfter 方法 Range对象的基本概念一个 Range对象 代表页面上的一段连续区域。 通过 Range对象 ， 可以获取 或 修改网页上的任何区域 12345678910111213141516171819202122function rangeTest(){ var html; showRangeDiv = document.getElementById(\"showRange\") //获得选取的内容 selection = document.getSelection() if(selection.rangeCount>0){ //获得选取内容的个数 html = \"你选取了>\"+selection.rangeCount + \"","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"按钮和图片","slug":"Bootstrap/按钮和图片","date":"2019-04-25T08:28:47.000Z","updated":"2019-04-29T08:08:56.739Z","comments":true,"path":"2019/04/25/Bootstrap/按钮和图片/","link":"","permalink":"http://yoursite.com/2019/04/25/Bootstrap/按钮和图片/","excerpt":"","text":"按钮在 Bootstrap 中，它给我们提供了很多样式的按钮。 比如说： 默认的、成功的、信息的、警告的或者链接的等等 123456789 default //默认 primary success //成功 info //信息 warning //警告 Link //链接 danger //危险 通过栅格系统，改变按钮的大小 123456 info info info info 可以通过设置 【 btn-block 】 属性让按钮充满父级容器1hello 那我们只能使用 button 吗？不是的。 通常情况下，button元素 和链接 a元素 是比较相似的，我们在 a 元素中也可以这么来用，eg： 1default 可以看到，其实它的区别与 按钮 的区别并不大，只不过按钮是未激活的，而 a标签 是激活的，并且比较大。 所以我们不单单只能使用 button 也可以使用 a标签 去替代掉 button，因为我们在多数开发的时候，a标签 出现的几率要高一些 也可以使用 input标签 来表示按钮; eg: 1 可以看到，几种不同设置按钮的方法差别并不大，所以可以根据自己的需求随意来进行使用，需要注意的是，作者建议我们使用 button ，因为像 input 在 Firefox 中可能会出现一些问题，可能会有bug，它的 高 的办法是没法统一的 图片在现代的 Bootstrap 版本中，它的图片也是响应式图片变化，它是如何做到的呢？ 它是把它的宽度，设为最大化，而高度自适应，但是这样会导致图片失帧，所以我们可以采取 SVG 的方式，去给它不失帧或者改变样式。 它也提供了一些圆角图片的效果 123 //圆形图片 //自带圆角的正方形图片 //自带边框效果 SVG（可缩放矢量图形）：可缩放矢量图形是基于 可扩展标记语言（标准通用标记语言的子集），用于描述二维矢量图形的一种图形格式","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"Bootstrap CSS表单、按钮和图片","slug":"Bootstrap/Bootstrap-CSS表单、按钮和图片","date":"2019-04-24T08:19:31.000Z","updated":"2019-04-29T08:00:52.550Z","comments":true,"path":"2019/04/24/Bootstrap/Bootstrap-CSS表单、按钮和图片/","link":"","permalink":"http://yoursite.com/2019/04/24/Bootstrap/Bootstrap-CSS表单、按钮和图片/","excerpt":"","text":"表单接下来介绍表单中几种最基本的实例： 内联表单 水平排列的表单 被支持的控件 静态标签 焦点状态 禁用状态 只读状态 校验状态 控件尺寸 辅助文本 eg: 123456789101112131415 email 密码 选择文件 选择你的文件 内联表单创建一个内联表单，需要加上一个类 【 class=”form-inline” 】 表单的默认样式的宽度是 100% 的，如果将其变为内联的方式，它的宽度就会 auto（自适应），并且变为了 1 行 关于 label ：必须设置 label ，如果不设置 label，屏幕阅读器是无法正确识别的； 如果实在不需要，可以选择将其隐藏，使用 【 class=”sr-only” 】 属性 123456789101112131415 email 密码 选择文件 选择你的文件 水平排列的表单有的情况下我们会使用到水平排列的表单，而且有的时候回根据内容和页面的布局来调整一下它的布局方式, 设置类为 【 class=”form-horizontal” 】 水平排列的表单需要我们主动去设置布局效果 由于默认的 水平排列 布局有点怪异，所以下面虎用到 栅格化表格 来进行表单的布局 12345678910111213141516171819202122232425262728293031 Email password 记住密码 登录 被支持的控件12345678910111213141516171819202122232425262728293031323334353637383940414243 //文本 //多行文本 Hello //复选框 吃橘子 吃苹果 //单选框 男 女 //下拉列表 //multiple属性： 表示显示所有选项 1 2 3 4 role属性 的作用是描述一个非标准的 标签 的实际作用； 比如用 div 做 button，那么设置 div 的 role = “button” ， 补助工具就可以认出这实际是个 button 静态标签静态标签，用来提示用户以怎样的的方式进行输出和输入 1请按照我的格式输入： hello@163.com 焦点状态当我们在其中一个输入框中选中的时候，可以发现其实是有一个焦点存在的，他会有一个阴影的效果，box-shadow，这就是它的一个焦点，如图： 禁用状态事实上我们在使用一些输入框，或者是点击按钮的时候，它有可能是不允许输入或者是禁用的状态，在 Bootstrap 中也有提供 1 可以看到，当鼠标移上去的时候，有一个禁用的小圆圈，代表当前是不可以使用的 禁用整个表单123456789101112131415161718192021222324252627282930313233343536373839404142434445 //文本 //多行文本 Hello //复选框 吃橘子 吃苹果 //单选框 男 女 //下拉列表 //multiple属性： 表示显示所有选项 1 2 3 4 可以看到，每一个内容都是不可选的，这样可以方便我们，不需要一一设置 只读状态12345 只读 与 不可选 是有 不一样 的点的，只读就是只读，不可选就是不可选的，我们可以后期去更改它的一些状态效果等等 校验状态事实上我们在看一些网页的时候，经常会有一些输入框会给我们一些提示，比如说成功了，或者是警告，密码不安全，或者是错误不允许输入 在 Bootstrap 中，对表单也有一个状态，比如说 success、 warning、 error、 ，使用它们只需要来添加一些简单的属性即可，添加到父类当中 1234567891011121314 //黄色 用户名 //绿色 用户名 //红色 用户名 如果感觉颜色不够明显，我们还可以添加图标,想要指定它的图片，我们可以根据官网给我们提供的组件： 在组件当中有很多的小图片，比如说我们需要一个表示成功的图片，那我们就找到相应图标，自己复制提供的字符串，直接黏贴到 class 中即可： 1234567891011//先换一个网络地址的 CDN //黄色 用户名 //用一个 span 来承载图片元素 其实它还可以 控制尺寸，是根据栅格系统来控制尺寸的，直接给它栅格多少个格就可以了 eg: 123456789101112//先换一个网络地址的 CDN //通过栅格控制控件大小 //黄色 用户名 //用一个 span 来承载图片元素 辅助文本对于辅助文本，我们只需要在 span标签 中给它添加一个 class，class的名称可以为 help-block 即可，此处就不再演示","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"操作系统（科普章节）","slug":"Linux/Linux基础-Ubuntu/操作系统（科普章节）","date":"2019-04-24T04:24:14.000Z","updated":"2019-04-26T04:59:21.411Z","comments":true,"path":"2019/04/24/Linux/Linux基础-Ubuntu/操作系统（科普章节）/","link":"","permalink":"http://yoursite.com/2019/04/24/Linux/Linux基础-Ubuntu/操作系统（科普章节）/","excerpt":"","text":"操作系统简介操作系统作为接口的示意图 没有安装操作系统的计算机，通常被称为 裸机 操作系统 概述 如果想在 裸机 上运行自己所编写的程序， 就必须用机器语言书写程序 如果计算机安装了操作系统，就可以在操作系统数安装支持的高级语言环境，用高级语言开发程序 操作系统可以直接与硬件打交道 机器语言： 计算机语言就是各种不同的 “0” 、 “1” 的组合 系统调用操作系统把所有跟硬件打交道的工作封装成了系统调用，系统调用可以理解为一个方法，举个例子：叫CPU “干活”，机器就会把系统调用翻译成对应的 “0101…” ，这样就可以让CPU做一个 加法、减法 的运算等等…，这样就叫做系统调用 系统调用的好处作为程序员要开发各种各样不同的软件，在开发软件的时候，如果操作系统提供了不同的系统调用，那么我们就可以直接来调用操作系统提供的方法，而不再需要跟 “0101” 这些枯燥的数字打交道，这就是操作系统提供系统调用的作用 小结操作系统有两个作用 可以 直接 控制各个不同的硬件进行工作 第二个作用是把操作硬件的这些方法 *封装 成一个又一个系统调用，供程序员直接访问，简化程序员的工作 举个例子：播放音乐假如我们 硬盘 有一首好听的歌曲，我们听这首歌曲就得先安装音乐播放的软件（应用程序），然后打开 软件 ，查找歌曲后点击播放 硬件的工作情况 将存放在硬盘上的歌曲从硬盘上读取出来，加载到内存 使用声卡对内存中的音频数据进行解码 再把解码后的数据发送给音箱 我们想象一下，如果我们在播放音乐时，先要写一大堆 “0101” 从硬盘上把歌曲加载到内存中，再写一大堆 “0101” 让声卡对内存中的歌曲进行解码，解码后再让声卡对 解码后的数据发送给音箱，这时，我们才能听到音乐。 十分繁琐！ 操作系统的工作情况 将硬盘、内存 与 声卡 的操作全部封装成系统调用 程序员开发音乐播放器的时候，只需要通过系统调用，从硬盘加载歌曲，然后进行解码，最后直接播放就 OK 了 ！！！ 不同应用领域的主流操作系统针对应用方向不通，可以分为四大类 桌面操作系统 服务器操作系统 嵌入式操作系统 移动设备操作系统 桌面操作系统Windows系列 用户群体大 优点：版本多、应用软件多，十分方便 缺点：安全性和稳定性差 macOS 适合于开发人员 ，基于 Unix 优点：安全性和稳定性要远远高于 Windows的操作系统，而且为程序员提供了非常好的开发环境配置 ！！ ！！ Linux 应用软件少 优点： 适用于服务器 、嵌入式 领域缺点： 应用软件少，不方便 服务器操作系统 从两个方面来理解服务器，分别是 硬件方面 和 软件方面 硬件方面： 所谓服务器就是一台电脑； 虽然外表与平时的 电脑 有所不同，但是它就是一台电脑； 软件方面： 有了硬件的电脑之后，我们就要在电脑上安装一个软件的操作系统，然后就可以对服务器进行维护和管理 服务器为什么装在大柜子里？而且房间很奇怪？ 这个房间通常称为 机房，所谓机房，是一个专门提供稳定带宽的地方，有了稳定的带宽之后，全世界各地的用户就可以通过互联网络来访问我们存在在服务器上的资源了； 譬如：我们可以打开浏览器来搜索百度，百度实际上是把 服务器 放在类似的机房里， 而用户在家里只需要打开浏览器，输入百度的网站，就可以找到这台服务器提供的资源了 机房里没有显示器、也没键盘和鼠标，那我们是如何进行维护的？通常，一个公司要把服务器放在机房之前，先要买一台电脑，买完电脑并在公司完成安装后，就拖到机房里，往机架上一装，简单配置一下 IP地址，工作人员就可以离开了； 接下来只要在我们的电脑上 安装一个软件 ，通过这个软件，我们就可以在任何地方 远程 登录服务器，对服务器进行维护以及日常的管理注意： 平时人是不会在机房里面的，因为机房里面 温度非常低，而且噪音非常大，人无法在里面长时间工作； linux 安全、稳定、免费 占有率高 linux服务器相比较 Windows Server而言，它的安全性，稳定性要比 Windows Server 高很多，而且 linux 是完全免费的； 另外，作为 linux而言，它在服务器方面 提供的相关的配套软件要比 Windows Server 齐全多得多 有关 python： 学习 python 就是为了来做 Web开发， 所谓 Web开发，就是用 python 来开发一个 Web服务器 Windows Server 付费 占有率低 各种类型的操作系统嵌入式操作系统所谓嵌入式开发，就是来开发一些只能硬件、智能机器人、智能家居等等的这些开发，随着时间的推移，经过市场的历练，现在在嵌入式开发领域，操作系统基本上是 Linux操作系统 一家独大了，为什么呢？ 因为 Linux 内核非常的小，而且是开源的，并且开发商可以根据自己的需求自行的定制，它在使用起来非常的简单； Python 这门语言，在人工智能领域以及深度学习领域非常的火爆，同时，Python 这门语言可以在 Linux 上正常的运行，因此要做智能硬件以及人工智能领域的开发，Linux 操作系统的学习也是必不可少的 移动设备操作系统 IOS Android（基于 Linux） 实际上，在以前，移动设备操作系统是归属于嵌入式开发的，因为嵌入式开发里面有个很重要的领域，就是开发智能手机和智能平板的，但是随着时间的推移： 在移动设备领域，现在几乎都是被苹果公司的 IOS操作系统 和 谷歌公司的安卓操作系统所垄断了，至于曾经的王者，例如：塞班、黑莓，以及现在默默努力的微软，在移动市场上并没有多大的市场占有率 如今，在以移动市场上，基本上就是苹果的IOS，和谷歌的安卓两大操作系统， 小科普： 安卓操作系统实际上也是由 Linux操作系统衍生出来的 虚拟机 虚拟机 （Virtual Machine） 指通过 软件 模拟的具有完整硬件功能的、运行在一个完全隔离的环境中的完整计算机系统 虚拟系统通过快速生成现有的操作系统的虚拟镜像，具有真实操作系统完全一样的功能 进入虚拟系统后，所有操作都是在这个全新的独立的虚拟系统里面进行，可以独立安装运行软件，保存数据，拥有自己的独立桌面，不会对真正的系统产生任何影响 而且能够在现有系统和虚拟镜像之间灵活切换的一类操作系统 安装虚拟机最大的好处，就是当我们想学习一个陌生的操作系统的时候，可以在不破坏已有的操作系统的基础上，安装一个全新的操作系统，在全新的操作系统中， 尽情的玩耍 ， 玩坏了就重装一遍就好了，不会对原有的操作系统产生任何影响 操作系统的作用是用来管理硬件设备的 操作系统的发展史操作系统的发展历史Unix1965年之前的时候，电脑并不像现在一样普遍，它课不是一般人能碰的起的，除非是军事或者学院的研究机构，而且当时大型主机至多能提供30台终端（30个键盘，显示器），链接一台电脑 为了解决数量不够用的问题： 1965年左右由 贝尔实验室 加入了 麻省理工学院 以及 通用电气 合作的计划 –该计划要建立一套 多使用者（multi-user）、多任务（multi-processor）、多层次（multi-level）的 MULTICS 操作系统，想让大型主机支持300台终端 1969年前后这个项目进度缓慢，资金短缺，贝尔实验室退出了研究 1969年从这个项目退出的 Ken Thompson 当时在实验室无时， 为了让一台空闲的电脑上能够运行 ‘星际旅行（Space Travel）’游戏，在8月份左右趁着妻子探亲的时间，用了一个月的世界，使用 汇编 写出了 Unix 的操作系统的原型 1970年，美国贝尔实验室的 Ken Thompson，以 BCPL语言 为基础，设计出很简单且很接近硬件的 B语言（取BCPL的首字母）， 并且他用 B语言写了第一个 UNIX 操作系统 1971年， 同样酷爱‘星际旅行（Space Travel）’的 Dennis M.Ritchie 为了能早点玩上游戏，加入了 Thompson 的开发项目，合作开发 UNIX，他的主要工作是改造 B语言，因为 B语言 的跨平台性较差 1927年， Dennis M.Ritchie 在 B语言 的基础上最终设计出了一种新的语言， 他取了 BCPL 的第二个字母作为这种语言的名字这就是 C语言 1973年初， C语言 的主题完成， Thompson 和 Ritchie 迫不及待的用它完全重写了现在大名鼎鼎的 Unix操作系统 C语言 在把 UNIX 一直到其他类型的计算机上使用时， C语言 强大的移植性（Portability） 在此显现 机器语言和汇编语言都不具有移植性，为 x86 开发的程序，不可能在 Alpha，SpaRC 和 ARM 等机器上运行 而 C语言程序 则可以使用在任意架构的处理器上，只要那种架构的处理器具有相对应的 C语言编译器和库，然后将C源代码编译，连接成目标二进制文件之后即可运行 UNIX家谱 Minix 因为 AT&T（通用电气） 的政策改变，在 Version 7 Unix 推出之后，发布新的使用条款，将 UNIX源代码 私有化，在大学中不再能使用 UNIX源代码 在私有化之后，只有一些大的公司才能够使用（如图，右下红色区域），主要在小型机市场上来使用 UNIX 操作系统 在图中间会有一个黄色的分支，这个分支是从 麻省理工学院 分出来的一套 UNIX操作系统，这个操作系统仅在 麻省理工学院 的范围内进行扩展，后来就延展出一套开源免费的叫做 Free BSD 的操作系统，但是，随着历史的发展，尤其是后来 Linux操作系统 异军突起之后， Free BSD 的用户就越来越少了；现在绝大多数人都是 Linux操作系统 的忠实粉丝 肯.汤姆逊开发出 UNIX操作系统后，贝尔实验室工作人员都广泛使用 UNIX操作系统； 而 UNIX 操作系统最开始设计的初衷是 多用户的操作系统（多个用户能够在同一时间登录到同一个电脑上使用的操作系统）；但是，肯.汤姆逊 可以以超级用户的身份登录到任何一个人的 UNIX操作系统 上，即在其他的终端上登录到其他人的电脑，这 显然是不行的； 于是 贝尔实验室 就开始对 UNIX 操作系统的源代码进行了彻底的排查，排查之后找到了 肯 在 UNIX 中留下的后门，然后把后门修改之后，重新编译并且部署了操作系统，以此来解决这个问题。 但是，在他们排查了后门之后， 肯 依旧可以以超级用户的身份登录到任意一台电脑上； 导致最后 通用电气公司 认为 UNIX 操作系统的源代码不能公开，如果公开出来，其危险性太大，于是，1979年之后，他们就把 UNIX 操作系统源代码完全的私有化，而不再允许其他人使用。 Andrew S.Tanenbaum（塔能鲍姆）教授为了在课堂上教授学生操作系统运作的细节，决定不再使用任何 AT&T 的源代码的前提下，自行开发与UNIX兼容的操作系统，以避免版权上的争议 以 小型UNIX（mini-UNIX）之意，将他取为MINIX（教学为主） Linux 1991年 林纳斯（Linus） 就读于赫尔辛基大学期间，对 Unix产生浓厚兴趣， 尝试在 Minix 上做一些开发工作 因为 Minix 知识教学使用，因此功能性不强， 林纳斯 经常要用他的终端 仿真器（Terminal Emulator）去访问大学主机上的新闻组合邮件， 为了方便读写和下载文件， 他自己编写了磁盘驱动程序和文件系统， 这些在后来成为了 Linux 第一个内核的雏形， 当时， 他年仅 21 岁！ 林纳斯 利用 GNU 的 bash 当做开发环境， gcc 当做编译工具，编写了 Linux内核， 一开始 Linux 并不能兼容 Unix 即 Unix 上跑的应用程序不能再 Linux 上跑，即应用程序与内核之间的接口不一致 一开始 Linux 只适用于 386，后来经过全世界网友的帮助，最终能够兼容多种硬件 Linux内核版本与发行版本内核（kernel） 系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序的抽象层 Linux内核版本又分为 稳定版 和 开发版， 两种版本是相互关联，相互循环 终端命令操作系统把硬件设备的管理，封装成一个又一个系统调用，方便其他的应用程序间接的管理硬件设备。由于 内核中 只有对硬件的基础访问以及系统的调用，操作的时候不方便，所以有了 终端命令 林纳斯开发 Linux 内核的时候，他封装完系统调用之后，然后为了检测系统调用是否正确，同时方便自己对硬件的操作，就包装了一个又一个终端命令，由这些终端命令来调用系统调用，间接的来操作电脑的硬件设备 在Linux内核内部，有两个重要的组成部分，一个是系统调用，方便其他的应用程序间接的访问硬件； 另外一个是 终端命令，同样是来调用所有的系统调用，然后同样也是来达到硬件管理的目的； 这样，一个Linux内核 就可以完整的自主操作 操作系统有两个作用： 管理所有的硬件设备 系统调用 发行版本所谓发行版，是一些有志向，想要开发操作系统的入。 比如：如果我们能自己开发一套操作系统，是不是就很高大上了！ 但是面对市场上茫茫多的硬件，如果我们要开发操作系统，把市场上所有的硬件设备的接口，全部自己写一遍，太消耗时间了！ 为了提高开发速度，这些开发操作系统的入，就看中了 Linux内核，既然 Linux内核 已经做到了跟所有的硬件配合的工作，那么我们就可以在 Linux内核 的基础上，来搭建另外一套 应用程序，这一套应用程序中，包含有桌面系统、基本的图形界面操作、桌面应用程序、一些桌面小游戏等等，这一套桌面的应用系统，就可以打包作为 Linux发行版； 注意：这一套 Linux发行版，在发布的时候，是包含有 Linux内核的，是两个完整的一体，共同发布的； Linux发行版，想要操作硬件，应该怎么做？既然内核已经封装好系统调用，那么发行版就不再负责与各种各样的硬件打交道，发行版直接通过 Linux内线 提供的系统调用，就可以间接的访问所有的硬件了 常见的发行版本如下： Linux发行版（也被叫做GNU/Linux发行版）通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件 Ubuntu Redhat Fedora openSUSE Linux Mint Deblan Manjaro Mageia CentOS Arch 其中 Ubuntu（乌班图）最为优秀，这也是推荐使用 Ubuntu 系统的原因； eg: 注意： 内核只有一个！！！注意： 内核只有一个！！！注意： 内核只有一个！！！","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"从零开始的Python学习","slug":"从零开始的Python学习","permalink":"http://yoursite.com/tags/从零开始的Python学习/"}]},{"title":"Bootstrap CSS栅格、代码和表格","slug":"Bootstrap/Bootstrap-CSS栅格、代码和表格","date":"2019-04-23T00:20:14.000Z","updated":"2019-04-29T08:00:38.769Z","comments":true,"path":"2019/04/23/Bootstrap/Bootstrap-CSS栅格、代码和表格/","link":"","permalink":"http://yoursite.com/2019/04/23/Bootstrap/Bootstrap-CSS栅格、代码和表格/","excerpt":"","text":"CSS栅格概述设置全局的CSS样式，基本的HTML元素均可以通过 class 设置，并且得到增强的效果，而且 Bootstrap着重介绍了 栅格系统（grid system）,也就意味着 栅格系统 非常重要，使用起来非常方便 Containers 容器栅格系统是 依赖容器 而存在的，Bootstrap 需要为页面内容和 栅格系统 包裹一个 容器Containers 好处给我们提供了一些 padding 属性，也就是像 margin 属性都有去设置一下，所以我们在使用的时候一定要包裹一个容器 123 ... 或者是使用下面这种方式，表示 百分百最宽 ，也就是能达到最大的使用范围，占据全部视口的整个容器，一般使用 container 即可 123 ... Grid systemBootstrap 给我们提供了一套响应式、移动式设备优先的流式栅格系统，它会随着屏幕的视口尺寸进行增加，系统也会自动最多分配，这里我们要记得是 12列 ，不管是在什么设备上，它最多只能承载 12列 介绍它必须通过 container 进行承载，栅格系统通用于一些系列的行与列的组合来创建一些页面布局，它有点类似于表格，但是使用起来确比表格方便得多 栅格的参数 Gird behavior 栅格系统行为表示以怎样的方式来布局 针对于不同屏幕 手机 平板 偏小桌面显示器 偏大桌面显示器 < 768px >= 768px >= 992px >= 1200px 布局方式针对于栅格系统的行为，其实就是它以怎样的方式来布局； 手机上的肯定是水平排列，在后面会有一些堆叠，然后根据屏幕的大小来自动释放 Container width 最大宽度 手机 平板 偏小桌面显示器 偏大桌面显示器 自适应 最大750px(它受最外层屏幕的限制) 790px 1170px Class preflx 前缀它给我们提供了所有的样式的使用我们必须遵循它所提供的 class 方式来进行书写，这一行是它针对不同屏幕的书写格式 手机 平板 偏小桌面显示器 偏大桌面显示器 .col-xs- .col-sm- .col-md- .col-lg- of columns 列数默认为 12列 最大的列宽 手机 平板 偏小桌面显示器 偏大桌面显示器 自适应 ~62px ~81px ~97px Gutter width 槽宽默认为 30px 其他另外它是 可嵌套的、 可偏移的 与 可以使用 列的排序 例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 .row{ margin-bottom: 20px; } .row .row{ margin-top: 10px; margin-bottom: 0px; } //通配方式： [class*=\"col-\"] 选择所有类名中含有\"col-\"的元素 [class*=\"col-\"]{ padding-top: 15px; padding-bottom: 15px; background-color: #eee; background-color: rgba(88,61,124,.15); border: 1p solid #ddd; border: 1px solid rgba(86,61,124,.2); } //注意：最大只能承载12个 //class名字 后面的数字表示当前所占的比例，1 代表 1/12 col-md-1 col-md-1 col-md-1 col-md-1 col-md-1 col-md-1 col-md-1 col-md-1 col-md-1 col-md-1 col-md-1 col-md-1 //一行承载4个 col-md-3 col-md-3 col-md-3 col-md-3 //如果内容过多，它采取自适应，自动调整高度或宽度 col-md-3col-md-3col-md-3col-md-3col-md-3col-md-3col-md-3col-md-3col-md-3col-md-3 col-md-3 col-md-3 col-md-3 //偏移 col-md-offset-偏移的个数 col-md-3 //嵌套 one first two //列的排序 col-md-9 col-md-3 CSS代码它的作用就是当我们想在网页中展示一些代码的时候，我们肯定要用到 code，比如我们会写个人博客，个人博客当中我们会 拷贝 一些代码放在上面供别人进行参考，这个时候我们就应该有一些关于代码的输入，那么它包含内联代码、用户输入、代码块、变量和程序输出 内联代码12345//这里我们不必要一定要使用容器，我们只是习惯性把容器放最外层 //我们通过 code标识 来包裹要作为代码片段的内容 For example & lt;section& gt; as inline eg: 我们可以看到代码的样式，它包含了一个尖括号以及背景和颜色突出的一个效果 用户输入单个字符用户输入在 Bootstrap 当中它模仿的是有命令行的输入方式的一个样式 123 我希望现在能键入 cmd 命令 eg: 这里我们可以看到，这个 cmd 明显是一个黑色包裹起来的代表它是一个用户输入 代码块12345 Sample text here...; eg: 可以看到它会有一个外边框，可以在里面加一些实体，比如说尖括号或者其他的一些实体效果。这里面的内容是可以直接复制的 变量123 x = y + z eg: 可以看到他是有一个 斜体的效果 程序输出123 hello world eg: 它没有什么特殊我们可以在页面上看到的一个效果，但是一般程序输出用这种方式来进行表示，既然它给我们了，我们就可以进行使用 CSS表格表格可以分为分为： 基本表格 条形状表格 带边框的表格 鼠标悬停的效果 紧凑型表格 状态类的 响应式表格 表格的样式修改，只需要修改 table 中的 class 即可 基本表格12345678910111213141516171819202122232425262728 表格标题 表格标题 表格标题 表格单元格 表格单元格 表格单元格 表格单元格 表格单元格 表格单元格 表格单元格 表格单元格 表格单元格 条形状表格条形状表格也可以称为 斑马线表格 123 ... 带边框的表格123 ... 鼠标悬停的效果123 ... 紧凑型表格123 ... 状态类的状态类主要是给单元格添加一些颜色来进行标识，它提供了 5 种，分别是： 鼠标悬停在单元格上所设置的颜色 成功的颜色 信息颜色 警告颜色 危机，或者潜伏在一些负面影响的动作的颜色 1234567891011121314151617181920212223242526272829303132333435363738 /灰色/ 表格标题 表格标题 表格标题 //绿色 表格单元格 表格单元格 表格单元格 //蓝色 表格单元格 表格单元格 表格单元格 //黄色 表格单元格 表格单元格 表格单元格 //红色 表格单元格 表格单元格 表格单元格 表格单元格 表格单元格 表格单元格 响应式表格响应式的操作我们需要在最外层创建一个 div 并且添加 【 table-responsive 】， 该表格样式当展示不完全的时候，其下方就会出现一个滚动条，让我们可以看全所有内容，eg： 1234567891011121314151617181920212223242526272829303132333435363738 表格标题 表格标题 表格标题 表格单元格表格单元格 表格单元格表格单元格 表格单元格表格单元格 表格单元格表格单元格 表格单元格表格单元格 表格单元格表格单元格 表格单元格表格单元格 表格单元格表格单元格 表格单元格表格单元格 表格单元格表格单元格 表格单元格表格单元格 表格单元格表格单元格 表格单元格表格单元格 表格单元格表格单元格 表格单元格表格单元格","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"全局CSS样式-排版","slug":"Bootstrap/全局CSS样式-排版","date":"2019-04-22T07:46:44.000Z","updated":"2019-04-29T08:08:50.462Z","comments":true,"path":"2019/04/22/Bootstrap/全局CSS样式-排版/","link":"","permalink":"http://yoursite.com/2019/04/22/Bootstrap/全局CSS样式-排版/","excerpt":"","text":"由于我们暂时只是测试，所以我们不用去添加刚才我们所添加的那个响应式布局的标题 排版排版包含：标题、页面主体、内联文本元素、对齐、改变大小写、缩略语、地址、引用 和 列表 标题HTML5 中，所有标题标签从 H1 ~ H6 均是可以使用的，另外还提供了了 【 .h1 】 ~ 【 .h6 】 类，为的是给内联属性的文本赋值一些标题的样式 在标题后面通常会有一个相对于标题小一点甚至颜色淡一点的副标题，它也提供了一个 small 标签来进行赋值操作， 也提供了 【 .small 】 类的元素来作为副标题 注意： 它与最基本的 H1 ~ H6 （不使用 Bootstrap） 还是有区别的 12345678 姚大帅哥 姚大帅哥 姚大帅哥 //副标题 姚大帅哥欢迎你的到来 页面主体Bootstrap 将全局的 fontSize（字体大小） 设置为14px，行高设置为1.428，这些属性直接赋值 body，所有的段落元素都可以生效。 另外 p标签还被设置了等高为二分之一行高，也就是 10px的底部外边距 1234hellhellohellohellohellohellohello//突出显示操作hellhellohellohellohellohellohello 文本内联元素1Hello World: 姚钊超级大帅哥 提供了类似于被删除文本的标签: del 无用文本标签： s 插入文本： ins 带下划线的文本: u 还有很多类似于小号文本，着重斜体等等…. ，它都提供了相应的使用，这些都可以参考它所给出的 API 来进行写，因为只是非常简单的通过它所给定的的标签来使用即可 文本的对齐123456//居左你好吗？//居右你好吗？//居中你好吗？ 改变字母的大小写123456//全部小写ABC//全部大写DEF//首字母大写hij 缩略语1hellohellohellohellohello eg: 地址123456 姚大帅哥 广东省汕头市潮阳区 上地三街，超级大厦，1008 P:8888 8888 列表没有样式的列表12345","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"入门例子创建","slug":"Bootstrap/入门例子创建","date":"2019-04-22T07:03:22.000Z","updated":"2019-04-29T08:08:44.584Z","comments":true,"path":"2019/04/22/Bootstrap/入门例子创建/","link":"","permalink":"http://yoursite.com/2019/04/22/Bootstrap/入门例子创建/","excerpt":"","text":"在 Bootstrap官网 我们在它展示的例子中我们可以看到一个简单的例子，只有导航和文字的页面 接下来我们完成这样一面的搭建，我们来看一下，Bootstrap 来完成这样一个页面到底有多简单，以及他给我们封装的样式到底如何使用 现在暂时先不考虑这个页面中我们为什么要使用它所给定的一些固定的格式 12345678910111213141516171819202122232425262728293031323334353637383940414243//添加一个 meta标签 因为它是一个响应式布局，我们通过一个 meta标签来设置//主要是提供自适应功能，表示宽度等于当前设备的宽度，缩放比例是当前不缩放//首先导入 Bootstrap 的Css文件: bootstrap.min.css body{ padding-top: 50px; } .starter{ padding: 40px 15px; text-align: center; } Project Name Home About Contact //自定义类 Bootstrap starter template 钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸钊哥帅到爆炸 eg:","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"素描","slug":"绘画/素描","date":"2019-04-22T05:39:19.000Z","updated":"2019-04-22T06:58:35.702Z","comments":true,"path":"2019/04/22/绘画/素描/","link":"","permalink":"http://yoursite.com/2019/04/22/绘画/素描/","excerpt":"","text":"如何排线握笔姿势将铅笔放在四根手指的上面，大拇指盖住它，食指和拇指用力，剩余的三根手指收起，握住笔 eg: 注意： 握笔千万不要太用力，要保持一个放松的状态，让自己的手腕保持放松（软下来） 排线手法运腕法最基本的排线手法； 排线过程中是手腕在运动，整个手凌空于整个画面之上，并没有压在画面上去画 要点 靠手腕的力量去运动，快速的铺出均匀而密集的线条 运腕法多用于 大面积 的绘画 eg: 注意： 线条不是来回的画，每一根线条都是独立的 小拇指支撑运腕法使用上面讲述的握笔姿势，将小拇指提出来，顶在画面上 特点 边缘整齐 画出线条的力道比运腕法更大 线条更加的密集 小拇指支撑运腕法多用于 小面积 的绘画 eg: 运臂法运笔法所画出的线条比较大,比较直，所以运臂法是用来画直线的； 素描中的长直线是用来 起型 ： 在画面的一开始用来定型，比如说要花一个玻璃瓶，就先得知道玻璃瓶有多高，有多低，具体有多宽，之后再这个范围里面去再去找它的具体形状eg: 绘画步骤 长直线是运用在起型的阶段 之后再用运腕法画出样式 最后用小拇指运腕法去塑造细节（局部） eg: 写字方式应用在塑造更加精确的形体，运用写字的方式来对画面进行绘画时，可以使画面更加精准，可以很清楚的确定自己要画的范围 eg: 练习方式千万不要一直保持一个方向去排，因为练习久了，你的手可能就只熟悉这种方向排线的手感；所以，练习运腕法的时候，第一遍排过来之后，第二遍就稍微倾斜一个角度（倾斜 15度 最适合） 注意： 运臂法 练习时千万不要犹豫， 一定要快、 准、 狠 练习大概一星期，培养出一种基本的手感 手感： 手感来自我们长期的练习，手对铅笔的记忆，只有不断地练习，手感会越来越顺手，越来越强， 画什么的都会得心应手 可能在一开始的时候，总是想着线条有没有画好，可是画到后面手感越来越好之后，你所在乎的就不是线条了，它已经变成了你的一个本能 线条的讲究均匀和稳定需要排的足够密集，长短差不多就够了 轻 — 重 — 轻（不强制要求）线条的两边的感觉是轻的，中间会比较踏实一点 轻–重–轻 的优点： 当使用 轻重轻 的线条进行一个衔接； 当两头轻的线相交，它就变成了一个稍微重一点的颜色； 这样的线条排出来的画面很均匀，具有美感 eg:","categories":[{"name":"素描","slug":"素描","permalink":"http://yoursite.com/categories/素描/"}],"tags":[{"name":"画画","slug":"画画","permalink":"http://yoursite.com/tags/画画/"}]},{"title":"HTML5增强的页面元素","slug":"HTML/HTML5增强的页面元素","date":"2019-04-22T04:18:39.000Z","updated":"2019-04-29T08:05:19.366Z","comments":true,"path":"2019/04/22/HTML/HTML5增强的页面元素/","link":"","permalink":"http://yoursite.com/2019/04/22/HTML/HTML5增强的页面元素/","excerpt":"","text":"课程概要 新增的 figure元素、 figcaption元素 新增的 details元素与 summary元素 新增的 mark元素 新增的 progress元素 新增的 meter元素 改良的 ol列表 改良的 dl列表 加以严格限制的 cite元素 和重新定义的 small元素 figure元素 以及 figcaption元素figure元素figure元素是一种组合元素，带有可选标题，figure元素用来表示网页上的一块独立的内容，将其从网页上移除之后，不会对网页的其他内容产生影响，figure元素 所表示的内容可以是图片、统计图或者是代码示例等 figcaption元素表示 figure元素 的标题，它从属于 figure元素 必须书写在 figure元素 的内部，可以书写在 figure 元素内部以及其他元素的前面或者后面，一个 figure元素 最多只允许放置一个 figcaption元素 ，但是允许放置多个其他元素 123456 美女 details元素 和 summary元素details元素details元素 是一种用于标识该元素内部的子元素可以被展开、收缩、显示的元素。 该元素具有一个 布尔类型 的 open属性，该属性值为 true 时，该元素内部的子元素应该被展开显示，当该属性为 false 的时候，其内部的子元素应该被收缩起来，不显示的。 该属性默认值是 false，页面打开时，其内部属于收缩状态。另外，details元素 内部不仅限于放置文字，还可以放置表单、插件或者是一个统计图的详细数据 summary元素summary元素 从属于 details元素，用鼠标单击 summary元素 中的文字内容时，details元素中的所有从属元素应该会被展开或者收缩，如果 details元素 没有 summary元素 ，浏览器会提供默认文字以供单击 123456789101112131415 function detail_onclick(detail){ var p = document.getElementById(\"p\"); if(detail.open){ p.style.visibility = \"hidden\"; }else{ p.stule.visibility = \"visible\"; } } 速度与激情7 你好么，这是为保罗特意打造的电影，看起来激情四射 eg: mark元素mark元素 表示页面中需要突出显示或高亮显示的对于当前用户具有参考作用的一段文字 1这是一段文字，用来测试mark元素 eg: ol HTML5 中,将 ol 进行了改良，为它添加了 start属性 与 reversed属性 start属性如果我们希望它不是在 1 开始， 而是在 5 开始，就可以使用 start属性 1234567 列表1 列表2 列表3 列表4 列表5 reversed属性使用 reversed 倒叙列表 1234567 列表1 列表2 列表3 列表4 列表5 dl在 HTML5 中，将该元素进行重新定义，重新定义后的 dl列表 表示 多个名字的列表项，每一项都包含一条或多条带有名字的 dt元素，用来表示术语， dt 元素仅跟着一个或多个 dd 元素，在一个元素内不允许有相同名字的 dt 元素，不允许有重复的术语 123456 Hello 你好就是Hello 博客 你喜欢看博客吗 cite元素表示作品的标题，例如一本书，一篇文章或者一首歌曲等的一个标题，该作品可以在页面单中被详细引用，也可以只在页面中提一下 12cite元素我最喜欢的电影是速度与激情 small元素在HTML5中，对small元素进行了重新的定义，使其从原来的通用展示性元素变为具体的专门用来标识所谓小字印刷体的一个元素； 通常在运用到免费声明，注意事项，法律规范或者版权等相关的法律文字的内容中，同时不允许应用在页面主题内容中，只允许当作额外的信息以依赖的方式内嵌在页面中使用。 注意： small元素 并不意味元素中内容字号会改变，如果想改变字号，还是得使用CSS样式进行配合来实现的 progress元素代表任务的完成进度，这个进度可以是不确定的，表示进度正在执行或者不清楚当前工作量有没有完成，也可以使用从0到某个数字，比如：从0到100中的一个数字来表示当前的完成进度情况； 这个元素表示当前任务完成具体情况的一个属性，max属性完成代表当前的工作量，它有一个最大值和最小值，分别用来规定一个范围，比如从0到100，那么最小值是0，最大值是100； 也可能工作比较繁重，那么可以从 0 到 1000，他的比例会相应的增加 javascript:1234567891011121314151617181920212223//没有达到想要的效果是，当前 js 是一个单线程，它是要执行完整个的 for循环，然后再执行内容function btn(){ //按钮事件 //for(var i = 0,i","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"Bootstrap简介","slug":"Bootstrap/Bootstrap简介","date":"2019-04-21T09:18:58.000Z","updated":"2019-04-29T08:00:18.468Z","comments":true,"path":"2019/04/21/Bootstrap/Bootstrap简介/","link":"","permalink":"http://yoursite.com/2019/04/21/Bootstrap/Bootstrap简介/","excerpt":"","text":"Bootstrap介绍 Bootstrap 是最受欢迎的 HTML 、CSS 、JS 的框架，用于开发响应式布局，移动设备优先的Web项目 Bootstrap 是为所有开发者，所有应用场景而设计的， Bootstrap 的前端是让开发更加快速，简单。所有的开发者都能快速上手、所有的功能都能适配、所有的项目都适用 三个优点 预处理脚本： 虽然我们可以直接使用 Bootstrap 提供的 CSS 样式表，但是 Bootstrap 的源码是基于最流行的 CSS 预处理脚本 Less 和Sass，你可以采用预编译的 CSS 文件快速开发，也可以从源码中定制自己需要的样式 响应式布局： 一个框架，多种设备；那么这对于我们现在来说无疑是最需要的点，我们希望我们的网页可以在电脑上展示，在平板上展示，在手机端展示，那么希望他们展示的内容都是相通的内容，那么这个时候，响应式布局给我们提供了很多的方便 特性齐全： Bootstrap提供了全面，美观的文档，你能在这里找到相应的 HTML 元素，HTLM 和 CSS 组件，以及 jQuery 插件方面的所有详细文档 注意： Bootstrap 是完全开源的，它的代码托管、开发、维护都依赖于Github 想要快速开发，使用Bootstrap是一个非常好的开源项目 Bootstrap的学习步骤 起步 全局的CSS样式 组件 JavaScript插件 定制 起步官网提供的几种下载方法生产环境的Bootstrap 使用这种方式下载的只是我们要使用的Bootstrap的几个文件，包含它的 CSS、 JS 以及字体文件（不包含文档和源码） eg: Bootstrap的源码 它包含 less 、 JavaScript 和 字体文件的源码，而且还带有文档 eg: SassBootstrap 从 less 到 Sass 的一个代码迁移移植项目，用于快速的来进行开发或者正对于 Sass 项目的引入等 下载选择 一般来说我们希望看到源码，所以下载第二个（Bootstrap源码）即可 如果我们只是单纯的使用，而且我们使用步骤也比较明确，那我们可以直接下载第一种 如果我们不想去下载，也可以直接使用 Bootstrap 给我们提供的一些 CDN 的加速服务 在下载完成后的 js 文件夹中发现，存在有两个文件 Bootstrap.js （未压缩）与 Bootstrap.min.js（压缩版本） 文件 注意： Bootstrap 是依赖于 jQuery 的，我们需要先引入一个 jQuery包 ，再来引入 Bootstrap包 基本的模板和案例eg： 如果我们觉得当前网站全是英文不是特别好理解，我们可以 Bootstrap 对应的中文网站： Bootstrap的中文网站","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"Vue.js第二课","slug":"Vue/Vue-js第二课","date":"2019-04-21T06:19:57.000Z","updated":"2019-04-30T04:31:17.787Z","comments":true,"path":"2019/04/21/Vue/Vue-js第二课/","link":"","permalink":"http://yoursite.com/2019/04/21/Vue/Vue-js第二课/","excerpt":"","text":"知识点梳理 过滤器 键盘修饰符以及自定义键盘修饰符 自定义指令 vue实例的生命周期 vue-resource 实现 get、 post、 jsonp 请求 Vue中的动画 数组的新方法forEach、 somw 、 filter 、 findIndex、 这些都是数组的新方法，都会对数组中的每一项进行遍历，执行相关操作 不同之处 forEach： 无法被中止 some： 可以通过 return true 中止 filter： 进行过滤，把符合条件的，返回得到一个新数组 findIndex： 找到对应对象的索引 过滤器概念 Vue.js 允许你自定义过滤器，可以用作一些常见的文本格式化 。 过滤器可以用在两个地方： mustache插值 v-bind表达式 过滤器应该被添加在JavaScript表达式的尾部， 由“管道”符指示; 定义一个过滤器概念过滤器 调用 时候的格式1{{ name | 过滤器的名称 }} 代表我们在输出 name 的值之前，先 调用函数 进行一下处理，并把处理的结果当作 内容 渲染到 插值表达式 中 12//过滤器的定义语法Vue.filter('过滤器的名称',function(){}) 过滤器中的 function： 第一个参数已经被规定死了，永远都是过滤器管道符前面传递过来的数据 eg: 当输出 name，调用过滤器，就自动加入了 123 的后缀 123Vue.filter('name',function(data){return data + '123'}) 过滤器的基本使用过滤器本身就是用来做 输出前 最后一层的处理，没有修改 原数据 123456789101112131415161718192021222324252627282930313233 {{ msg | msgFormat('疯狂','123') | test }} //定义一个 Vue 全局的过滤器，名字叫 msgFormat //第一个参数可以拿到管道值， 第二个位置可以进行传参 //也可以传递多个参数 Vue.filter('msgFormat',function(msg,arg,arg2){ //字符串的replace 方法，第一个参数，除了可写一个字符串之外， 还可以定义一个正则 //【 /单纯/g 】 表示全局匹配 return msg.replace(/单纯/g,arg + arg2) }) //可以多次调用过滤器，先将 原始的值 交个第一个过滤器处 //理，再调用 第二个过滤器 对第一个过滤器处理的值进行处 //理，最后把结果放回 插值表达式 Vue.filter('test',function(msg)){ return msg + '========' } //Vue实例 var vm=new Vue({ el: '#app', data: { msg: '曾经，我也是一个单纯的少年，单纯的我，傻傻地问，谁是世界上最单纯的男人' }, methods: { } }); 处理过程： 对象先交给过滤器处理，过滤器调用函数，最后返回给 插值表达式 使用 SE6 中的字符串新方法 String.prototype.padStart( maxLength, fillString=’ ‘)或 String.prototype.padEnd(maxLength,fillString=’ ‘)来填充数字 按键修饰符当用户敲击键盘的按键时，触发相关事件。 eg: 1 系统给我们提供了一些按键别名： 自定义指令以及钩子函数通过 Vue.directive() 来定义，参数1 是指令的名称，参数2 是指令的对象 123456Vue.directive('focus',{ //当绑定的元素插入到 DOM 中会执行 inserted 这个函数 inserted: function (el) { el.focus() }}) 其他的函数： 下面实例中演示了前三个主要的方法 。 如果一个文本框，或者键盘上的一个超链接等等，当你想要显示，必须经过一个步骤， 浏览器的渲染会先解析这个元素，把解析好的元素先放在内存中的 DOM树 中，才能显示； 所以，如果没有放到 DOM树上，势必也无法获得焦点 钩子函数的参数 el： 指定所绑定的元素，可以用来操作 DOM binding： 一个对象，包含以下属性： name：指令名，不包括 v- 前缀 value：指令的绑定值（计算之后），例如： v-my-directive=”1 + 1”,value的值是2 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中课用，无论值是否改变都可用。 expression：绑定值的字符串形式，例如： v-my-directive=”1 + 1”，expression的值是 “1 + 1” arg：传给指令的参数。例如： v-my-directive: foo, arg的值是 “foo” modifiers：一个包含修饰符的对象，例如： v-my-directive.foo.bar，修饰符对象 modifiers的值是（foo:true , bar:true） vnode：Vue编译生成的虚拟节点 oldVnode：上一个虚拟节点，仅在 update 和 comonentUpdated 钩子中可用 函数简写大多数情况下，我们可能想在 bind 和 update 钩子上做重复动作，并且不想关心其他的钩子函数。可以这样简写： 123Vue.directive('color-swatch',function(el, binding)){ el.style.backgroundColor = binding.value} Vue实例的生命周期什么是生命周期从 Vue实例的创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子= 生命周期事件 = 生命周期函数 主要生命周期函数分类：创建期间的生命周期函数： beforeCreate： 实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods属性 这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它 123 123456789101112131415var vm = new Vue({ el: '#app', data: { msg: 'ok' }, methods: { show(){ console.log('执行了show方法') } }, beforeCreate(){ //console.log(this.msg) //this.show() }}) 结论： 在beforeCreate 生命周期执行的时候，data 和 methods 中的数据都还没有被初始化 created： 实例已经在内存中创建 OK，此时 data 和 methods 已经创建 OK，此时还没有开始编译模板 123 123456789101112131415var vm = new Vue({ el: '#app', data: { msg: 'ok' }, methods: { show(){ console.log('执行了show方法') } }, created(){ console.log(this.msg) this.show() }}) 结论： 在 created 中，data 和 methods 都已经被初始化好了； 如果要调用 methods 中的方法，或者操作 data 中的数据，最早只能在 created 中操作 开始编译模板： 接下来表示开始编译模板，把Vue代码中的那些指令进行执行，最终在内存中生成一个编译好的最终模板字符串，然后把这个模板字符串，渲染为内存中的 DOM，此时只是在内存中渲染好了模板，并没有把模板挂载到页面中去 挂载 ： 放到页面的操作 beforeMount： 此函数执行的时候，模板已经在内存中编译好了，但是尚未挂载到页面中去，此时，页面还是旧的 这时遇到的第三个生命周期函数，表示 模板已经在内存中编译完成了，但是尚未把 模板 渲染到页面中去 123 {{ msg }} 1234567891011121314var vm = new Vue({ el: '#app', data: { msg: 'ok' }, methods: { show(){ console.log('执行了show方法') } }, beforeMount(){ console.log(document.getElementById('h3').innerText) }}) 在 beforeMount 执行的时候，页面中的元素，还没有真正替换过来，知识之前写的一些模板字符串（将要挂载） mounted ： 此时，已经将编译好的模板，挂载到了页面指定的容器中显示 如果要通过某些插件操作页面上的 DOM 节点，最早要在 mounted 中进行 只要执行完了 mounted，就表示整个 Vue 实例初始化完毕了，此时，组件以及脱离了 创建阶段，进入到了运行阶段 这是遇到的第四个生命周期函数，表示，内存中的模板已经真是的挂载到了页面中，用户已经可以看到渲染好的页面了 123 {{ msg }} 1234567891011121314var vm = new Vue({ el: '#app', data: { msg: 'ok' }, methods: { show(){ console.log('执行了show方法') } }, mounted(){ console.log(document.getElementById('h3').innerText) }}) 注意： mounted 是 实例创建期间最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其他操作的话，这个实例，就静静的 躺着我们的内存中，一动不动 运行期间的生命周期函数 这些是组件 运行阶段 的生命周期函数，只有两个： beforUpdate 和 updated 这俩时间会根据 data 数据的改变，有选择性的触发0次 到 多次 beforeUpdate： 状态改变之前执行此函数，此时 data 中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有开始重新渲染 DOM节点 这时候表示我们的界面还没有被更新， 【 数据被更新了吗? 数据肯定被更新了 】 1234 {{ msg }} 123456789101112131415var vm = new Vue({ el: '#app', data: { msg: 'ok' }, methods: { show(){ console.log('执行了show方法') } }, beforUpdate(){ console.log('界面上元素内容：' + document.getElementById('h3').innerText) console.log('data 中的 msg 数据是：' + this.msg) }}) 得出结论： 当执行 beforUpdate 的时候， 页面中显示的数据还是旧的，此时 data 数据是最新的，页面尚未和最新的数据保存同步 updated： 实例更新完毕之后调用此函数，此时 data 中的状态值和界面上显示的数据都已经完成了更新，界面已经重新渲染好了！ 这一步执行的是： 先根据 data 中最新的数据，在内存中重新渲染出一份最新的 内存DOM数 当最新的 内存 DOM数 被更新之后，会把最新的内存 DOM数，重新渲染到页面中去，这时候，就完成了数据 从 data（Modelc层） -> view（视图层）的更新 1234 {{ msg }} 123456789101112131415var vm = new Vue({ el: '#app', data: { msg: 'ok' }, methods: { show(){ console.log('执行了show方法') } }, updated(){ console.log('界面上元素内容：' + document.getElementById('h3').innerText) console.log('data 中的 msg 数据是：' + this.msg) }}) 结论 ： updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的 销毁期间的生命周期函数 beforeDestroy ： 实例销毁之前调用，在这一步，实例仍然完全可用 当执行 beforeDestory 钩子函数的时候，Vue实例 就已经 从 运行阶段，进入到了销毁阶段；当执行 beforeDestory 的时候，实例身上所有的 data 和所有的 methods，以及过滤器，指令 等等，都处于可用状态。 此时，还没有真正执行销毁的过程 destroyed： Vue实例销毁后调用。 调用后， Vue实例指示所有东西都会解绑、所有的事务监听器都会被移除，所有的之实例也会被销毁 当执行到 destroyed 函数 的时候，组件以及被完全销毁了，此时，组件中所有的数据、 方法、 指令、 过滤器…，都已经不可用了 案例：品牌管理案例 Vue不提倡操作 DOM jQuery帮我们封装了一些 DOM操作，它是用来操作 DOM 的； 而Vue是帮我们免除操作 DOM 的这个过程，所以 Vue 中一般不使用 jQuery 在 Vue 中，使用事件绑定机制，为元素指定处理函数的时候，如果加了小括号，就可以给函数传参了 HTML:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//此案例需要引入 bootstrap 框架 添加品牌 Id: Name: 搜索名称关键字： //Vue中所有的指令，在调用的时候，都以 v- 开头 //注意：有无单引号的区别，如果不写 单引号，则表示为一个变量，它就会去 data 上面 //去找； 添加了 单引号 ，则表示为 一个字符串 //注意： 如果值为数字，则不会被当做一个变量，只会被当做一个字符串，直接被指令调用 Id Name Ctime Operation //之前， v-for 中的数据都是直接从 data 上的list中直接渲染过来的 //现在，我们自定义了一个 search方法，同时，把所有的关键字，通过 //传参的形式，传递给了 search 方法 //在 search 方法内部，通过执行 for循环，把所有符合关键字的数据，保存 //到一个新数组中，返回 {{ item.id }} {{ item.ctime | dataFormat('')}} //要阻止 a标签 的默认行为并且定义一个方法 删除 {{ dt | dateFormat }} JavaScript:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233//定义全局过滤器，进行时间的格式化//所谓的全局过滤器，就是所有的VM实例都共享的Vue.filter('dataFormat',function(dataStr,pattern=''){ //这是根据给定的时间字符串，得到特定的时间 var dt = new Date(dataStr) // yyyy-mm-dd var y = dt.getFullYear() var m = dt.getMonth() + 1 var d = dt.getDate() //retrun y + '-' + m + '-' + d //模板字符串 //return `${y} - ${m} - ${d}` //如果你传过来的 pattern 经过转换 第一个 判断条件 则返回年月日 //如果不成立，就认为要得到一个最全的日期 if(pattern.toLowerCase() === ’yyyy-mm-dd‘){ return `${y} - ${m} - ${d}` }else{ var hh = dt.getHours() var mm = dt.getMinutes() var ss = dt.getSeconds() return `${y} - ${m} - ${hh} ${hh}:${mm}:${ss}` }})//自定义全局按键修饰符Vue.config.keyCodes.f2 = 113//全局的指令不带 s，私有指令才带 s//使用 Vue.directive() 定义全局指令 v-focus//注意：在定义的时候，指令的名称前面，不需要加 v- 前缀，但是，在调用的时候，//必须在指令名称前 加上 v- 前缀来进行调用//参数1： 指令的名称 //参数2：是一个对象，这个对象身上有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作Vue.directive('focus',{ //这里的 el 表示，把指令绑定到那个元素之上，这个el就表示哪个元素 //每当指令绑定到元素上的时候，会立即执行这个 bind函数，只执行一次 bind: function(el){ //注意：在每个函数中，第一个参数永远是 el，表示被绑定了指令的哪个元素， //这个 el 参数，是一个原生的 JS 对象（DOM对象） //在元素绑定了指令的时候，还没有 插入到 DOM中 去，这时调用 focus 方法没有作用 //因为，一个元素只有插入 DOM 之后，才能获得焦点 //绑定的时候执行了一次，所以插入后就没有执行，所以没有效果 //el.focus() //和JS行为有关的操作，最好在 inserted 中去执行，防止 JS行为不生效 }, //表示元素插入到 DOM 中的时候会执行 inserted 函数，只触发一次 //这是个 JS 行为，只有加载到 DOM 中，才能获得焦点，在内存中获得 //焦点没有意义； 就算是获得了焦点，最后也要重新从内存里面放到 DOM //中去； //放进 DOM 的时候要创建一下元素，放的时候，就不会再执行一次 focus() inserted: function(el){ el.focus() }, //当VNode更新的时候，会执行updated，可能会触发多次 updated: function(){ }})//自定义一个 设置字体颜色的 指令//只要把样式交给了 DOM元素，只要 DOM元素 被浏览器的渲染引擎解析，自然//也就会解析身上的样式，只要样式被解析了，最终显示到页面上，自然会把样//应用起来Vue.directive('color',{ //样式，只要通过指令绑定给了元素，不管这个元素有没有被插入到页面中去 //这个元素肯定有了一个内联的样式 //将来元素肯定会显示到页面中，这时候，浏览器的渲染引擎必然会解析样式， //应用给这个元素 bind: function(el,binding){ //el.style.color = 'red' //console.log(binding.name) //和样式相关的操作，一般都可以在 bind 中执行 //console.log(binding.value) //console.log(binding.expression) //带引号 el.style.color = binding.value }})//Vue实例var vm=new Vue({ el: '#app', data: { id: '', name: '', keywords: '',//搜索的关键字 list: [ {id: 1,name: '奔驰',ctime: new Date()}, {id: 2,name: '宝马',ctime: new Date()} ] }, methods: { add(){//添加的方法 //console.log('ok'); //分析步骤： //1.要获取 id 和 name ，直接从 data 上面获取 //2.组织出一个对象 //3.把这个对象，调用 数组的相关方法，添加到当前 data 上的 list中 //4.注意：在Vue中，已经实现了数据的双向数据绑定，每当我们修改了data中的数据，Vue会默认监听到数据的改动，自动把最新的数据应用到页面上； //5.当我们意识到上面的第四步的时候，就证明大家已经入门Vue了，我们更多的是在进行 VM 中 Model 数据的操作， 同时，在操作 Model 数据的时候，指定的业务逻辑操作； var car = { id: this.id, name: this.name, ctime: new Date()} this.list.push(car) //等号从右到左进行计算，依次赋值 this.id = this.name = '' }, del(id){ //根据id删除数据 //分析 //1.如何根据 Id, 找到要删除这一项的索引 //2.如果找到索引了，直接调用 数组的 splice方法 /* this.list.some((itme, i)=>{ if(item.id == id){ this.list.splice(i,1) //在数组的 some 方法中，如果 return true，就会立即终止这个数组的循环 return trun; } }) */ //另一种方法 var index = this.list.findIndex(item => { if(item.id == id){ return true; } }) this.list.splice(index, 1) }, search(keywords){//根据关键字，进行数据的搜索 /* var newList=[] this.list.forEach(item => { //判断是否包含关键字 if(item.name.indexOf(keywords) !=-1){ newList.push(item) } }) return newlist */ //注意： forEach、 somw 、 filter 、 findIndex、 这些都是 //数组的新方法，都会对数组中的每一项进行遍历，执行相关操作 return newList = this.list.filter(item => { //方法一：if(item.name.indexOf(keywords) != -1) //注意： SE6中，为字符串提供了一个新方法， //叫做 String.prototype.include('要包含的字符串') //如果包含，返回true，否则返回false if(item.name.includes(keywords)){ return item } }) //return newList } }});//如何自定义一个私有的过滤器（局部）var vm2 = new Vue({ el: \"#app2\", data: { dt: new Date() }， methods: { }， filters: { //定义私有过滤器 过滤器有两个条件 【过滤器名称 和 处理函数】 //过滤器调用的时候，采用的是就近原则，如果私有过滤器和全局过滤器名称一致了， //这时以私有过滤器为优先 dateFormat: function(dateStr,pattern = ''){ var dt = new Date(dataStr) var y = dt.getFullYear() var m = (dt.getMonth() + 1).toString().padStart(2,'0') var d = dt.getDate().toString().padStart(2,'0') if(pattern.toLowerCase() === ’yyyy-mm-dd‘){ return `${y} - ${m} - ${d}` }else{ var hh = dt.getHours().toString().padStart(2,'0') var mm = dt.getMinutes().toString().padStart(2,'0') var ss = dt.getSeconds().toString().padStart(2,'0') return `${y} - ${m} - ${hh} ${hh}:${mm}:${ss} ~~~~~~~~` } } }, //带 s，因为私有的内部可以有多个指令 directives: { 'fontweight': { bind: function(el,binding){ el.style.fontWeight = binding.value } }, //注意，这个 function 等同于把代码写到了 bind 和 update 中去 'fontsize': function(el,binding){ el.style.fontSize = parseInt(binding.value) + 'px' } }});//Vue不提倡这么做//document.getElementById('search').focus() some()： 根据指定的条件进行判断，如果返回true some() 就会被终止 findIndex()： 专门用来查找索引 Vue 调试工具 vue-devtools 的安装步骤和使用方法一：直接在谷歌浏览器添加插件Vue.js devtools - 翻墙安装方式 （本人测试无法使用） 方法二：本地手动安装 首先在github下载 devtools源码 ，地址：vue-devtools 再根据这篇博客进行添加，地址：手动添加 vue-devtools 方法 注意： 要想使用该插件，必须使用未被压缩过的文件 Vue.js，如果使用压缩过的 Vue.min.js ，则浏览器控制台不会出现 Vue 这一标签栏 如果还是无法使用，查看扩展工具中是否有 【 允许访问文件网址 】 安装成功就会出现如下效果 Vue-resource 实现 get、post、jsonp请求 之前的学习中，如何发起数据请求？ 要么写原生，但是原生太麻烦。 后来接触到 jQuery，然后就无法自拔了 而在 Vue 中，不推荐使用 jQuery ，因为 jQuery 要操作 DOM，而 Vue 不提倡操作 DOM，所以不需要使用 jQuery 那么我们可以使用很多的其他第三方包，比如： vue-resource，这是一个和 Vue 高度集成的一个第三方包，它能够让我们很方便的发送数据请求，像 get、 post、 jsonp 除了 Vue-resource 之外，还可以使用 ‘ axics ‘ 第三方包实现数据的请求 常见的数据请求类型？ get、 post、 jsonp 测试的URL请求资源地址 get请求地址： http://www.liulongbin.top:3005/api/getnewslist post请求地址： https://api.apiopen.top/musicBroadcasting jsonp请求地址： http://suggest.taobao.com/sug?code=utf-8&q=商品关键字&callback=cb 注意： Vue-resource 依赖于 Vue，所以先后顺序要注意 Vue-resource 向 Vue 身上又挂载了一个属性： $http，通过它可以点出一些方法， eg：this.$http.get、 this.$http.post、 this.$http.jsonp 使用方法： 使用方式： get(url, [options]) 第一个是请求的url地址 第二个options是可选的参数 post(url, [body],[options]) 第一个是请求的url地址 第二个是 body，注意：这是要发送给服务器的数据对象， 要以对象形式来存在； 因为 post 要提交一个数据，而数据就放在包里面 第三个是一些选项 jsonp(url, [options])：参数与 get 差不多，不做详解 例子： this.$http.get(‘/someUrl’,[options]).then(successCallback,errrorCallback); 请求 ‘/someUrl’ 的url地址 通过 .then 来拿到服务器返回的数据 .then 中有两个参数，一个是成功的回调，一个是失败的回调 注意：成功的回调必须要传，后面的 失败回调 是可选的 get请求1234567 1234567891011121314var vm = new Vue({ el: '#app', data: { }, methods: { getInfo(){ //发起 get 请求 //当发起 get 请求之后，通过 .then 来设置成功的回调函数 this.$http.get('http://www.liulongbin.top:3005/api/getnewslist').then(function(result){ console.log(result) }) } }}); 可以看到： status：200 // 表示成功 statusText： “ok” //表示状态码的描述信息 url: //表示请求地址 那有没有 data？ 可以在图中找，如图所示： 使用例子测试能否返回 data属性： 1234567 1234567891011121314var vm = new Vue({ el: '#app', data: { }, methods: { getInfo(){ //发起 get 请求 //当发起 get 请求之后，通过 .then 来设置成功的回调函数 this.$http.get('http://www.liulongbin.top:3005/api/getnewslist').then(function(result){ console.log(result.data) }) } }}); 控制台弹出如下数据，获取 data 信息成功 测试获取 body 的信息： 可以看到，返回的信息几乎一致，但是通过观察 result返回的值： 注意： 可以看到，虽然data也可以使用，但是data的值是虚的，所以我们建议使用 body post请求1234567 123456789101112131415var vm = new Vue({ el: '#app', data: { }, methods: { postInfo(){//发起 post 请求 application/x-wwww-form-urlencoded //手动发起的 post请求，默认没有表单格式，所以有的服务器处理不了 //通过 post 方法的第三个参数，设置 {emulateJSON : true} 提交的内容类型 为 普通表单数据格式 this.$http.post('https://api.apiopen.top/musicBroadcasting',{},{emulateJSON : true}).then(result => { console.log(result.body) }) } }}); 接下来使 post 发送数据到服务器，由于手动发起的 post请求，默认没有表单格式，所以有的服务器处理不了，所以要添加一个选项 emulateJSON： 发送请求体 添加上选项后，再次测试： 现在就可以访问了 JSONP请求1234567 12345678910111213var vm = new Vue({ el: '#app', data: { }, methods: { jsonpInfo(){//发起 jsonp 请求 this.$http.jsonp('http://suggest.taobao.com/sug?code=utf-8&q=商品关键字&callback=cb',{}).then(result => { console.log(result.body) }) } }}); 注意： 其实 箭头函数 默认就是一个 匿名函数，回调 本身就是一个匿名函数 可以看到，控制台成功返回了信息 JSOP的原理 由于浏览器的安全限制，不允许 AJAX 访问 跨域的请求（协议不同、域名不同、端口号不同的数据接口），浏览器认为这种访问不安全 可以通过动态创建 script 标签的形式，把 script标签 的 src属性，指向数据接口的地址，因为 script 标签不存在跨域限制，这种数据获取方式，称作 JSONP（注意：根据 JSONP 实现的原理，知晓，JSONP只支持Get请求） 具体实现过程： 现在客户端定义一个回调方法，预定义对数据的操作 再把这个回调方法的名称，通过URL传参的信息，提交到服务器的数据接口 服务器数据接口组织好姚发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行 客户端拿到服务器返回的字符串之后。 当做Script脚本去解析执行，这样就能够拿到 JSONP 的数据了 比如说：后端服务器的接口运行在 3344 上，而前端网站可能运行在 80 端口，那么这时候如何 跨域访问？ 如何请求数据？ 这时候，前后端开发更多是采用 JSONP，因为端口不一样 JSPON原理：动态创建 script 标签，由于 script标签 不受跨域的限制，script标签 就是来请求脚本，它把一个 src 脚本请求过来，当做 js 去解析执行 实例：模拟手动实现JSONP服务器端代码使用 node 写，然后客户端也可以请求 node服务器 的 JSONP的地址 客户端JSONP页面 先创建一个 html页面，然后托管到服务器，由于我没有安装 Visual Studio Code ，所以我暂时先托管到本地的 IIS服务器 12345 function show(){ console.log('ok') } 由于只要我们的页面被展示出来，浏览器的内存中就有一个 show() 方法，接下来手动调用 show()查看： 然后再添加一个 script标签 用于请求服务器 1234567 function show(){ console.log('ok') } 可以看到 客户端的端口 与 请求的服务器的端口不同，存在跨域限制，但是，script标签 不受跨域限制，可以请求 由于当前没有 请求的服务器，所以我们 手动创建一个node服务器（需要先安装 node.js）： 首先创建一个文件夹存放服务器脚本 app.js（任意位置） 写一个 app.js作为服务器文件 123456789101112131415//导入 http 内置模块const http = require('http')//创建一个 http 服务器const server = http.createServer()//监听 http 服务器的 request 请求server.on('request',function(req, res){ // write your code here...})//指定端口号并启动服务器监听server.listen(3000, function(){ console.log('server listen at http://127.0.0.1:3000')}) 使用 cmd 执行服务器 接下来修改 服务器脚本 的内容，添加一个 判断条件：如果你的地址等于 getscript，那么我们就可以返回一个 js脚本，因为 客户端 本来就是要请求一个脚本去执行，所以服务器需要返回一个脚本，否则 返回 ‘404’ 那么怎么才算是一个合适的脚本？ 比如：方法的调用； 我们可以在 html看到，客户端要请求的是一个 js文件 ，那么 服务器 就可以监听它的请求，给它返回一个 js文件 123456789101112131415161718192021222324252627//导入 http 内置模块const http = require('http')//创建一个 http 服务器const server = http.createServer()//监听 http 服务器的 request 请求server.on('request',function(req, res){ const url = req.url if(url === '/getscript'){ //拼接一个合法的 JS 脚本，这里拼接的是一个方法的调用 var scriptStr = 'show()' //通过 res.end() 发送给客户端，客户端 去把这个 字符串 当作 **JS代码**去解析执行 res.end(scriptStr) } else { res.end('404') }})//指定端口号并启动服务器监听server.listen(3000, function(){ console.log('server listen at http://127.0.0.1:3000')}) 接下来启动服务器，尝试使用 客户端 请求服务器的 JS脚本。 在 cmd 中启动 node服务器： 启动服务器后，在 IIS 服务器中启动 80端口 的html文件，打开控制台，可以看到，服务器成功调用并且输出了 show() 方法： 优化服务器动态调用方法功能由于 show() 方法的方法名称 写死 了，那服务器只能使用这一个方法。 在需求中，需要服务器可以 自动识别 调用的函数，所以最好就是 客户端 把方法的名称通通过 callback 来传递，服务器 拿到方法后就可以 动态拼接该方法，这样能保证方法的适用性 eg：修改HTML方法名字测试 1234567 function showInfo(){ console.log('ok') } 修改服务器代码 12345678910111213141516171819202122232425262728293031323334353637//导入 http 内置模块const http = require('http')//这个核心模块，能够帮我们解析 URL 地址，从而拿到 pathname queryconst urlModule = require('url')//创建一个 http 服务器const server = http.createServer()//监听 http 服务器的 request 请求server.on('request',function(req, res){ //const url = req.url //结构赋值 //true表示模块内部的方法，会调用另一个模块去帮我们解析成一个对象 const { pathname: url, query } = urlModule.parse(req.url, true) if(url === '/getscript'){ //拼接一个合法的 JS 脚本，这里拼接的是一个方法的调用 //var scriptStr = 'show()' //这里使用模板字符串动态调用方法 var scriptStr = `${query.callback}()` //通过 res.end() 发送给客户端，客户端 去把这个 字符串 当作 **JS代码**去解析执行 res.end(scriptStr) } else { res.end('404') }})//指定端口号并启动服务器监听server.listen(3000, function(){ console.log('server listen at http://127.0.0.1:3000')}) 接下来将 客户端的 showInfo()方法 改名字，改为showInfo123测试 服务器是否能够调用 该方法： 1234567 function showInfo123(){ console.log('ok') } 可以看到，服务器正常调用并返回到客户端 服务器修改客户端方法现在服务器端返回的脚本会执行本地定义的一些方法，服务器端只是简单地调用了一下方法； 那么服务器在调用方法的时候，能不能为方法传一个数据？ 可以，服务器为方法传递拼接好数据： 1234567 function showInfo(data){ console.log(data) } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//导入 http 内置模块const http = require('http')//这个核心模块，能够帮我们解析 URL 地址，从而拿到 pathname queryconst urlModule = require('url')//创建一个 http 服务器const server = http.createServer()//监听 http 服务器的 request 请求server.on('request',function(req, res){ //const url = req.url //结构赋值 //true表示模块内部的方法，会调用另一个模块去帮我们解析成一个对象 const { pathname: url, query } = urlModule.parse(req.url, true) if(url === '/getscript'){ //拼接一个合法的 JS 脚本，这里拼接的是一个方法的调用 //var scriptStr = 'show()' var data = { name: 'xjj', age: 18, gender: '女孩子' } //这里使用模板字符串动态调用方法 //把对象转成字符串，放到拼接的位置，这样的话，我们会调用这个方法，同时给传一个 JSON字符串类型的数据放到传递的数据中去 //相当于传递了 show()方法的一个参数，相同的道理 var scriptStr = `${query.callback}(${JSON.stringify(data)})` //通过 res.end() 发送给客户端，客户端 去把这个 字符串 当作 **JS代码**去解析执行 res.end(scriptStr) } else { res.end('404') }})//指定端口号并启动服务器监听server.listen(3000, function(){ console.log('server listen at http://127.0.0.1:3000')}) 可以看到，客户端拿到了服务器为方法拼接的对象，这就是 JSONP的实现原理 JSONP的实现原理：客户端自己不用调用，只有服务器返回一个具体方法的调用，如果我们需要拿到某个数据，服务器端就需要帮我们先把数据组织好，然后调用方法的时候传到 方法的参数就完成了","categories":[{"name":"Vue学习","slug":"Vue学习","permalink":"http://yoursite.com/categories/Vue学习/"}],"tags":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/tags/前端知识/"}]},{"title":"表单新增的元素与属性（五）","slug":"HTML/表单新增的元素与属性（五）","date":"2019-04-20T11:44:30.000Z","updated":"2019-04-29T08:11:17.903Z","comments":true,"path":"2019/04/20/HTML/表单新增的元素与属性（五）/","link":"","permalink":"http://yoursite.com/2019/04/20/HTML/表单新增的元素与属性（五）/","excerpt":"","text":"在HTML5中，大幅度的增加了与改良了input元素的种类，可以简单的使用元素来实现HTML5之前需要使用JavaScript脚本才能实现的许多功能 增加与改良的input元素 url类型、emali类型、date类型、time类型、datetime类型、datetime-local类型、month类型、week类型、number类型、range类型、search类型、Tel类型、color类型 url类型如果提交的不是一个网址，则会弹出提示请求输入网址,达到了一个检验的效果 1234 eg: email类型email的input元素是一种专门用来输入email地址的文本框，如果提交时该文本框的内容不是一个email地址的完整格式，则不允许进行提交，达到了一个检验的效果 1234 eg: date类型data类型的input元素是深受开发者喜爱的一种元素，在网页中经常需要输入各种各样的日期，例如生日，购买日期，订票等，那么data类型的input元素以日历的形式方便用户进行输入 1234 eg: time类型time类型的input元素，是一种专门用来输入时间的文本框，并且在提交时对输入时间有效性进行检查 1234 eg: datetime类型datetime类型是input元素一种专门用来输入UTC时间和日期的文本框，并且在提交时对输入的日期和时间进行有效性的检查； 它与time的区别就是，它是一个UTC的时间和日期 1234 datetime-local类型datetime-local它是input元素一种专门用来输入本地日期和时间的文本框，并且在提交时，对输入的日期和时间进行有效性的检查 1234 month元素month元素的input类型是一个专门用来输入月份的文本框，并且在提交时进行有效性的检查 1234 eg: week元素week类型的input元素是一种专门用来输入周号的一个文本框 1234 eg: number类型number类型的input元素是一种专门用来输入数字的文本框，并且在提交时进行检查，检查其中内容是否为数字，如果其中内容不为数字，则文本框内容作为空白来进行提交，也就意味着它也可以提交的，只不过提交的数据是空白，同时与输入日期时间的元素相通，number类型的input元素也具有一个最大值、最小值和一个step属性 1234 step属性意味着每次增加，是以指定的数字进行增加 eg: number类型的 valueAsNumbervalueAsNumber将文本框中的字符当做数字进行操作，而不是当成默认的字符串 制作简易计算器 1234567891011121314151617 function sum(){ var n1 = document.getElementById(\"num1\").valueAsNumber; var n2 = document.getElementById(\"num2\").valueAsNumber;; document.getElementById(\"result\").valueAsNumber = n1 + n2 } + = range元素range类型的input元素是一种只允许输入一段范围的文本框，具有最大值和最小值属性，可以设置最大值、最小值， 默认值一般是0和100，也具有 step属性 step属性： 是一个每次增加的数值，可以指定每次拖动的步幅 12 eg: search类型它是一种专门用来输入搜索关键字文本框 12 tel类型tel类型的 input元素 被设计为用来输入电话号码的专用文本框，tel类型没有特殊的限制规则，不强制输入数字 12 color类型color类型的input元素被用来设计选取颜色，提供一个颜色选择器，现在它在黑莓浏览器、chrome20以上都是支持的 1234 eg: output元素的追加在HTML5中，追加了新的元素output元素，output元素定义不同类型的输出 12345678910 function value_change(){ var number= document.getElementById(\"range\").value; document.getElementById(\"output\").value= number; } 10 eg: 表单验证1234567891011121314151617 function check(){ var emial = document.getElementById(\"email\"); if(email.value == \"\"){ alert(\"请输入email\"); return false; }else if(!email.checkValidity()){ alert(\"请输入正确的Email地址\"); return false; } } Email novalidates 表示不会对输入进行验证的表单 eg:","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"Vue.js第一课","slug":"Vue/Vue-js第一课","date":"2019-04-19T11:03:29.000Z","updated":"2019-04-21T06:15:38.873Z","comments":true,"path":"2019/04/19/Vue/Vue-js第一课/","link":"","permalink":"http://yoursite.com/2019/04/19/Vue/Vue-js第一课/","excerpt":"","text":"什么是Vue.js Vue.js是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App；Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js是最前端主流框架之一，和Angular.js、React.js一起，并成为前端三大主流框架 Vue.js是一套构建用户界面的框架，值关注视图图层，它不仅易与上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层，主要的工作就是和界面打交道 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱 提高开发效率的发展历程：原生JS（原生代码纯在兼容性） -> Jquery（屏蔽各个浏览器的兼容性） -> 前端模板引擎（不需要频繁操作DOM） -> Angular.js / Vue.js（减少不必要的DOM操作，提高渲染效率；提供了双向数据绑定概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心概念，就是让用户不再操作DOM元素，解放了程序员的双手，让程序员可以更多的时间去关注业务逻辑 在MVC中，C层（业务逻辑层）开发起来最麻烦，通常占了整个程序的70~80%的代码量，消耗主要的精力 争强自己就业时候的竞争力，人无我有，人有我优！！！ 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大；项目如果需要更换框架，则需要重新架构整个项目 库（插件）：提供某一个小功能，对项目入侵较小，如果某个库无法完成某些需求，可以很容易切换到其他库实现需求。例如： 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的MVC与前端中的MVVM的区别 MVC 是后端的分层开发概念（M【model】：处理数据、V【view】视图层、c【Controller】业务逻辑层） 数据的CRUD：增加(Create)、读取查询(Read)、更新(Update)和删除(Delete)几个单词的首字母简写。 MVVM是前端视图图层概念，主要关注于视图层分离，也就是说：MVVM把前端的视图层，分为了三部分： Model View VM ViewModel （MVVM思想的核心，因为VM是M和V之间的调度者） 前端页面中使用MVVM的思，主要是为了让我们开发更加方便，因为MVVM提供了数据的双向绑定； 注意：数据的双向绑定是由VM提供的 Vue.js 基本代码和MVVM之间的对应关系 Vue和其他框架一样，需要下载一个 .js 文件（这里使用vue- 2.4.0.js版本） 通过Vue提供的指令，很方便的就能把数据渲染到页面上，程序员不再手动操作DOM元素了【前端的Vue之类的框架，不提倡我们去手动操作DOM元素了】 当我们导入包之后，在浏览器的内存中，就多了一个 Vue 的构造函数 123456789101112131415161718192021222324//将来new的Vue实例，会控制这个元素中的所有内容//导入vue的包//创建一个Vue的实例 //我们new出来的这个 vm 对象，就是我们 MVVM 中的 VM 调度者 var vm = new Vue({ el: '#app', //表示当前new的这个Vue实例，要控制页面上的哪个区域 //这里的data激素MVVM中的 M，专门用来保存每个页面的数据 data: { //data属性中，存放的是el中要用到的数据 msg: '欢迎学习Vue' } })// Vue元素所控制的这个区域，就是我们的 V {{ msg }} Vue值 - 【基本的代码结构】 和 【插值表达式】、【v-cloak】当网速较慢时，请求数据网页就会出现原本的代码块，此时可以用 v-clock属性 来解决该问题 v-cloak：能够解决插值表达式的闪烁问题 1234567891011121314151617181920 {{ msg }} [v-clock]{ //属性选择器 display: none; } var vm = new Vue({ el: '#app', data: { msg: '123' } }) 调整网速进行测试：浏览器的调试界面 -> Network -> Online -> Slow 3G，表示慢速的一个3G网络 Vue指令之 【V-text】 和 【V-html】v-textV-text的作用和插值表达式是没有太大的区别的,那为什么还要有插值表达式和 V-text 呢？ 区别： v-test v-html V-test默认没有闪烁问题 插值表达式默认会出现闪烁问题: V-test会覆盖html标签中原本的内容 插值表达式可以在前后放置任意内容（不会覆盖） 12345678910111213 var vm = new Vue({ el: '#app', data: { msg: '123' } }) v-html 插值表达式和V-test都会把内容当中普通字符串输出,当我们将数据作为HTML语句输出时，我们就需要使用v-html来进行输出 12345678910111213 var vm = new Vue({ el: '#app', data: { msg2: '哈哈，我是一个大大的H1，我大，我骄傲' } }) V-bind绑定属性v-bind是Vue中，提供的用于绑定属性的指令。声明这是一个data变量，从而对参数进行解析 12345678910111213 var vm = new Vue({ el: '#app', data: { mytitle:'这是一个自己定义的title' } }) 注意：v-bind会把属性引号内的东西当做js代码去解析执行，即可以写合法的表达式，eg：可以使用 “ mytitle + ‘123’ “ 【变量+表达式】来作为参数 v-bind的简写v-bind可以被简写为只用“ : ”来表示，eg： V-on绑定事件Vue中提供了 【 v-on： 】 事件绑定机制 123456789101112131415161718 var vm = new Vue({ el: '#app', data: { }, methods:{ //这个methods属性中定义了当前Vue实例所有可用额方法 show:function(){ alert('Hello') } } }) 一般在js中，带 s 的关键字通常是一个数组 知识总结 如何定义一个基本的Vue代码结构 插值表达式 和 v-text v-cloak 解决插值表达式闪烁问题 v-html v-bind vue提供的属性绑定机制；缩写是【 ： 】 v-on vue提供的事件绑定机制；缩写是【 @ 】 实例：Vue指令之 ‘v-on’ 和 ‘跑马灯效果’ 点击“浪起来”：每隔一段时间都会第一个字符并放到最后；点击“低调”：停止截取 分析： 给 【浪起来】 按钮，绑定一个点击时间 v-on 或缩写 【 @ 】 在按钮的事件处理函数中，要写相关的业务逻辑代码：拿到 msg 字符串，然后调用字符串的 substring 来进行字符串的截取操作，把第一个字符截取出来，放到最后一个位置即可 为了实现点击一下按钮，自动截取的功能需要把2步骤中的代码，放到一个定时器中 在VM实例中，如果想要获取 data 身上的属性，或者调用 methods 里面的方法，必须通过 this.数据属性名 或 this.方法名 来进行访问，这里的this，就表示我们 new 出来的 VM实例对象 1234567891011121314151617181920212223242526272829303132333435363738 {{ msg }} var vm = new Vue({ el: '#app', data: { msg: '猥琐发育，别浪~~!', intervalId:null //在data上定义 定时器id，类似于全局变量，方便调用 } methods: { lang(){ //console.log(this.msg) //刚一开始定时器的值等于null，每当调用null，都会返回一个值给IntervalId，所以每次点击按钮，都会重复的开启定时器，所以需要一个条件来判断是否等于null，即是否第一次开启定时器，防止重复开启 if(this.intervalId != null) return; // => 表示内部的this指向外部的this this.intervalId = setInterval( () => { //获取到头的第一个字符 var start = this.msg.substring(0,1) //获取到后面的所有字符 var end = this.msg.substring(1) //表示从1开始截取，如果不写第二个参数，则截取剩余所有部分 //重新拼接得到新的字符串，并赋值给this.msg this.msg=end + start },400) }, stop(){ clearInterval(this.intervalId) //每当清楚了定时器之后，需要重新把 intervalId 置为null this.intervalId = null; } } }) 箭头函数 【 => 】 的作用：解决了this指向的问题，箭头函数内部的this永远和箭头函数外部的this保持一致；我们外部的this当前的指向是我们的vm实例，所以内部的指向也是vm实例 Vue有一个特点，它能监听自己身上date的改变，只要date有改变，它会立即把改变应用到页面中去。【好处：程序员值需要关系数据，不需要考虑如何重新渲染到页面】 console.log()方法：表示用于在控制台输出信息 Vue指令之 v-on的缩写 和 时间修饰符v-on的缩写，即使用‘ @ ’符号v-on 提供的事件修饰符 .stop阻止冒泡 .prevent阻止默认事件 .capture添加事件监听器使用事件捕获模式 .self只当事件在元素本身（比如不是子元素）触发时触发回调 .once事件只触发一次 【 .stop 】 阻止冒泡机制冒泡机制：先调用当前元素事件，然后再调用外层被包裹的这些元素;使用了【 .stop 】 阻止冒泡机制，就不会自动调用外层事件，只会调用当前的事件 1234567891011121314151617181920212223242526272829303132 .inner{ height: 150px; background-color: darkcyan; } var vm=new Vue({ //指定了要控制的元素 el: \"#app\", //指定了要展示的数据 data: {}, //要触发的方法 methods:{ div1Handler(){ console.log('这是触发了 inner div 的点击事件') }, btnHandler(){ console.log('则是窜了 btn按钮 的点击事件') } } }); 【 .prevent 】 阻止默认行为eg：只要显示自己定义的事件，不实现默认事件(即阻止默认行为)。eg：超链接的默认跳转事件 123456789101112131415161718192021222324 有问题，先去百度 var vm=new Vue({ //指定了要控制的元素 el: \"#app\", //指定了要展示的数据 data: {}, //要触发的方法 methods:{ linkClick(){ concole.log('触发了链接的点击事件') } } }); 【 .capture 】 添加事件监听器时使用事件捕获机制使用 【 .capture 】 实现捕获触发事件的机制，即将捕获到的事件优先运行。eg：由于DOM是默认冒泡排序机制（从内到外），我们可以使用【 .capture 】捕获外层事件，实现从外到内进行程序的运行 123456789101112131415161718192021222324252627282930313233 .inner{ height: 150px; background-color: darkcyan; } //捕获 var vm=new Vue({ //指定了要控制的元素 el: \"#app\", //指定了要展示的数据 data: {}, //要触发的方法 methods:{ div1Handler(){ console.log('这是触发了 inner div 的点击事件') }, btnHandler(){ console.log('则是窜了 btn按钮 的点击事件') } } }); 【.self】事件，表示只有自身才能触发自身的事件使用【.self】实现只有点击当前元素的时候，才会触发事件处理函数 1234567891011121314151617181920212223242526272829303132 .inner{ height: 150px; background-color: darkcyan; } var vm=new Vue({ //指定了要控制的元素 el: \"#app\", //指定了要展示的数据 data: {}, //要触发的方法 methods:{ div1Handler(){ console.log('这是触发了 inner div 的点击事件') }, btnHandler(){ console.log('则是窜了 btn按钮 的点击事件') } } }); once事件只触发一次使用【.once】只触发一次事件处理函数，类似于使用了一次事件后就将事件舍弃 123456789101112131415161718192021222324 有问题，先去百度 var vm=new Vue({ //指定了要控制的元素 el: \"#app\", //指定了要展示的数据 data: {}, //要触发的方法 methods:{ linkClick(){ concole.log('触发了链接的点击事件') } } }); 注意： 【.stop】和【.self】的区别 【.stop】阻止了所有的 冒泡行为；【.self】只会阻止自身冒泡行为的触发，并不会真正阻止 冒泡的行为； Vue指令之 【v-model】 和 【双向数据绑定】使用v-model指令，可以实现 表单元素和Model中数据的双向绑定；注意：v-model只能运用在表单元素中 只有v-model才可以实现 【双向数据绑定】 v-bind只能实现数据的单向绑定，从 M 自动绑定到 V，无法实现数据的双向绑定 12345678910111213141516 {{ msg }} var vm=new Vue({ el: '#app', data: { msg: '大家都是好学生，爱敲代码，爱学习，爱思考，简直是完美，没瑕疵！' }, methods: {} }); 我们在date身上定义的属性或者字段，Vue会帮我们挂载到vm身上 实例：简易计算器案例 代码是从上带下去执行，先加载Vue.js包，再渲染HTML页面，然后立即执行Vue脚本语言，重新为HTML中的值赋值，最后赋值完成并且输出到HTML页面中 1234567891011121314151617181920212223242526272829303132333435363738394041424344 + - * / var vm = new Vue({ el: '#app', data: { n1: 0, n2: 0, result: 0, opt: '+' }; methods: { calc(){ switch(this.opt){ case '+': this.result = parseInt(this.n1) + parseInt(this.n2) break; case '-': this.result = parseInt(this.n1) - parseInt(this.n2) break; case '*': this.result = parseInt(this.n1) * parseInt(this.n2) break; case '/': this.result = parseInt(this.n1) / parseInt(this.n2) break; } } } }); 还可以使用如下代码代替 switch()函数： eval()函数：把字符串解析执行，然后获得执行的结果 123//投机取巧的方式，正式开发中尽量少用var codeStr = 'parseInt(this.n1)' + this.opt + 'parseInt(this.n2)'this.result=eval(codeStr) 在Vue中使用样式使用class样式 数组1这是一个邪恶的H1 注意：class使用 v-bind 做数据绑定时，类名必须用单引号包起来，vue的属性则不必加单引号 数组中使用三元样式1这是一个邪恶的H1 eg: 1234567891011121314 这是一个很大很大的H1，大到你无法想象！！！ var vm=new Vue({ el: '#app', data: { flag: false }, methods: {} }); 数组中嵌套对象 在数组中使用对象来代替三元表达式，提高代码的可读性 1这是一个邪恶的H1 eg: 1234567891011121314 这是一个很大很大的H1，大到你无法想象！！！ var vm=new Vue({ el: '#app', data: { flag: true }, methods: {} }); 直接使用对象 在为 class 使用 v-bind 绑定对象的时候，对象的属性是类名，由于对象的属性可带引号，也可不带引号，所以这里可写可不写； 属性的值是一个标识符 1这是一个邪恶的H1 eg: 1234567891011121314 var vm = new Vue({ el: \"add\", data: { flag: true, classObj: { red: true, thin: true, italic: false, active: false} }, methods: {} }) 使用内联样式 对象就是无序键值对的集合 直接在元素上通过 【:style】 的形式，书写样式对象1这是一个善良的H1 如果属性中有 ‘-‘ ，则必须添加一个单引号 将样式对象，定义到 【data】 中，并直接引用到 【:style】中在 data 上定义样式：123data: { h1StyleObj: {'color': 'red','font-size': '40px','font-weight': '200'}} 在元素中，通过属性绑定的形式，将样式的对象应用到元素中：1这是一个善良的H1 在 【:style】 中通过数组，引用多个 【data】 上的样式对象在data上定义样式：1234data: { h1StyleObj: {color: 'red','font-size': '40px','font-weight': '200'}, h1StyleObj2: {fontStyle: 'italic'}} 在元素中，通过属性绑定的样式，将样式对象应用到元素中：1这是一个善良的H1 Vue指令之 【v-for】 和 【key】 属性迭代数组v-for循环普通数组12345678910111213 索引值：{{i}} --- 每一项： {{item}} var vm= new Vue({ el: '#app', data: { list: {1,2,3,4,5,6} }, methods: {} }); v-for循环对象数组1234567891011121314151617 Id: {{ user.id }} === 名字： {{ user.name }} --- 索引：{{ i }} var vm= new Vue({ el: '#app', data: { list: { id:1, name: 'zs1'}, list: { id:2, name: 'zs2'}, list: { id:3, name: 'zs3'}, list: { id:4, name: 'zs4'} }, methods: {} }); 迭代对象中的属性在遍历对象身上的键值对的时候，除了有 val key之外 ，在第三个位置还有一个索引 1234567891011121314151617 值是： {{ val }} --- 键是： {{ key }} --- 索引： {{ i }} var vm = new Vue({ el: \"#app\", data: { uesr: { id: 1, name: '托尼·斯达克', gender: '男' } }, methods: {} }) 迭代数字in 后面我们放 普通数组， 对象数组， 对象， 还可以放数字 1234567891011121314 这是第 {{count}} 个p标签 var vm=new Vue({ el: \"#app\", data: { }, methods: {} }) 如果使用用 v-for 去迭代一个数字的话，则起始位置从1开始 2.2.0+ 的版本里，单在组件中使用 v-for 时，key现在是必须的当Vue.js用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略，如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的顺序，而是简单复用此处每个元素，而且确保它在特定索引下显示已被渲染过得每个元素。 为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有的元素，你需要为每项提供一个唯一key属性。 在组件中，使用 v-for 循环的时候，或者在一些特殊情况中，如果 v-for 有问题，必须在使用 v-for 的同时，指定唯一的字符串/数字类型： key值 注意：没有使用key时，表示没有指定选中为哪一项，会导致bug；每次for循环的时候，通过制定key来标识当前循环这一项的一个唯一身份 12345678910111213141516171819202122232425262728293031323334353637383940414243 Id: Name: //注意：v-for循环的时候，key 属性只能使用 number 或 string //注意： key 在使用时，必须使用v-bind属性绑定的形式，指定key的值 {{item.id}} --- {{item.name}} var vm = new Vue({ el: \"#app\", data: { id: '', name: '', list: { {id: 1, name: '李斯'}, {id: 2, name: '嬴政'}, {id: 3, name: '赵高'}, {id: 4, name: '韩非'}, {id: 5, name: '荀子'}, } }, methods: { add(){ this.list.unshift({id: this.id, name: this.name }) } } }) key属性 能够保证数据的唯一性，让我们data上的数据与页面上的数据强制关联起来 ； 如果不使用key，程序则会值使用 v-for 来循环渲染，渲染结束后就会忘记各个DOM元素的对应关系，从而导致BUG eg: push():在数组末尾添加元素， unshift():在数组开始添加元素 Vue指令之 v-if 和 v-show一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换使用 v-show 较好，如果在运行时条件不大可能改变使用 v-if 较好 如果元素涉及到频繁的切换，最好不要使用 v-if ，而是推荐使用 v-show； 如果元素可能永远也不会被显示出来被用户看到，则推荐使用v-if v-if的特点： 每次都会重新删除或创建元素； v-show的特点： 每次不会重新进行DOM的删除和操作，知识切换了元素的 display： none 样式 v-if 有较高的切换性能消耗； v-show 有较高的初始渲染消耗 1234567891011121314151617181920 这是用v-if控制的元素 这是用v-show控制的元素 var vm=Vue({ el: \"#app\", data: { flag: true }, methods: { toggle(){ this.flag= !this.flag } } }); 知识梳理：MVC 和 MVVM 的区别MVC 是后台开发的概念，MVVM 为前端的概念。MVC站在整个项目的角度来考虑，MVVM只考虑前端页面，把前端页面分离为 Model 、 View 、 VM，其中，VM为核心，它是一个调度者，如果离开了VM，则MVVM将失去所有的优势。其中，vm提供了一个很重要的功能，即双向数据绑定 Vue基本代码的结构 导入包 创建一个要控制的元素（一般在 div标签 中加一个 id 以便控制） 变向Vue代码 注意： 不要给 body标签 加一个 id，在 Vue的版本1 里面是可以这么干的，但是在 Vue2.0 以后都不能这么写了 基本指令 插值表达式 v-cloak、 v-text、 v-html、 v-bind、 v-on、 v-model 、v-for、 v-if 、v-show； 其中： v-bind 的缩写是：【 : 】 v-on 的缩写是：【 @ 】 事件修饰符 【 .stop 】： 阻止冒泡 【 .prevent 】： 阻止默认行为 【 .capture 】： 捕获机制 【 .self 】： 自身执行 【 .once 】： 只执行一次 vm实例的属性 【 el 】： 指定要控制的区域 【 data 】： 是个对象，指定了控制的区域内要用到的数据 【 methods 】：虽然带了个 s 后缀，但是是个对象，这里可以自定义方法 学习注意事项 在vm实例中，如果要访问data上的数据，或者要访问methods中的方法，必须带this 在 v-for 中，要会使用 key 属性（只接受 string / number） v-model 只能应用于表单元素 在vue中绑定样式的两种方式 v-bind: class 、 v-bind: style v-if 有更高的切换消耗、 v-show 有更高的初始渲染消耗","categories":[{"name":"Vue学习","slug":"Vue学习","permalink":"http://yoursite.com/categories/Vue学习/"}],"tags":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/tags/前端知识/"}]},{"title":"表单新增的元素与属性（四）","slug":"HTML/表单新增的元素与属性（四）","date":"2019-04-19T08:00:33.000Z","updated":"2019-04-29T08:07:37.541Z","comments":true,"path":"2019/04/19/HTML/表单新增的元素与属性（四）/","link":"","permalink":"http://yoursite.com/2019/04/19/HTML/表单新增的元素与属性（四）/","excerpt":"","text":"文本框的list属性在HTML5中，为单行文本框增加了一个list属性，该属性的值为某个datalist元素的id。datalist元素也是HTML5中新增的元素，该元素类似于选择框，但是用户想要设定的值不在选项列表之内时，允许自行输入。datalist元素本身并不显示，而是当文本框获得焦点时以提示输入的方式显示。(类似于下拉菜单) 123456789 HTML5学习 Android学习 IOS学习 datalist属性默认是看不到的，但是为了在每个浏览器中兼容，所以还是自己设置style的display属性 eg: 文本框的autocomplete属性帮助输入所用的自动完成功能，是一个既节省输入时间有十分方便的功能，在HTML5之前，因为谁都可以看见输入的值，所以在安全方面存在缺陷，只要使用AutoComplete属性，安全性方面也可以得到很好地控制。 1234//方法同上，即使用datalist标签定义候补的值 autocomplete有两个值：on（不填写）、off 文本框的pattern属性在HTML5中，对input属性使用pattern属性，并且将属性值设为某个格式的正则表达式，在提交时会针对这些进行检查，检查其内容是否符合给定格式。当输入的内容不符合给定格式时，则不允许提交，同时在浏览器中显示提示文字，提示输入的内容必须符合给定格式。 123456 请输入内容 //该正则表达式表示随意输入3个大写字母 eg: 文本框的SelectionDirection属性这对input元素与textarea元素，在HTML5增加了SelectionDirection属性。当用户在这两个元素中用鼠标选取部分文字时，可以使用该属性来获取选取方向。当用户正向选取文字时，该属性值为“forward”，当用户反向选取文字时，该属性值为“backward”。当用户没有选取任何文字时，该属性值为“forward”。 12345678910111213 function AD(){ var control = document.forms[0]['text']; var Direction = control.selectionDirection; alert(Direction); } 一般我们会以SelectionDirection这种属性的方式来获取用户的操作然后从中获取需要的信息","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"表单新增的元素与属性（三）","slug":"HTML/表单新增的元素与属性（三）","date":"2019-04-18T08:13:44.000Z","updated":"2019-04-29T08:07:43.597Z","comments":true,"path":"2019/04/18/HTML/表单新增的元素与属性（三）/","link":"","permalink":"http://yoursite.com/2019/04/18/HTML/表单新增的元素与属性（三）/","excerpt":"","text":"标签的control属性在HTML5中，可以在标签内部放置一个表单元素，并且通过该标签的control属性来访问该表单元素 1234567891011121314151617 function setValue(){ var label = document.getElementById(\"label\"); var textbox = label.control; textbox.value=\"010010\"; } 邮箱： 请输入六为数字 文本框的placeholder属性placeholder是指当前文本框处于未输入状态时显示的输入提示。当文本框处于未输入状态且未获取光标焦点时，模糊显示输入提示文字 placeholder属性相当于文本框的提示，方便我们对当前的输入框当中的输入内容有更好的了解 12 eg: 复选框的indeterminate属性对于复选框checkbox元素来说，过去只是选取与非选取这两种状态。在HTML5中，可以在JavaScript脚本代码中对该元素使用indeterminate属性，以说明复选框处于“尚未明确是否选取状态”。 12345属性测试 var cb = document.getElementById(\"cb\"); cb.indeterminate = true; eg : 注：该属性表明checkbox有三种状态。 注：这两个属性的配合使用，我们指的是interminate与checkbox属性两种不同的属性，如果只考虑interminate与checkbox结合使用，可能会被认为复选框具有两种false或者两种true、或者是一种true一种false、另外一个false另外一个true，即四种状态来组合。但事实上，他只有三种状态，即选取、非选择和不明状态，所以写的时候，需要在JavaScript脚本中进行简单的处理。 image提交按钮的height属性和width属性针对于类型为image的input属性，HTML5新增了两个属性，height、width分别用来指定图片按钮的高度和宽度。 12345 姓名 eg:","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"PHP生成验证码","slug":"其他/PHP生成验证码","date":"2019-04-18T04:13:26.000Z","updated":"2019-04-18T06:11:57.591Z","comments":true,"path":"2019/04/18/其他/PHP生成验证码/","link":"","permalink":"http://yoursite.com/2019/04/18/其他/PHP生成验证码/","excerpt":"","text":"代码部分form.php文件 12345678910111213if (isset($_REQUEST['authcode'])) { session_start(); if (strtolower($_REQUEST['authcode'])==$_SESSION['authcode']) { echo' 输出正确'; # code... }else{ echo $_REQUEST['authcode']; echo $_SESSION['authcode']; echo' 输出错误'; } exit();} 本段代码的解析：先接受session值，将提交的值与验证码比较，如果输入正确，则显示‘输入正确’，否则依次输出提交的值、验证码的值和‘输入错误’ captcha.php文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//必须至于顶部,多服务器端记录验证码信息，便于用户输入后做校验session_start();//默认返回的是黑色的照片$image = imagecreatetruecolor(100, 30);//将背景设置为白色的$bgcolor = imagecolorallocate($image, 255, 255, 255);//将白色铺满地图imagefill($image, 0, 0, $bgcolor);//空字符串，每循环一次，追加到字符串后面 $captch_code='';//验证码为随机四个数字母字for ($i=0; $i","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"PHP相关知识","slug":"PHP相关知识","permalink":"http://yoursite.com/tags/PHP相关知识/"}]},{"title":"表单新增的元素与属性（二）","slug":"HTML/表单新增的元素与属性（二）","date":"2019-04-17T08:46:01.000Z","updated":"2019-04-29T08:07:49.566Z","comments":true,"path":"2019/04/17/HTML/表单新增的元素与属性（二）/","link":"","permalink":"http://yoursite.com/2019/04/17/HTML/表单新增的元素与属性（二）/","excerpt":"","text":"formtarget属性在HTML4中，表单元素具有一个target属性，该属性用于指定在何处打开表单提交后所需要加载的页面。 在HTML5中，可以对多个按钮分别使用formtarget属性来指定提交后在何处打开所需加载的页面。 123456789101112 提交到xx.jsp页面 提交到xx.jsp页面 提交到xx.jsp页面 提交到xx.jsp页面 提交到xx.jsp页面< /form>< /form> formtarget的五个属性 _blank：在新的浏览器页面或窗口进行打开 _self：target属性的默认值，在相同的框架frame中打开 _parent：在当前框架的父框架中进行打开 _top：在当前窗口中打开， _framename：在指定框架中打开 autofocus属性为文本框，选择框或按钮控件加上autofocus属性，当画面打开时，该控件自动获得光标焦点 12345 < /form> autofocus属性一般是用在当前页面，当前的输入框或者是按钮或者是其他的内容处于第一优先级时，才会使用该属性 required属性HTML5中新增的required属性可以应用在大多数输入元素上，在提交时，如果元素中内容为空白，则不允许提交，同时在浏览器中显示相应的提升文字 12345 提交< /button>< /form> eg: labels属性在HTML5中，为所有可使用标签的表单元素、button、select元素等，定义一个labels属性，属性值为一个NodeList对象，代表该元素所绑定的标签元素所构成的集合 12345678910111213141516171819202122 function Validate(){ var txtName=document.getElementById(\"txt_name\"); var button=document.getElementById(\"btnValidate\"); var form=document.getElementById(\"testform\"); if(txtName.value.trim()==\"\" ){ var label=document.createElement(\"label\"); label.setAttribute(\"for\",\"txt_name\"); form.insertBefore(label,button); txtName.labels[1].innerHTML=\"请输入姓名\"; txtName.labels[1].setAttribute(\"style\",\"font-size:9px;color:red\"); } }< /script> 姓名：< /label> < /form> label的for属性：for属性规定label与那个表单元素绑定 trim()：去除字符串的头尾空格","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"环回接口（Loopback）","slug":"Cisco/环回接口（Loopback）","date":"2019-04-16T03:45:08.000Z","updated":"2019-04-16T04:05:02.513Z","comments":true,"path":"2019/04/16/Cisco/环回接口（Loopback）/","link":"","permalink":"http://yoursite.com/2019/04/16/Cisco/环回接口（Loopback）/","excerpt":"","text":"概述路由器上的一个逻辑、虚拟接口。路由器默认没有任何环回接口，但是它们很容易创建。可以根据需要创建任何数目的环回端口。这些接口在路由器上与物理接口一样对待；可以给他们分配寻址信息，包括他们在路由器选择更新中的网络号，甚至在它们上可以终止IP链接，如Telnet。环回接口由于独占一个IP地址，子网掩码一般建议设为255.255.255.255 loopbackloopback接口，在网络设备（一般是路由器）上是一种特殊的接口，它不是物理接口，而是一种看不见摸不着的逻辑接口（虚拟接口），但是对于网络设备来说是至关重要的。 在网络设备上可以通过配置命令来创建一个或多个环回接口，并且可以和配置物理接口一样，配置环回接口的IP地址和掩码，环回接口的掩码一般全为1，既255.255.255.0。环回接口有一个特性，除非设备瘫痪，否则其状态一直是up。这个特征对于路由协议来说非常重要。环回接口是使用广泛的一种逻辑接口。在一个网络中，不同设备的环回接口地址以及同一设备上的不同环回接口地址应该统一规划，避免重复。 创建环回接口的原因 用来建立路由邻居 我们知道路由协议想要正常运行，大多数需要先建立邻居关系，邻居关系的稳定是路由计算正确的基石。实际运用中，常常使用环回接口来建立两个路由器之间的邻居关系。比起使用物理接口建立连接，使用环回接口可以使邻居关系更加牢固，因为就算某刻物理链路和接口发生了故障，只要能从其他途径访问到该设备，那么邻居关系就不会中断。 用来作为Router-ID 在常用的OSPF，BGP登录有协议中，都有Router-ID的概念，这相当与一台路由器的身份证号，在一个指定的范围（如一个自治系统）内只能标识一台设备，不能有重复。因为环回接口的稳定性，我们常使用一个环回接口地址来作为Router-ID，使整个设备标识稳定可靠。 使用环回接口作为Router-ID还有一个好处就是可以节省地址，因为环回接口的地址一般和业务地址没有关系，是独立规划的。 用于虚拟隧道的链接 在建立IPSec或GRE之类的虚拟隧道时，使用loopback接口可以保证整个隧道的稳定性。 用于网络连通性测试 创建并配置好环回端口之后，它的地址是能被ping或telnet的，这就可以被用来测试网络的连通性。 如何创建loopback接口Router(config)# interface loopback[number] 注意：启动OSPF路由选择进程时会选择OSPF的路由器ID。这发生在手动执行了router ospf命令或者在启动过程中加载路由器配置时。因此，如果在启用了OSPF之后再创建环回接口，那么该环回接口将不会被用作路由器ID；然而，如果重新启动路由器，默认将使用环回接口。因此，建议优先创建环回接口并给它先分配IP地址，再启动OSPF,这样可以消除关于路由器ID的困惑","categories":[{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/categories/Cisco/"}],"tags":[{"name":"Cisco知识点","slug":"Cisco知识点","permalink":"http://yoursite.com/tags/Cisco知识点/"}]},{"title":"RIPv1基本配置","slug":"Cisco/RIPv1基本配置","date":"2019-04-16T03:16:40.000Z","updated":"2019-04-16T04:53:51.387Z","comments":true,"path":"2019/04/16/Cisco/RIPv1基本配置/","link":"","permalink":"http://yoursite.com/2019/04/16/Cisco/RIPv1基本配置/","excerpt":"","text":"RIPv1基本配置#拓扑图： Lo0：表示环回口0，可以把一个环回口想象成路由器上的一个接口接了一台主机，这个主机的地址是1.1.1.1 配置命令配置路由器R1router rip //启动RIP进程 version 1 //配置RIP版本1 network 1.0.0.0 //通告网络 network 192.168.12.0 配置路由器R2router rip version 1 network 192.168.12.0 network 192.168.23.0 配置路由器R3router rip version 1 network 192.168.23.0 network 192.168.34.0 配置路由器R4router rip version 1 network 192.168.34.0 network 4.0.0.0 实验调试查看路由表show ip route 以上输出表面路由器R1学到了三条RIP路由，其中条目“R 4.0.0.0/8[120/3] via 192.168.12.2,00:00:13,Serial0/0/0”的含义如下： R：路由条目是通过RIP路由协议学来的； 4.0.0.0/8：目的网络 120：RIP路由协议的默认管理距离； 3：度量值，从路由器R1到达网络4.0.0.0/8的度量值为3跳； 192.168.12.2：下一跳地址； 00:00:13：距离下一次更新还有17（30-13）秒； Serial0/0/0：接收该条路由条目的本路由器的接口 查看路由协议配置和统计信息show ip protocols Routing Protocols is “rip”:路由器上运行的路由协议是RIP Send updates every 30 seconds,next due in 23 seconds:更新周期是30秒，距离下次更新还有23秒 Outgoing update filter list for all interfaces is not set:在入方向上没有设置过滤列表 Incoming update filter list for all interfaces is not set:在出方向上没有设置过滤列表 Invalid after 180 seconds,hold down 180,flushed after 240:路由条目如果在180秒还没有收到更新，则被标记为无效 Redistributing:rip:只允许rip协议，没有其他的协议重分布进来 Default version control:send version 1, receive version 1:默认发送版本1的路由更新，结束版本1的路由更新","categories":[{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/categories/Cisco/"}],"tags":[{"name":"Cisco强化学习","slug":"Cisco强化学习","permalink":"http://yoursite.com/tags/Cisco强化学习/"}]},{"title":"RIP概述","slug":"Cisco/RIP概述","date":"2019-04-16T02:56:07.000Z","updated":"2019-04-16T03:14:43.403Z","comments":true,"path":"2019/04/16/Cisco/RIP概述/","link":"","permalink":"http://yoursite.com/2019/04/16/Cisco/RIP概述/","excerpt":"","text":"动态路由协议包括距离向量路由协议和链路状态路由协议。RIP（Routing Information Protocols，路由信息协议）是使用最广泛的举例向量路由协议。RIP是为小型网络环境设计的，因为这类协议的路由学习及路由更新将产生较大的流量，占用过多的带宽。 概述RIP是由Xerox在70年代开发的，最初定义在RFC1058中，RIP用两种数据包传输更新：更新和请求，每个有RIP功能的路由器默认情况下每隔30秒利用UDP520端口向与它直连的网络邻居广播（RIP v1）或组播（RIP v2）路由更新。因此路由器不知道网络的全局情况，如果路由更新在网络上传播慢，将会导致网络收敛慢，造成路由环路。为了避免路由环路，RIP采用水平分割、毒性逆转、定义最大跳数、闪式更新、抑制计时五个机制来避免路由环路。 RIPv1、RIPv2相同点RIP协议分为版本1和版本2.不论是版本1或者版本2，都具备下面的特征： 都是距离向量路由协议； 使用跳数（Hop Count）作为度量值； 默认路由更新周期为30秒； 管理距离（AD）为120； 支持触发更新； 最大跳数为15跳； 支持等价路径，默认4条，最大6条； 使用UDP520端口进行路由更新； 不同点 RIPv1 RIPv2 在路由器更新的过程中不携带子网信息 在路由器更新的过程中携带子网信息 不提供认证 提供明文和MD5认证 不支持VLSM和CIDR 支持VLSM和CIDR 采用广播更新 采用组播（224.0.0.9）更新 有类别（Classful）路由协议 无类别（Classless）路由协议","categories":[{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/categories/Cisco/"}],"tags":[{"name":"Cisco强化学习","slug":"Cisco强化学习","permalink":"http://yoursite.com/tags/Cisco强化学习/"}]},{"title":"表单新增的元素与属性","slug":"HTML/表单新增的元素与属性","date":"2019-04-15T12:07:40.000Z","updated":"2019-04-29T08:10:35.097Z","comments":true,"path":"2019/04/15/HTML/表单新增的元素与属性/","link":"","permalink":"http://yoursite.com/2019/04/15/HTML/表单新增的元素与属性/","excerpt":"","text":"表单内元素的form属性在HTML4中，表单内的从属元素必须书写在表单内部，而在HTML5中，可以把他们书写在页面上任何地方，然后为该元素指定一个form属性，属性值为该表单的id，这样就可以声明该元素从属于指定表单了 123456 < /form>< /textarea> 这样做的好处是，如果你需要向页面添加一些样式，比较好添加，因为它们不会分散在表单之内了，所以添加相关的css效果，也会变得方便很多 表单内元素的formaction属性在HTML4中，一个表单之内的所有元素只能通过表单的action属性被统一提交到另一个页面，而在HTML5中可以为所有的提交按钮，增加不同的formaction属性，使单击不同的按钮时可以将表单提交到不同的页面 123456 提交到xx.jsp页面 提交到xx.jsp页面 提交到xx.jsp页面< /form> 表单内元素的formmethod属性在HTML4中，一个表单内只能有一个action属性用来对表单内所有元素统一指定提交页面，所以每个表单内页只有一个method属性来统一指定提交方法。在HTML5中，可以使用formmethod属性来对每一个表单元素指定不同的提交方法。 提交方法：提交时最常用的有像GET和POST两种方式 1234 提交 提交< /form> 表单内元素的formenctype属性在HTML4中，表单元素具有一个enctype属性，该属性用于指定在表单发送到服务器之前应该如何对表单内的数据进行编码； 在HTML5中，可以使用formenctype属性对表单元素分别指定不同的编码方式； 1234 < /form> formenctype的三种属性 text/plain属性：表单数据中的空格被转换为加号，但不对表单数据中的特殊字符进行编码 multipart/form-data属性：不对字符进行编码，在使用包含文件上传控件的表单时，必须使用改值 application/x-www-form-urlencoded属性：发送前编码所有字符，当表单元素的action属性为get时浏览器则用当前的编码方式把表单数据转换成一个字符","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"Valine-访问被api域名白名单拒绝","slug":"其他/Valine-访问被api域名白名单拒绝","date":"2019-04-15T09:01:37.000Z","updated":"2019-04-15T09:09:39.087Z","comments":true,"path":"2019/04/15/其他/Valine-访问被api域名白名单拒绝/","link":"","permalink":"http://yoursite.com/2019/04/15/其他/Valine-访问被api域名白名单拒绝/","excerpt":"","text":"发现错误 打开LeanCloud控制台点击设置->安全中心 添加相关网站网址 回到网站刷新查看 成功解决！","categories":[{"name":"教学","slug":"教学","permalink":"http://yoursite.com/categories/教学/"}],"tags":[{"name":"github搭建个人博客","slug":"github搭建个人博客","permalink":"http://yoursite.com/tags/github搭建个人博客/"}]},{"title":"为博客添加域名","slug":"其他/为博客添加域名","date":"2019-04-15T08:32:11.000Z","updated":"2019-04-15T08:54:09.706Z","comments":true,"path":"2019/04/15/其他/为博客添加域名/","link":"","permalink":"http://yoursite.com/2019/04/15/其他/为博客添加域名/","excerpt":"","text":"阿里云上购买域名 购买后点击解析 修改IP以及主机记录获得博客IP的方法：在cmd页面ping博客”.github.io后缀”的域名 eg: 点击修改弹出如下窗口，填入相关信息 eg: 记录值中填入博客的IP以及修改主机记录（随意），其他选项默认 创建CNAME文件放入仓库在站点的source文件夹下创建CNAME文件 在CNAME中写入你购买的站点名 添加域名成功！","categories":[{"name":"教学","slug":"教学","permalink":"http://yoursite.com/categories/教学/"}],"tags":[{"name":"github搭建个人博客","slug":"github搭建个人博客","permalink":"http://yoursite.com/tags/github搭建个人博客/"}]},{"title":"新增的非主体结构元素（一）","slug":"HTML/新增的非主体结构元素（一）","date":"2019-04-14T08:17:09.000Z","updated":"2019-04-29T08:09:46.811Z","comments":true,"path":"2019/04/14/HTML/新增的非主体结构元素（一）/","link":"","permalink":"http://yoursite.com/2019/04/14/HTML/新增的非主体结构元素（一）/","excerpt":"","text":"在HTML5中，还增加了一些用来表示逻辑结构或者是附加信息的非主体结构元素 header元素 footer元素 hgroup元素 address元素 header元素header元素是一种具有引导和导航作用的结构元素，通常用来放置整个页面或页面内的一个内容区块的标题，但是也可以包含其他内容，例如数据表格、搜索歌单或相关的logo图片 以前我们是通过一个div包裹然后给它设定一个class或者id指定是header用来包含整个页面或页面内的区域块的一个标题 注意：header的出现不一定只有一次，它可以出现多次，不论是在整个页面来表示他的标题，或者说区域块来表示标题都是可以的 旧版的写法1234< /div>< /div>< /div> ##现在的写法 1234567891011 页面标题< /h1>< /header> Hello< /h1> < /header>< /article> 通常一个header元素至少包含一个h元素 完整的例子123456789101112 IT最新技术< /h1> 姚的博客< /a> 学习< /a>< /li> 技术< /a>< /li> 运动< /a>< /li> < /ul> < /nav>< /header>","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"新增的主题结构元素（七）","slug":"HTML/新增的主题结构元素（七）","date":"2019-04-14T07:49:26.000Z","updated":"2019-04-29T08:06:04.101Z","comments":true,"path":"2019/04/14/HTML/新增的主题结构元素（七）/","link":"","permalink":"http://yoursite.com/2019/04/14/HTML/新增的主题结构元素（七）/","excerpt":"","text":"footer元素footer元素可以作为其上层父级内容区块或是一个根区块的脚注。footer通常包括其相关区块的脚注信息，如作者、相关阅读链接及版权信息等。 旧版本和新版本的书写区别旧版的书写方式12345678 版权信息< /a>< /li> 站点地图< /a>< /li> 联系方式< /a>< /li> < /ul>< /div> 新版的书写12345678 版权信息< /a>< /li> 站点地图< /a>< /li> 联系方式< /a>< /li> < /ul>< /footer> footer元素的使用与header元素的使用相似footer元素与header元素一样，一个页面也限制为必要使用一个数量，在当前的页面当中，未必只包含一个footer用来表示底部，它还可以在一个区域块当中进行表示（与header元素的使用比较相似）； eg: 123456789101112 这是一个文章的底部 < /footer>< /article> 这是一个文章的底部 < /footer>< /section> hgroup元素hgroup元素是将标题及其子标题进行分组的元素。hgroup元素通常会将h1~h6元素进行分组，譬如一个内容区块的标题及其子标题算一组 当我们需要为主标题加上一个子标题的时候，尤其是一些文章，或者是一些我们看到的广告，它会有子标题 当只有一个标题的时候，我们就没有必要去使用hgroup;当标题过多，第一个和第二个是同一级，而且他是属于第一个的子标题的时候，此时我们应该使用hgroup将其包裹起来，代表当前他是一个子标题 1234567891011121314151617181920212223 这是文章标题 < /h1> 这是一个子标题< /h2> < /hgroup> 2015-10-10< /time>< /p> < /header> 这是内容 < /div> 这是底部 < /footer>< /article> 内容区域块使用div重载，存在的样式都通过div来进行添加一些css样式","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"新增的主题结构元素（六）","slug":"HTML/新增的主题结构元素（六）","date":"2019-04-14T06:42:30.000Z","updated":"2019-04-29T08:06:10.608Z","comments":true,"path":"2019/04/14/HTML/新增的主题结构元素（六）/","link":"","permalink":"http://yoursite.com/2019/04/14/HTML/新增的主题结构元素（六）/","excerpt":"","text":"address元素address元素的简介address元素用来在文档中呈现联系信息，包括文档作者或者文档维护者的名字、他们的网络链接、电子邮箱、真实地址、电话号码等。address应该不只用来呈现电子邮箱或真实地址，还用来展示跟文档相关的联系人的所有联系地址。 123456789101112131415 < /a> < /a>< /address> < /a> 欢迎来到Yaoremu的博客 < /address> 2015-10-10< /time> < /div>< /footer> HTML5的结构大纲编排的规则显示编排内容区域块显示编排是指明确的使用section等元素创建文档结构，在每个区域块使用标题，类似与< h1 > ~ < h6 >或< hgroup >等…… 隐示编排内容区域块所谓隐示编排指不明确使用section等元素，而是根据网页需求，来写各级的< h1 > ~ < h6 >或者< hgroup >，把各级内容区域块自动创建出来 标题分级从< h1 > ~ < h6 >它的级别是不同的，更具标题不同，那么级别也不同。如果新的出现的标题比上一个标题级别低，将生成下级内容区域块；如果新出现的标题比上一标题级别要高，或者两者级别相等的情况下，将生成新的区域块 不同区域块使用相同级别标题eg: 123456789101112131415161718192021222324252627282930 网页标题< /h1> 首页< /a>< /li> 帮助< /a>< /li> < /ul> < /nav>< /header> 文章主标题< /h1> 文章子标题< /h2> < /hgroup> 文章正文< /p> 评论标题< /h1> 评论正文< /p> < /article> < /div> < /section>< /article> 版权所有...< /small>< /footer>","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"新增的主题结构元素（五）","slug":"HTML/新增的主题结构元素（五）","date":"2019-04-13T12:25:46.000Z","updated":"2019-04-29T08:10:26.781Z","comments":true,"path":"2019/04/13/HTML/新增的主题结构元素（五）/","link":"","permalink":"http://yoursite.com/2019/04/13/HTML/新增的主题结构元素（五）/","excerpt":"","text":"time元素与微格式微格式：它是一种利用HTML5的class属性来对网页添加的附属信息的方法，那么附加的信息有可能新闻发生的时间，日期，个人电话号码，企业邮箱等，微格式并不是在HTML5之后才有的，在HTML5之前它就和HTML结合使用了，但是在使用过程当中发现日期和时间的机器编码上出现了一些问题，编码过程中会产生一些歧义。HTML5增加了一个新的元素，来无歧义的，明确的对机器码时间、日期进行编码，并且让人一读，很容易认出它，这个元素就是TIME元素 Time元素： Time元素代表的是24小时中某一个时刻或者某一个日期，它是允许带时差的 12342015-10-10< /time>2015-10-10< /time>2015-10-10< /time>2015-10-10< /time> 编码时，机器读到的在datetime属性当中，而元素的开始标记和结束标记之间的部分是显示在网页上的 datetime属性 日期与时间之间用T来表示，它是一个间隔分隔符（T代表的是Time） Z表示的是机器编码使用的是UTC标准时间 +时间：表示另一地区的时差，如果是在本地编码，而且是在本地使用就不需要再加这个时差 pubdate属性pubdate是一个可选的，布尔类型的值得属性，它可以用在article元素中的time元素上，意思是time元素代表了文章或者整个网页的发布日期，pubdate属性的具体使用方法通过下面案例来演示。 提问：为什么使用pubdate属性，为什么不能直接使用time表示当前发布的一个日期 1234567891011 苹果< /h1> 发布日期 2015-10-10< /time> < /p> 舞会时间 2015-10-12< /time> < /p> < /header>< /article> 此时程序中有两个time，所以我们要有一个明确的time来指出他是一个发布时间，这个时候我们就在第一个time中加上一个pubdate，用它来表示当前具体的发布时间","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"新增的主题结构元素（四）","slug":"HTML/新增的主题结构元素（四）","date":"2019-04-13T11:48:11.000Z","updated":"2019-04-29T08:07:01.553Z","comments":true,"path":"2019/04/13/HTML/新增的主题结构元素（四）/","link":"","permalink":"http://yoursite.com/2019/04/13/HTML/新增的主题结构元素（四）/","excerpt":"","text":"section元素section元素用于对网站或应用程序中页面上的内容进行分块。一个section元素通常由内容及其标题组成。但section元素并非一个普通的容器元素；当一个容器需要被直接定义样式或通过脚本定义行为时，推荐使用div而非section元素。 通常不推荐为那些没有标题内容使用section元素。 section元素的作用是对页面上的那些内容进行分块，或者说对文章进行分段，请不要与有了自己完整的独立的内容的aritcle元素进行混淆。 123456789101112131415161718 苹果< /h1> 这是一个苹果，可以吃。而且很好吃< /p>< /section> 苹果< /h1> 这是一个苹果，可以吃。而且很好吃 红富士< /h2> 这是一种外表很红的苹果，吃起来也不赖< /p> < /section> 国光< /h2> 这是一种外表很红的苹果，吃起来也不赖< /p> < /section>< /article> 第一行不适用section的原因：这里可以使用section元素，但是由于其结构非常清晰，分析器可以识别第一行内容在一个section元素当中，所以可以将第一个section进行省略 section与article的区别123456789 水果< /h1> pingguo< /h2> 内容< /p> < /article>< /section> 在HTML5中，article元素可以看成是一个特殊类的section元素，它比section元素更加强调独立性，既section元素强调分段或分块，而article元素强调的是独立性。具体来说，如果一块内容相对于比较独立、完整的时候，应该使用article元素；但如果想将一块内容分为几段，那这个时候可以使用section元素。 在HTML5中，div元素作为一个容器的存在，当使用css样式时，可以对这个容器进行总体的css样式的嵌套;即不要讲section元素作为设置样式页面的容器，这是div的工作 总结 不要讲section元素作为设置样式的页面容器； 如果article元素、aside元素、nav元素更符合使用条件，那不要使用section元素 没有标题内容，不要section元素；section元素是要存在一个标题的","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"新增的主题结构元素（三）","slug":"HTML/新增的主题结构元素（三）","date":"2019-04-12T06:24:38.000Z","updated":"2019-04-29T08:07:08.427Z","comments":true,"path":"2019/04/12/HTML/新增的主题结构元素（三）/","link":"","permalink":"http://yoursite.com/2019/04/12/HTML/新增的主题结构元素（三）/","excerpt":"","text":"nav元素是一个可以用在页面导航的连接组，其中的导航元素链接到其他的页面或当前页面的其他部分。并不是所有的连接组都要被放进nav元素，只需要将主要的、基本的链接组放进nav元素即可。 nav元素的应用场景： 传统导航条 侧边栏导航 页内导航 翻页操作 nav元素通常承载一个列表元素 nav元素是可以多处使用的 12345678910111213141516171819202122232425262728293031 主页< /a>< /li> 开发文档< /a>< /li>< /nav> HTML5与CSS3的历史< /h1> HTML5历史< /a>< /li> CSS3历史< /a>< /li> < /ul> < /nav> < /header> HTML5历史< /h1> ....< /p> < /section> CSS3的历史< /h1> ....< /p> < /section> 删除< /a> 修改< /a> < /footer>< /article> 版权声明：< /small>< /p>< /footer> 标签定义文档中的节（section、区段）。比如：章节、页眉、页脚或文档中的其他部分。 注意：HTML5中不能使用menu元素代替nav元素。manu元素是用在一系列发出命令的菜单上的，是一种交互性的元素，确切点说是使用在web应用程序中的。","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"新增的主题结构元素（二）","slug":"HTML/新增的主题结构元素（二）","date":"2019-04-12T05:41:59.000Z","updated":"2019-04-29T08:06:16.599Z","comments":true,"path":"2019/04/12/HTML/新增的主题结构元素（二）/","link":"","permalink":"http://yoursite.com/2019/04/12/HTML/新增的主题结构元素（二）/","excerpt":"","text":"aside元素aside元素用来表示当前页面或文章的附属信息部分，它可以包含与当前页面或主要内容相关的引用，侧边栏、广告、导航条以及其他类似有区别于主要内容的部分。 article元素内使用aside元素是针对于article元素的名词解释；eg：在< p>下面存放了一个aside元素，用来存放名词解释的部分； 12345678 语法< /h1> 文章的正文......< /p> 名词解释< /h1> 语法：这是一个对语言来说很重要的内容体< /p> < /aside>< /article> article元素之外使用作为页面或站点全局的附属信息部分，最典型的形式是侧边栏，其中的内容是可以有一些链接，博客中的或者是文章列表、广告单元等等； （我们也可以在aside元素中添加一个弹出窗，然后把它当成一个广告单元，在很多论坛上经常会看到在右下角会弹出一个框，可以给它加一下样式，然后让他弹出来就会是一个广告单元；既可以通过aside来进行承载） 1234567891011121314151617181920 语法< /h1> 文章的正文......< /p> 名词解释< /h1> 语法：这是一个对语言来说很重要的内容体< /p> < /aside>< /article> 评论 2018-3-10< /a>< /li> 大牛：真希望能好好学习一下 < /a>< /li> < /nav>< /aside> nav元素：表示导航 通过使用article元素我们可以发现当前页面的语义化是非常明确的，让人读起来是一下就可以了然，我就知道你当前是在哪、或者做什么的、它的具体作用是什么；","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"新增的主题结构元素（一）","slug":"HTML/新增的主题结构元素（一）","date":"2019-04-11T05:44:09.000Z","updated":"2019-04-29T08:11:05.724Z","comments":true,"path":"2019/04/11/HTML/新增的主题结构元素（一）/","link":"","permalink":"http://yoursite.com/2019/04/11/HTML/新增的主题结构元素（一）/","excerpt":"","text":"article元素article元素 代表文档、页面或应用程序中独立的、完整的、可以独自被外部引用的内容。它可以是一篇博客或者报刊中的文章，一篇论坛帖子、一段用户评论或独立的插件，或其他任何独立的内容。 eg: 12345678910 YaoRemu< /h1> Hello，欢迎来到YaoRemu的博客< /p> Hello< /p> 这是底部< /p> < /footer>< /article> article元素是可以嵌套使用的 内层的内容在原则上需要与外层的元素相关联（eg：一篇博客文章中，针对于该文章的评论，就可以使用嵌套article元素的方式，因它们有一个所属关系，用来呈现当前的评论，可以使用article元素来进行包裹一下） eg: 123456789101112131415161718192021 YaoRemu< /h1> Hello，欢迎来到YaoRemu的博客< /p> < /header> 作者 < /header> 评论 < /p> time < /footer> < /aritcle> 这是底部< /p> < /footer>< /article> 为了更加的语义化，更加的方便我们去阅读源码，可以使用article元素，使用article元素代替div后，从语义化来说，它是非常方便的，但是从内容的呈现角度来说，他们是没有区别的。 article元素可以用来表示插件eg: 12345678910111213141516171819202122232425262728 YaoRemu< /h1> Hello，欢迎来到YaoRemu的博客< /p> < /header> 作者 < /header> 评论 < /p> time < /footer> < /aritcle> 这是底部< /p> < /footer>< /article> 这是一个内嵌页面< /h1> < /embed> < /object>< /article> eg: < embed>标签定义嵌入的内容，比如插件（演示中表示引入当前页面）","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"新增的元素和废除的元素","slug":"HTML/新增的元素和废除的元素","date":"2019-04-11T04:11:36.000Z","updated":"2019-04-29T08:09:40.552Z","comments":true,"path":"2019/04/11/HTML/新增的元素和废除的元素/","link":"","permalink":"http://yoursite.com/2019/04/11/HTML/新增的元素和废除的元素/","excerpt":"","text":"新增的元素新增的结构元素section、article、aside、header、hgroup、footer、nav、figure section：页面中的内容块（eg：章节、页眉、页脚……），可以与< h1>~< h6>等元素结合使用，表示文档的结构 article：页面中的一块与上下文不相干的独立内容（eg：博客中的一篇文章、报纸中的一篇文章） aside：表示article元素内容之外的，与article元素内容相关的补助信息 header：表示页面中的一个内容区域块，通常用它来表示标题 hgroup：用于对整个页面或者页面中的一个内容块的标题进行结合 footer：表示页面中的一个部分、一个区域块，通常表示这个区域块的脚部（底部），通常我们会用它来承载作者的姓名，日期等一下与作者相关的元素 nav：表示页面中的导航链接部分 figure：表示一段独立的流的内容，一般表示文档中主体流内容中的一个独立的单元 新增的其他元素video、audio、embed、mark、progress、meter、time、ruby、rt、rp、wbr、canvas、command、details、datalist、datagrid、keygen、output、source、menu video：video元素来定义视频（eg：电影片段、视频流） audio：定义音频、音乐或者音频流 canvas：画布，对于画布我们比较注重，因为无论是在应用当中还是在游戏当中，我们对canvas的应用都比较多；canvas表示图形（eg：图表或者其他图形），这个元素本身没有行为，仅仅提供一块画布，但它的一个绘图API展示给客户端JavaScript以及脚本，能够把想绘制的东西绘制在这块画布上 新增的input元素的类型email、url、number、range、Date Pickers email：email表示必须输入的email地址 url：表示文本框输入的一个地址 number：表示数字 range：表示输入框内的一个数字的范围值 Date Pickers：关于日历的日期，时间， 废除的元素能使用CSS替代的元素：basefont、big、center、font、s、tt、u等不再使用frame框架对于< frameset>元素，< frame>元素以及< noframes>元素，由于frame框架对网页可用性存在负面的影响，在HTML5当中以及不支持frame框架，只支持iframe，或者用服务器创建的由多个页面组成的复合页面的形式，同时，以上三个元素被废除 只能部分浏览器支持的元素其他被废除的元素新增的属性和废除的属性新增的属性 表单相关的属性 链接相关的属性 其他属性 废除的属性在后面的文章进行详解","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"HTML5与HTML4区别","slug":"HTML/HTML5与HTML4区别","date":"2019-04-10T09:53:56.000Z","updated":"2019-04-29T08:04:34.114Z","comments":true,"path":"2019/04/10/HTML/HTML5与HTML4区别/","link":"","permalink":"http://yoursite.com/2019/04/10/HTML/HTML5与HTML4区别/","excerpt":"","text":"推出理由及目标HTML5的储蓄，对于Web来说的意义是非常重大的，因为他的意图是想把目前Web上纯在的各种问题一并解决掉了。 Web浏览器之间的兼容性很低 （规范不统一，没有标准化） 文档结构不够明确 （之前表示文档的标题、正文都是使用< div>来排版，结构比较混乱） Web应用程序的功能收到了限制 世界知名浏览器厂商对HTML5的支持：微软（IE9以下不支持）、Google、苹果、opera、Mozilla 语法的改变内容类型文件扩展符（.html、.htm）与内容类型（text.html）保持不变； DOCTYPE声明在HTML4中，我们要明确的指出是哪一个版本；而在HTML5中可以省略部分内容； eg: < !DOCTYPE html> 指定字符编码在HTML4中需要很多声明；eg: < meta http-equiv=\"content-type\" content=\"text/html;charset=UTF-8\"> 在HTML5中则非常简单；eg: < meta charset=\"UTF-8\"> 可以省略标记的元素在HTML5中，元素的标记可以进行省略（详细内容之后再提）； 具有boolean值的属性当这些属性值不指定属性值时，默认表现为true；如果想将属性设为固定的true，可将属性值设为属性名，或者字符串设置为空，不写（默认为true）； 如果想将属性值设为false，可不写该属性； eg: 前三true，最后一个false 省略引号指定属性值时，必须指定引号；但是在HTML5中，可以省略引号;","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"全局属性","slug":"HTML/前端学习-全局属性","date":"2019-04-10T09:08:19.000Z","updated":"2019-04-29T08:19:20.410Z","comments":true,"path":"2019/04/10/HTML/前端学习-全局属性/","link":"","permalink":"http://yoursite.com/2019/04/10/HTML/前端学习-全局属性/","excerpt":"","text":"contentEditable属性允许用户编辑元素中的内容，取值为true【可编辑】、false【不可编辑】eg: designMode属性指定整个页面是否可以编辑（只能在JavaScript中修改编辑），取值：on【可编辑】、off【不可编辑】 hidden属性通知浏览器不渲染该元素，使该元素为不可见状态，取值：true【可见状态】、false【不可见状态】eg:不可见状态 spellcheck属性针对input元素与textarea文本输入框提供的新属性，对用户输入的文本内容进行拼写和文本检查eg: tabindex属性不断敲击tab键，让窗口或页面中的控件获得焦点，对窗口中的所有控件进行遍历，每一个tableindex属性表示该接口是第几个访问到的eg:","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"【极客】前端学习","slug":"【极客】前端学习","permalink":"http://yoursite.com/tags/【极客】前端学习/"}]},{"title":"MarkDown进阶操作","slug":"MarkDown/MarkDown进阶操作","date":"2019-04-10T08:26:46.000Z","updated":"2019-04-14T07:02:48.654Z","comments":true,"path":"2019/04/10/MarkDown/MarkDown进阶操作/","link":"","permalink":"http://yoursite.com/2019/04/10/MarkDown/MarkDown进阶操作/","excerpt":"","text":"图片处理有时候希望图片变得小一点，或者让他靠左边，使得排版更加美观，但是默认没有提供这类操作，可以直接引入HTML来设置； 基本形式 ！[图片描述]（图片链接） 例子： ！[头像]（ http://ww1.sinaimg.cn/large/8c0b2220gy1g1ae3jfoogj20du0duwf0.jpg ） 自定义尺寸 < img width=’150’ height=’150’ src=” http://ww1.sinaimg.cn/large/8c0b2220gy1g1ae3jfoogj20du0duwf0.jpg “> 插入音乐在网易云音乐生成外连接，直接复制黏贴即可；（如果不想自动播放，可以把auto改成0） < iframe frameborder=”no” border=”0” marginwidth=”0” marginheight=”0” width=330 height=86 src=”//music.163.com/outchain/player?type=2&id=29979976&auto=1&height=66”> 插入视频 视频与图片和音乐同理，不在赘述； 设置不同的字体颜色 < font color=red>我是红色 eg: 我是红色 设置不同类型的字体 < font face=”黑体”>我是黑体 eg: 我是黑体 添加背景色 < table>< tr>< td bgcolor=”red”> 背景色是:red < / td>< / tr>< / table> eg: 背景色是:red","categories":[{"name":"教学","slug":"教学","permalink":"http://yoursite.com/categories/教学/"}],"tags":[{"name":"MarkDown基本语法","slug":"MarkDown基本语法","permalink":"http://yoursite.com/tags/MarkDown基本语法/"}]},{"title":"网络端口地址转换NAPT配置","slug":"Cisco/网络端口地址转换NAPT配置","date":"2019-03-31T09:58:35.000Z","updated":"2019-04-14T07:04:53.462Z","comments":true,"path":"2019/03/31/Cisco/网络端口地址转换NAPT配置/","link":"","permalink":"http://yoursite.com/2019/03/31/Cisco/网络端口地址转换NAPT配置/","excerpt":"","text":"拓扑图 相关知识①：NAT将网络划分为内部网络和外部网络两部分，局域网主机利用NAT访问网络时，是将局域网内部的本地地址转换为全局地址（互联网合法的IP地址）后转发数据包； 相关知识②：NAT分为两种类型：NAT（网络地址转换）和NAPT（网络端口地址转换IP地址对应一个全局地址）； 相关知识③：NAPT：使用不同的端口来映射多个内网IP地址到一个指定的外网IP地址，多对一。NAPT采用端口多路复用方式。内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可以隐瞒内部的所有主机，有效的避免来自Internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式 配置命令配置Router0enable configure terminal hostname R0 配置端口interface fa0/0 ip address 192.168.1.1 255.255.255.0 no shutdown exit interface s0/0/0 ip address 200.1.1.1 255.255.255.0 no shutdown clock rate 64000 exit 配置Router1enable configure terminal hostname R1 配置端口interface s0/0/0 ip address 200.1.1.2 255.255.255.0 no shutdown exit interface fa0/0 ip address 200.1.2.1 255.255.255.0 no shutdown exit 配置Router0静态路由ip route 200.1.2.0 255.255.255.0 200.1.1.2 配置Router1静态路由ip route 192.168.1.0 255.255.255.0 200.1.1.1 查看路由表end show ip route 使用PC1测试能否与服务器通信CMD Web浏览器 Router0上进行网络端口地址转换NAPT配置interface fa0/0 ip nat inside //设定私有地址连接口 exit interface fa2/0 ip nat outside //设定公有地址连接口 exit access-list 1 permit 192.168.1.0 0.0.0.255 //建立一个控制列表，列表名为1，用来定义内部使用的私有IP地址段，为地址段转换为公网IP做准备 ip nat pool 5ijsj 200.1.1.3 200.1.1.3 netmask 255.255.255.0 //定义一个IP地址池 ip nat inside source list 1 pool 5ijsj overload //启用内部源地址转换为动态NAT //无overload表示多对多，有overload表示多对一 end show ip nat translations //查看NAT转发表 实验结果PC1使用Web浏览器范文服务器 查看NAT转发表show ip nat translations(有1个结果) PC2使用web浏览器访问服务器 eg: 再次查看NAT转发表show ip nat translations(有2个结果) eg:","categories":[{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/categories/Cisco/"}],"tags":[{"name":"Cisco基础","slug":"Cisco基础","permalink":"http://yoursite.com/tags/Cisco基础/"}]},{"title":"网络地址转换NAT配置","slug":"Cisco/网络地址转换NAT配置","date":"2019-03-30T07:12:04.000Z","updated":"2019-04-14T07:04:55.628Z","comments":true,"path":"2019/03/30/Cisco/网络地址转换NAT配置/","link":"","permalink":"http://yoursite.com/2019/03/30/Cisco/网络地址转换NAT配置/","excerpt":"","text":"拓扑图 相关知识①：网络地址转换NAT（Network Address Translation）,被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了IP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。 相关知识②：默认情况下，内部IP地址是无法被路由到外网的，内部主机10.1.1.1要与外部Internet通信，IP包到达NAT路由器时，IP包头的源地址10.1.1.1被替换成一个合法的外网IP，并在NAT转发表中保存这条记录。 当外部主机发送一个应答到内网时，NAT路由器收到后，查看当前NAT转换表，用10.1.1.1替换掉这个外网地址。 相关知识③：NAT将网络划分为内部网络和外部网络两部分，局域网主机利用NAT访问网络时，将局域网内部的本地地址转换为全局地址（互联网合法的IP地址）后转发数据包； 相关知识④：NAT分为两种类型：NAT（网络地址转换）和NAPT（网络端口地址转换IP地址对应一个全局地址）；①、 静态NAT：实现内部地址与外部地址一对一映射。现实中，一般都用于服务器；②、 动态NAT：定义一个地址池，自动映射，也是一对一的。现实中，用的比较少；③、 NAPT：使用不同的端口来映射多个内网IP地址到一个指定的外网IP地址，多对一； 配置命令配置Router0enable configure terminal hostname R0 配置路由器端口interface fa0/0 ip address 192.168.1.1 255.255.255.0 no shutdown exit interface s0/0/0 ip address 222.0.1.1 255.255.255.0 no shutdown clock rate 64000 exit 配置Router1enable configure terminal hostname R1 配置路由器端口interface s0/0/0 ip address 222.0.1.2 255.255.255.0 no shutdown exit interface fa0/0 ip address 222.0.2.1 255.255.255.0 no shutdown exit Router0静态路由配置ip route 222.0.2.0 255.255.255.0 222.0.1.2 Router1静态路由配置ip route 192.168.1.0 255.255.255.0 222.0.1.1 使用PC0尝试与服务器通信ping 192.168.1.2 （成功通信） Web浏览器 （成功通信） Router0进行NAT配置interface fa0/0 ip nat inside //设定私有地址连接口(局域网) exit interface fa s0/0/0 ip nat outside //设定公有地址连接口(广域网) exit ip nat inside source static 192.168.1.2 222.0.1.3 //设置NAT地址，将内网地址映射为外网地址 end show ip nat translations //查看NAT转发表 知识点①：对于路由器来说：①inside对应的是access-list（访问控制列表）、②outside对应的是转换地址池； 实验结果ping被转换后的地址： 222.0.1.3 （成功通信） Web浏览器中尝试访问转换后的地址：222.0.1.3 （成功通信）","categories":[{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/categories/Cisco/"}],"tags":[{"name":"Cisco基础","slug":"Cisco基础","permalink":"http://yoursite.com/tags/Cisco基础/"}]},{"title":"扩展IP访问控制列表配置","slug":"Cisco/扩展IP访问控制列表配置","date":"2019-03-29T10:14:23.000Z","updated":"2019-04-14T07:05:41.188Z","comments":true,"path":"2019/03/29/Cisco/扩展IP访问控制列表配置/","link":"","permalink":"http://yoursite.com/2019/03/29/Cisco/扩展IP访问控制列表配置/","excerpt":"","text":"拓扑图 知识点①：访问控制列表定义的典型规则主要有以下：源地址，目标地址，上层协议，时间区域；扩展IP访问列表（编号100-199、2000、2699）使用以上四种组合来进行转发或阻断分组；可以根据数据包的源IP、目的IP、源接口、目的接口、协议来定义规则，进行数据包的过滤。 知识点②：扩展IP访问列表的配置包括以下两部分：①定义扩展IP访问列表；②将扩展IP访问列表应用于特定接口上； 配置命令配置Router0端口enable configure terminal hostname R0 interface fa0/0 ip address 172.16.1.1 255.255.255.0 no shutdown exit interface fa0/1 ip address 172.16.2.1 255.255.255.0 no shutdown exit 配置Router1端口enable configure terminal hostname R1 interface fa0/1 ip address 172.16.2.2 255.255.255.0 no shutdown exit interface s0/0/0 ip address 172.16.3.1 255.255.255.0 no shutdown clock rate 64000 配置Router2端口enable configure terminal hostname R2 interface s0/0/0 ip address 172.16.3.2 255.255.255.0 no shutdown exit interface fa0/0 ip address 172.16.4.1 255.255.255.0 no shutdown exit 配置Router0静态路由ip route 0.0.0.0 0.0.0.0 172.16.2.2 配置Router2静态路由ip route 0.0.0.0 0.0.0.0 172.16.3.1 配置Router1静态路由ip router 172.16.1.0 255.255.255.0 172.16.2.1 ip router 172.16.4.0 255.255.255.0 172.16.3.2 end show ip route //查看路由表 实验PC0尝试与服务器通信ping 172.16.4.2（此时成功通信） 使用网页尝试通信 Router1上配置扩展IP访问控制列表configure terminal 允许源主机地址使用TCP协议通过出站端口访问目标地址WEB服务器access-list 100 permit tcp host 172.16.1.2 host 172.16.4.2 eq www 禁止源主机地址使用icmp协议通过出站端口到达目标主机地址WEB服务器access-list 100 deny icmp host 172.16.1.2 host 172.16.4.2 echo 知识点①：echo表示：传递echo报文 知识点②：ICMP协议（Internet Control Message Protocol Internet控制报文协议）：TCP/IP协议簇的一个子协议，用在IP主机，路由器之间传递控制消息；控制消息：指网络通不通，主机是否可达、路由是否可用等网络本身的消息； 将ACL应用到端口interface s0/0/0 ip access-group 100 out end 实验结果ping 172.16.4.2（此时无法通信） 使用网页尝试通信（此时成功通信）","categories":[{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/categories/Cisco/"}],"tags":[{"name":"Cisco基础","slug":"Cisco基础","permalink":"http://yoursite.com/tags/Cisco基础/"}]},{"title":"标准 IP 访问控制列表配置","slug":"Cisco/标准-IP-访问控制列表配置","date":"2019-03-28T07:50:17.000Z","updated":"2019-04-14T07:03:40.027Z","comments":true,"path":"2019/03/28/Cisco/标准-IP-访问控制列表配置/","link":"","permalink":"http://yoursite.com/2019/03/28/Cisco/标准-IP-访问控制列表配置/","excerpt":"","text":"拓扑图 相关知识①：ACLs 的全称为 接入控制列表(Access Control Lists),也称访问控制列表(Access Lists),俗称防火墙，在有的文档中还称包过滤。 相关知识②：ACLs 通过定义一些规则对网络设备接口上的数据报文进行控制；运行通过或者丢失，从而提高网络可管理型和安全性； 相关知识③：IP ACL分为两种：标准IP访问列表和扩展IP访问列表，编号范围为 1~99、1300~1999、100~199、2000~2699;标准IP访问控制列表：根据数据包的源地址定义规则，进行数据包的过滤；扩展IP访问控制列表：根据数据包的源IP、目的IP、源接口、目的端口、协议来定义规则，进行数据包的过滤； 相关知识④：IP ACL 基于接口进行规则的应用，分为：入栈应用和出栈应用； 配置命令配置路由器0enable configure terminal hostname R0 配置端口interface fa 0/0 ip address 172.16.1.1 255.255.255.0 no shutdown exit interface fa0/1 ip address 172.16.2.1 255.255.255.0 no shutdown exit interface s0/0/0 ip address 172.16.3.1 255.255.255.0 no shutdown clock rate 64000 exit 配置路由器1enable configure terminal hostname R1 配置端口interface s0/0/0 ip address 172.16.3.2 255.255.255.0 no shutdown exit interface f0/0 ip address 172.16.4.1 255.255.255.0 no shutdown exit 配置路由器0的静态路由配置静态路由ip route 172.16.4.0 255.255.255.0 172.16.3.2 配置路由器1的静态路由配置静态路由ip route 0.0.0.0 0.0.0.0 172.16.3.1 查看路由表end show ip route PC0、PC1尝试能否与PC2通信PC0: （此时成功通信） PC1: （此时成功通信） 在路由器0中配置访问控制列表建立ACL命名为 5ijsjip access-list standard 5ijsj permit 172.16.1.0 0.0.0.255 //允许网段通过 deny 172.16.2.0 0.0.0.255 //禁止网段通过 interface s0/0/0 ip access-group 5ijsj out //将ACL应用到相关端口 end 知识点：in表示过滤入口的包；out表示过滤出口的包； 实验结果再次PC0、PC1尝试能否与PC2通信PC0: （由于ACL允许 172.16.1.0 网段通过，所以PC0成功通信） PC1: （由于ACL禁止 172.16.1.0 网段通过，所以PC1通信失败）","categories":[{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/categories/Cisco/"}],"tags":[{"name":"Cisco基础","slug":"Cisco基础","permalink":"http://yoursite.com/tags/Cisco基础/"}]},{"title":"OSPF、RIP小记","slug":"Cisco/OSPF、RIP小记","date":"2019-03-28T07:08:27.000Z","updated":"2019-04-14T07:02:43.120Z","comments":true,"path":"2019/03/28/Cisco/OSPF、RIP小记/","link":"","permalink":"http://yoursite.com/2019/03/28/Cisco/OSPF、RIP小记/","excerpt":"","text":"OSPF可将OSPF比喻成导航，可以实时更新； RIP将RIP比喻成路标，是固定不变的，除非人为修改；","categories":[{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/categories/Cisco/"}],"tags":[{"name":"Cisco笔记","slug":"Cisco笔记","permalink":"http://yoursite.com/tags/Cisco笔记/"}]},{"title":"路由器综合路由配置","slug":"Cisco/路由器综合路由配置","date":"2019-03-27T07:50:26.000Z","updated":"2019-04-14T07:06:14.446Z","comments":true,"path":"2019/03/27/Cisco/路由器综合路由配置/","link":"","permalink":"http://yoursite.com/2019/03/27/Cisco/路由器综合路由配置/","excerpt":"","text":"拓扑图 相关知识①：运行多个路由协议进程，系统软件提供了路由信息从一个路由进程重新分布到另一个路由进程的功能；路由的相互重分布可以再所有的IP路由协议之间进行。相关命令：redistribute protocol … 相关知识②：路由重分发，可在同一网内使用多种路由协议，为了实现多种路由协议的协同工作，路由器可以使用路由重分发(route redistribution) 将学习到的一种路由协议的路由通过另一种路由协议广播出去，这样网络的所有部分就可以互通了。为了实现重分发，路由器必须同时运行多种路由协议，这样每种路由协议才可以取路由表中的所有或部分其他协议的路由来进行广播； 配置命令配置三层路由器Switch0enable configure terminal 开启Vlanvlan 2 exit 划分Vlan给端口fa0/10interface fa0/10 switchport access vlan 2 exit 注意：由于vlan1默认是划分给所有端口的，所以可以省略划分vlan1 配置Vlaninterface vlan 1 ip address 192.168.1.1 255.255.255.0 no shutdown exit interface vlan 2 ip address 192.168.2.1 255.255.255.0 no shutdown exit 查看Vlan信息end show interface vlan 1 在路由器上启动rip协议configure terminal ip routing //开启三层交换机路由功能 router rip //配置RIP协议 network 192.168.1.0 //宣告本地路由和相连路由之间的网段 network 192.168.2.0 version 2 //设置RIP版本 配置路由器Router0enable configure terminal hostname R1 配置端口interface fa0/0 ip address 192.168.2.2 255.255.255.0 no shutdown exit interface fa0/1 ip address 192.168.3.1 255.255.255.0 no shutdown exit 在路由器启动rip协议router rip network 192.168.2.0 version 2 在路由器启动ospf协议router ospf 1 //配置OSPF协议 network 192.168.3.0 0.0.0.255 area 0 //宣告直连网络 配置路由器Router1enable configure terminal hostname R2 配置端口interface fa0/1 ip address 192.168.3.2 255.255.255.0 no shutdown exit interface fa0/0 ip address 192.168.4.1 255.255.255.0 no shutdown exit 在路由器启动ospf协议router ospf 1 network 192.168.3.0 0.0.0.255 area 0 network 192.168.4.0 0.0.0.255 area 0 查看路由表end show ip route 实验结果使用Router0（中间的路由器）测试与两台PC是否能够通信ping 192.168.1.2 (success) ping 192.168.4.2 (success) 尝试PC0与PC1通信 （此时无法通信） 配置Router0（中间的路由器）configure terminal 路由重分布router rip redistribute ospf 1 //ospf路由重发布 exit router ospf 1 redistribute rip subnets //rip路由重发布 end 注意： 本例在Packet Tracer 5.2上能够正常运行，但是在Packet Tracer 5.3 上的Switch0不能学习到192.168.3.0/192.168.4.0的路由信息，所以需要给Switch0指定静态路由: ip route 0.0.0.0 0.0.0.0 192.168.2.2 再次Router1查看路由表 （查看路由重发布后该路由器学习到的路由） show ip route 再次尝试PC0与PC1通信 （成功通信）","categories":[{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/categories/Cisco/"}],"tags":[{"name":"Cisco基础","slug":"Cisco基础","permalink":"http://yoursite.com/tags/Cisco基础/"}]},{"title":"路由器OSPF动态路由配置","slug":"Cisco/路由器OSPF动态路由配置","date":"2019-03-26T00:47:01.000Z","updated":"2019-04-14T07:05:59.292Z","comments":true,"path":"2019/03/26/Cisco/路由器OSPF动态路由配置/","link":"","permalink":"http://yoursite.com/2019/03/26/Cisco/路由器OSPF动态路由配置/","excerpt":"","text":"拓扑图 相关知识①：OSPF(Open Shortest Path First 开放式最短路径优先)是一个内部网关协议(Interior Gateway Protocol，检测IGP)，用在单一自治系统(autonomous system,AS)内决策路由。与RIP相比，OSPF是链路状态协议，而RIP是距离矢量协议。 相关知识②：OSPF开放式最短路径优先协议，是目前网络中应用最广泛的路由协议之一；OSPF路由协议通过向全网扩散本设备的链路状态信息，使网络中每台设备最终同步一个具有全网链路状态的数据库，然后路由器采用SPF算法，以自己为根，计算到达其他网络的最短路径，最终形成全网路由信息； 配置命令配置三层交换机S3569enable configure terminal hostname S3569 划分Vlan给端口vlan 10 exit valn 20 exit interface fa 0/10 switchport access vlan 10 exit interface fa 0/20 switchport access vlan 20 exit 配置Vlaninterface vlan 10 ip address 192.168.1.1 255.255.255.0 no shutdown exit interface vlan 20 ip address 192.168.3.1 255.255.255.0 no shutdown exit end show ip route //查看路由表 配置OSPF动态路由协议configure terminal ip routing //开启三层交换机路由功能 router ospf 1 //启动OSPF进程 network 192.168.1.0 0.0.0.255 area 0 //通告直连网络 network 192.168.3.0 0.0.0.255 area 0 end show ip route 知识点①：OSPF宣告是要加反掩码的； 知识点②：area是自治系统区域的标识，eg：如果全局在一个area中，那么它们属于一个自治系统，也成单区域自治系统； 配置路由器R1enable configure terminal hostname R1 配置端口interface fa0/0 no shutdown ip address 192.168.3.2 255.255.255.0 exit interface serial 0/0/0 no shutdown clock rate 64000 ip address 1952.168.4.1 255.255.255.0 end show ip route 配置OSPF动态路由协议configure terminal router ospf 1 network 192.168.3.0 0.0.0.255 area 0 network 192.168.4.0 0.0.0.255 area 0 end show ip route 配置路由器R2enable configure terminal hostname R2 配置端口interface fa 0/0 no shutdown ip address 192.168.2.1 255.255.255.0 exit interface serial 0/0/0 no shutdown ip address 192.168.4.2 255.255.255.0 end show ip route 配置OSPF动态路由协议configure terminal router ospf 1 network 192.168.2.0 0.0.0.255 area 0 network 192.168.4.0 0.0.0.255 area 0 end show ip route 实验结果验证 PC1、PC2 主机之间可以互相通信；eg:","categories":[{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/categories/Cisco/"}],"tags":[{"name":"Cisco基础","slug":"Cisco基础","permalink":"http://yoursite.com/tags/Cisco基础/"}]},{"title":"路由器RIP动态路由配置","slug":"Cisco/路由器RIP动态路由配置","date":"2019-03-25T06:08:52.000Z","updated":"2019-04-14T07:04:17.509Z","comments":true,"path":"2019/03/25/Cisco/路由器RIP动态路由配置/","link":"","permalink":"http://yoursite.com/2019/03/25/Cisco/路由器RIP动态路由配置/","excerpt":"","text":"拓扑图 相关知识①：动态路由是指路由器能够自动的建立自己的路由表，并且根据实际情况适时的进行调整； 相关知识②：RIP(routing infromation protocol)路由信息协议：一种内部网关协议（IGP），是一种动态路由选择协议；RIP协议基于距离矢量算法，使用“跳数(metric)”来衡量到达目标地址的路由协议。（该协议的路由器只关心自己周围的世界，只与自己相连的路由器交换信息，范围在15跳之内）； 相关知识③：RIPv1与RIPv2的区别： 配置命令配置三层交换机enable configure terminal hostname S3560 划分vlan给端口vlan 10 exit vlan 20 exit interface fa0/10 switchport access vlan 10 exit interface fa0/20 switchport access vlan20 exit end show vlan 配置vlanconfigure terminal interface vlan 10 ip address 192.168.1.1 255.255.255.0 no shutdown exit interface vlan 20 ip address 192.168.3.1 255.255.255.0 no shutdown end show ip router //查看路由表 show running //查看当前配置 在三层交换机上启动rip协议configure terminal router rip //启动rip协议 network 192.168.1.0 //宣告本地路由和相连路由之间的网段 network 192.168.3.0 version 2 //设置RIP版本为2 end show ip route 配置Router2enable configure terminal hostname R2 配置端口interface fa0/0 no shutdown ip address 192.168.3.2 255.255.255.0 interface serial0/0/0 //配置路由器的串行接口 no shutdown ip address 192.168.4.1 255.255.255.0 clock rate 64000 //配置时钟频率 end show ip route 知识点①：在Packet Tracert模拟器中，必须设置时钟速率，否则路由器之间无法ping通； 知识点②：serial口：路由器连接路由器就要用路由器上的Serial端口连接 在路由器上启动rip协议conf t router rip network 192.168.3.0 network 192.168.4.0 version 2 exit 配置Router1enable configure terminal hostname R1 配置端口interface fa0/0 no shutdown ip address 192.168.2.1 255.255.255.0 interface serial0/0/0 no shutdown ip address 192.168.4.2 255.255.255.0 end show ip route 在路由器上启动rip协议configure terminal router rip network 192.168.2.0 network 192.168.4.0 version 2 end 实验结果查看拓扑图中的的两台PC是否正常通信；eg:","categories":[{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/categories/Cisco/"}],"tags":[{"name":"Cisco基础","slug":"Cisco基础","permalink":"http://yoursite.com/tags/Cisco基础/"}]},{"title":"路由器静态路由配置","slug":"Cisco/路由器静态路由配置","date":"2019-03-24T00:13:41.000Z","updated":"2019-04-14T07:04:13.028Z","comments":true,"path":"2019/03/24/Cisco/路由器静态路由配置/","link":"","permalink":"http://yoursite.com/2019/03/24/Cisco/路由器静态路由配置/","excerpt":"","text":"拓扑图 注：由于路由器[2811]初始时没有Serial接口，所以需要在图形化界面安装上[WIC-2T]组件； 配置命令配置Router1各个端口enable configure terminal hostname R1 interface fa0/1 no shutdown //开启端口 ip address 192.168.1.1 255.255.255.0 //配置端口IP以及子网掩码 exit interface serial 0/0/0 //配置串行接口 no shutdown ip address 192.168.3.1 255.255.255.0 clock rate 64000 //设置时钟评率，起同步作用 end 知识点①：Serial是用V35线来传输数据是同步的，连接时需要DCE同步时钟速率； 知识点②： 路由器连接路由器要用路由器上的Serial端口连接； 配置Router2各个端口enable configure terminal hostname R2 interface fa0/1 no shutdown ip address 192.168.2.1 255.255.255.0 exit interface serial 0/0/0 ip address 192.168.3.2 255.255.255 no shutdown end 配置R1静态路由enable configure terminal ip route 192.168.2.0 255.255.255.0 192.168.3.2 //配置静态路由 end show ip route //查看路由表 知识点①：ip route 静态路由格式： ip route 目标网段 目标的子网掩码 目标网段的接口 配置R2静态路由enable configure terminal ip route 192.168.1.0 255.255.255.0 192.168.3.1 //配置静态路由 end show ip route 实验结果测试PC1是否ping通PC2;eg:","categories":[{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/categories/Cisco/"}],"tags":[{"name":"Cisco基础","slug":"Cisco基础","permalink":"http://yoursite.com/tags/Cisco基础/"}]},{"title":"路由器单臂路由配置","slug":"Cisco/路由器单臂路由配置","date":"2019-03-23T00:20:40.000Z","updated":"2019-04-14T07:04:15.321Z","comments":true,"path":"2019/03/23/Cisco/路由器单臂路由配置/","link":"","permalink":"http://yoursite.com/2019/03/23/Cisco/路由器单臂路由配置/","excerpt":"","text":"拓扑图 配置命令配置Switchenable configure terminal vlan 2 exit vlan 3 exit interface fastEthernet 0/2 switchport access vlan 2 //将端口划分给Vlan2 exit interface fastEthernet 0/3 switchport access vlan 3 //将端口划分给Vlan3 exit interface fastEthernet 0/1 switchport mode trunk //设置端口为trunk模式 知识点：数据包经过trukn会封装新的包头，添加对应的Vlan信息；当目标接受到该数据包，即可解包查看对应的Vlan，然后发送个对应的Vlan； 配置Routerenable configure terminal interface fastEthernet 0/0 no shutdown //开启路由器端口 exit interface fastEthernet 0/0.1 //配置虚拟子接口 encapsulation dot1q 2 //配置以太网子接口Vlan号，封装格式为802.1q ip address 192.168.1.1 255.255.255.0 //设置端口ip及其子网掩码 exit interface fastEthernet 0/0.2 encapsulation dot1q 3 ip address 192.168.2.1 255.255.255.0 end show ip route //查看路由表信息 知识点①：dot1q(802.1q): 虚拟局域网标准，在路由器中dot1q为虚拟局域网的封装模式； 知识点②：为什么要划分子接口？ 多vlan通信，各vlan间的网段不同，网关不同，但是交换机只连接路由器上的一个物理端口，所以划分多个虚拟子接口，以便于配置多个地址作为vlan的网关地址 实验结果PC1与PC2实现多Vlan通信； eg:","categories":[{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/categories/Cisco/"}],"tags":[{"name":"Cisco基础","slug":"Cisco基础","permalink":"http://yoursite.com/tags/Cisco基础/"}]},{"title":"快速生成树配置","slug":"Cisco/快速生成树配置","date":"2019-03-22T05:34:22.000Z","updated":"2019-04-14T07:03:35.137Z","comments":true,"path":"2019/03/22/Cisco/快速生成树配置/","link":"","permalink":"http://yoursite.com/2019/03/22/Cisco/快速生成树配置/","excerpt":"","text":"拓扑图 配置命令Switch1配置命令enable //进入特权模式 show spanning-tree //查看生成树配置 configure terminal //全局配置模式 hostname S1 //交换机更名 int fa 0/10 switchport access vlan 10 //把端口划分给Vlan 10 exit int rang fa 0/1-2 switchport mode trunk //配置端口为trunk模式 exit spanning-tree mode rapid-pvst //把交换机的生成树模式由默认的STP改成RSTP(快速生成树) end 知识点：trunk端口可封装Vlan标签，用于多Vlan交换机 Switch2配置命令enable configure terminal hostname S2 interface fa0/10 switchport access vlan 10 exit interface range fa0/1-2 switchport mode trunk exit spanning-tree mode rapid-pvst //把交换机的生成树模式由默认的STP改成RSTP(快速生成树) end show spanning-tree 知识点：PVST(per Vlan Spanning Tree)：生成树协议； RSTP(Rapid Spanning Tree Protocol):快速生成树协议;在STP的基础上实现了快速收敛，并增加了边缘端口的概念及保护； 实验结果 当主链路处于down状态的时候，交换机能够自动切换到备份链路，保证数据的正常转发； eg: 使用PC1 ping PC2ipconfig ping -t 192.168.1.3 //-t表示在手动停止前，一直发送数据包 关闭S2正常运行端口，测试快速生成树协议en conf t interface fa 0/1 shutdown //关闭正常运行的端口测试是否自动切换到备份链路 使用ping -t ip 不断的请求PC2，然后关闭正在通信的Fa0/1接口，最后查看PC1中通信情况是否正常（即交换机是否自动切换到备份链路）；","categories":[{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/categories/Cisco/"}],"tags":[{"name":"Cisco基础","slug":"Cisco基础","permalink":"http://yoursite.com/tags/Cisco基础/"}]},{"title":"利用三层交换机实现Vlan间路由","slug":"Cisco/利用三层交换机实现Vlan间路由","date":"2019-03-21T11:39:02.000Z","updated":"2019-04-14T07:05:38.841Z","comments":true,"path":"2019/03/21/Cisco/利用三层交换机实现Vlan间路由/","link":"","permalink":"http://yoursite.com/2019/03/21/Cisco/利用三层交换机实现Vlan间路由/","excerpt":"","text":"拓扑图 配置命令配置二层交换机enable //特权模式 configure terminal //全局配置模式 vlan 2 //开启vlan exit vlan 3 exit interface fa0/2 switchport access vlan 2 //配置端口在access模式，允许vlan2通过 exit interface fa0/3 switchport access vlan 3 exit interface fa0/1 switchport mode trunk //配置该端口为trunk模式 exit show vlan //查看vlan配置 配置三层交换机enable configure terminal vlan 2 exit vlan 3 exit interface fa0/1 switchport trunk encapsulation dot1q //给端口封装802.1q协议(dot1q),既trunk链路的中继协议 switchport mode trunk //配置该端口为trunk模式 exit interface fa0/2 switchport access vlan 2 exit interface vlan 2 //配置vlan 2 ip address 192.168.1.1 255.255.255.0 //配置IP及其子网掩码 no shutdown //开启vlan 2 exit interface vlan 3 ip address 192.168.2.1 255.255.255.0 no shutdown exit exit ip routing //启用三层交换机IP路由功能 show ip route //查看路由表 实验结果PC3分别ping测试PC1、PC2，实验结果为： PC3ping通PC1；PC3ping通PC2,实现了路由功能； eg:","categories":[{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/categories/Cisco/"}],"tags":[{"name":"Cisco基础","slug":"Cisco基础","permalink":"http://yoursite.com/tags/Cisco基础/"}]},{"title":"cisco多交换机之间的端口聚合链路","slug":"Cisco/cisco多交换机之间的端口聚合链路","date":"2019-03-20T06:17:27.000Z","updated":"2019-04-14T07:02:29.932Z","comments":true,"path":"2019/03/20/Cisco/cisco多交换机之间的端口聚合链路/","link":"","permalink":"http://yoursite.com/2019/03/20/Cisco/cisco多交换机之间的端口聚合链路/","excerpt":"","text":"拓扑图： 相关知识：port-channel具备了逻辑端口的属性，真正成为一个独立的逻辑端口；端口汇聚是一种逻辑上的抽象过程，将一组具备相同属性的端口，抽象成一个逻辑端口；其不仅能增加网络的带宽，还能提供链路的备份功能，以及负载均衡； 配置命令Switch0的配置命令hostname SwitchA //更名 int port-channel 1 //端口聚合模式 exit int fa0/1 channel-group 1 mode on //将物理端口加入channel-group exit int fa0/2 channel-group 1 mode on exit int fa0/3 channel-group 1 mode on exit int port-channel 1 switchport mode trunk //将端口聚合配置为trunk模式 switchport trunk allowed vlan all Switch1的配置命令hostname SwitchA int port-channel 1 exit interface fa0/1 channel-group 1 mode on exit interface fa0/2 channel-group 1 mode on exit interface fa0/3 channel-group 1 mode on exit int port-channel 1 switchport mode trunk switchport trunk allowed vlan all 结果使用show run查看结果： 知识点 链路聚合的配置，实现交换机间的端口聚合，扩展网络宽带，实现链路冗余备份；","categories":[{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/categories/Cisco/"}],"tags":[{"name":"Cisco基础","slug":"Cisco基础","permalink":"http://yoursite.com/tags/Cisco基础/"}]},{"title":"cisco多交换机上配置基于端口的Vlan隔离办公网络","slug":"Cisco/cisco多交换机上配置基于端口的Vlan隔离办公网络","date":"2019-03-19T10:07:32.000Z","updated":"2019-04-14T07:02:27.328Z","comments":true,"path":"2019/03/19/Cisco/cisco多交换机上配置基于端口的Vlan隔离办公网络/","link":"","permalink":"http://yoursite.com/2019/03/19/Cisco/cisco多交换机上配置基于端口的Vlan隔离办公网络/","excerpt":"","text":"拓扑图 配置命令配置左边的交换机enable //特权模式 configure terminal //全局模式 interface fa 0/1 switchport mode trunk //配置Trunk switchport trunk allowed vlan all //trunk允许所有Vlan流量通行（默认trunk就是允许所有） vlan 10 //开启vlan name RD1 //命名 vlan 20 name RD2 interface range fa0/9-fa0/16 //配置一组接口 switchport access vlan 10 //把该端口划分给Vlan exit interface range f0/17-fa0/24 switchport access vlan 20 exit 配置右边的交换机enable configure terminal interface fa0/1 switchport mode trunk switchport trunk allowed vlan all vlan 10 name RD1 vlan 20 name RD2 interface range fa0/9-fa0/16 switchport access vlan 10 exit interface range fa0/17-fa0/24 switchport access vlan 20 exit 注意： access为链接电脑的端口或者傻瓜交换机（也就是同一Vlan的交换机）；trunk则肯定是连接交换机的（属于多vlan的交换机）; 测试结果结果：PC1与PC3、PC2与PC4之间能相互ping通，除此以外的任意两台电脑上ping不通的；","categories":[{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/categories/Cisco/"}],"tags":[{"name":"Cisco基础","slug":"Cisco基础","permalink":"http://yoursite.com/tags/Cisco基础/"}]},{"title":"No3. Telnet","slug":"Cisco/ciscoTelnet","date":"2019-03-18T08:00:05.000Z","updated":"2019-04-14T07:02:24.627Z","comments":true,"path":"2019/03/18/Cisco/ciscoTelnet/","link":"","permalink":"http://yoursite.com/2019/03/18/Cisco/ciscoTelnet/","excerpt":"","text":"拓扑图: 配置命令: 首先开启Vlan: enable configure terminal interface vlan 1 no shutdown eg: 配置交换机：设置Vlan1 IP及其子网掩码: interface vlan 1 ip address 10.1.1.154 255.255.255.0 exit 设置进入系统视图的密码：enable password **** 设置五条虚拟链接：line vty 0 4 设置特权等级[级别越高权限越大]：privilege level 1 0 设置远程链接(Telnet)的密码：password cisco 设置login验证[如果只设置login,直接输入密码即可；如果设置了login local，则需要输入用户名以及密码]:login 退出VTY[VTY(Virtual typle terminal)虚拟类型终端]的配置：exit 使用PC与交换机进行Telnet测试:Telnet 10.1.1.154 (输入前面密码即可) eg: 结果:","categories":[{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/categories/Cisco/"}],"tags":[{"name":"Cisco基础","slug":"Cisco基础","permalink":"http://yoursite.com/tags/Cisco基础/"}]},{"title":"MarkDown基础教学","slug":"MarkDown/MarkDown基础教学","date":"2019-03-18T08:00:05.000Z","updated":"2019-04-14T07:02:46.267Z","comments":true,"path":"2019/03/18/MarkDown/MarkDown基础教学/","link":"","permalink":"http://yoursite.com/2019/03/18/MarkDown/MarkDown基础教学/","excerpt":"","text":"基础语法标题# h1 ## h2 ### h3 #### h4 ##### h5 ###### h6 段落及区块引用> 这段文字被高亮显示... eg: 这段文字被高亮显示… 插入链接或图片[点击跳转百度](http://www.baidu.com) eg:点击跳转百度 ![图片](https://i.loli.net/2019/03/19/5c903bc01be37.gif) eg: 列表Markdown支持有序列表和无序列表两种形式： 无序列表使用 * 或 + 或 - 标识 * 黄瓜 * 玉米 * 茄子 + 黄瓜 + 玉米 + 茄子 - 黄瓜 - 玉米 - 茄子 有序列表使用数字加.标识，eg: 1. 1. 玉米 2. 黄瓜 3. 茄子 注意：如果在单一列表项中包含了多个段落，为了保证渲染正常，*与段落首字母之间必须保留四个空格。（如果在列表中加入了区块引用，也要缩进4个空格） 分割线*** --- eg: 强调使用 * 或 _ 包裹字符即可。使用单一符号时效果是斜体，使用两个符号标记的效果是加粗； *这里是斜体* _这里是斜体_ eg: 这里是斜体 **这里是加粗** __这里是加粗__ eg: 这里是加粗 高级应用插入代码块使用反引号进行包裹即可； 如果插入一整段代买，需要至少两个以上反引号进行包裹； ` ` `JavaScript //此处声明语言，以便生成高亮效果 function YaoRemu(){ document.write(\"Hello MarkDown!\"); } ` ` ` eg: 123function YaoRemu(){ document.write(\"Hello MarkDown!\");} 插入表格表头|条目一|条目二 :---:|:---:|:---: 项目|项目一|项目二 eg: 表头 条目一 条目二 项目 项目一 项目二 注意：三个杆左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字具有，两边都放置表示文字居中。 其他特殊符号处理：在使用特殊符号时，需要插入反斜杠； eg: \\\\ 输出: \\ 给文字上色手动添加标签’’’’保存即可； eg: 我是蓝色","categories":[{"name":"教学","slug":"教学","permalink":"http://yoursite.com/categories/教学/"}],"tags":[{"name":"MarkDown基本语法","slug":"MarkDown基本语法","permalink":"http://yoursite.com/tags/MarkDown基本语法/"}]},{"title":"MySql服务安装","slug":"其他/MySql服务安装","date":"2019-03-17T07:52:24.000Z","updated":"2019-04-15T08:55:10.097Z","comments":true,"path":"2019/03/17/其他/MySql服务安装/","link":"","permalink":"http://yoursite.com/2019/03/17/其他/MySql服务安装/","excerpt":"","text":"安装过程 先添加安装文件中bin文件夹到用户环境变量(这样才可以使用命令) mysqld –initialize（执行初始化【不添加用户名】/此处注意，如果安装提示出错，可以删除 [data] 文件夹后重试 ） mysqld install (安装MySql) （由于之前已经安装过，所以这里提示 已存在） net start mysql(启动MySql服务) 完成！ 注意：要正确配置[my.ini]中的文件！！！","categories":[{"name":"教学","slug":"教学","permalink":"http://yoursite.com/categories/教学/"}],"tags":[{"name":"安装教程","slug":"安装教程","permalink":"http://yoursite.com/tags/安装教程/"}]}]}